<HTML>
<HEAD>
<TITLE>
Python module: loris</TITLE>
<BODY BGCOLOR="#ffffff">
<H1>Python module: loris</H1>

<HR><H1> Contents </H1>
<UL><LI> <A HREF="#s1_">1. Version</A>
<LI> <A HREF="#s2_">2. Loris class interfaces</A>
<UL><LI> <A HREF="#s2_1_">2.1. class Analyzer</A>
<LI> <A HREF="#s2_2_">2.2. class BreakpointEnvelope</A>
<LI> <A HREF="#s2_3_">2.3. class ExportSpc</A>
<LI> <A HREF="#s2_4_">2.4. class PartialList</A>
<LI> <A HREF="#s2_5_">2.5. class SampleVector</A>
</UL><LI> <A HREF="#s3_">3. Non-object-based procedures</A>
<LI> <A HREF="#s4_">4. Utility functions</A>
</UL>

<A name="s1_">
<HR><H2>1. Version</H2></A>
<P><TT><B>__version__ = Loris 1.0beta1 </B></TT>

<A name="s2_">
<HR><H2>2. Loris class interfaces</H2></A>
<A name="s2_1_">
<H3>2.1. class Analyzer</H3></A>
<P><TT><B>Analyzer(resolutionHz)</B></TT>
<BLOCKQUOTE>  	Construct and return a new Analyzer configured with the given	
		frequency resolution (minimum instantaneous frequency	
		difference between Partials). All other Analyzer parameters 	
		are computed from the specified frequency resolution. 			
	   
</BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Destroy this Analyzer. 								
	   
</BLOCKQUOTE>

<P><TT><B>analyze(vec,srate)</B></TT>
<BLOCKQUOTE>  	Analyze a SampleVector of (mono) samples at the given sample rate 	  	
		(in Hz) and return the resulting Partials in a PartialList. 												
	   
</BLOCKQUOTE>

<P><TT><B>configure(resolutionHz)</B></TT>
<BLOCKQUOTE>  	Configure this Analyzer with the given frequency resolution 
		(minimum instantaneous frequency difference between Partials). 
		All other Analyzer parameters are (re-)computed from the 
		frequency resolution. 		
	   
</BLOCKQUOTE>

<P><TT><B>freqResolution()</B></TT>
<BLOCKQUOTE>  	Return the frequency resolution (minimum instantaneous frequency  		
		difference between Partials) for this Analyzer. 	
	   
</BLOCKQUOTE>

<P><TT><B>ampFloor()</B></TT>
<BLOCKQUOTE>  	Return the amplitude floor (lowest detected spectral amplitude),  			
		in (negative) dB, for this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>windowWidth()</B></TT>
<BLOCKQUOTE>  	Return the frequency-domain main lobe width (measured between 
		zero-crossings) of the analysis window used by this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>freqFloor()</B></TT>
<BLOCKQUOTE>  	Return the frequency floor (minimum instantaneous Partial  				
		frequency), in Hz, for this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>hopTime()</B></TT>
<BLOCKQUOTE>  	Return the hop time (which corresponds approximately to the 
		average density of Partial envelope Breakpoint data) for this 
		Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>freqDrift()</B></TT>
<BLOCKQUOTE>  	Return the maximum allowable frequency difference between 					
		consecutive Breakpoints in a Partial envelope for this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>cropTime()</B></TT>
<BLOCKQUOTE>  	Return the crop time (maximum temporal displacement of a time-
		frequency data point from the time-domain center of the analysis
		window, beyond which data points are considered &quot;unreliable&quot;)
		for this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>bwRegionWidth()</B></TT>
<BLOCKQUOTE>  	Return the width (in Hz) of the Bandwidth Association regions
		used by this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>setFreqResolution(x)</B></TT>
<BLOCKQUOTE>  	Set the frequency resolution (minimum instantaneous frequency  		
		difference between Partials) for this Analyzer. (Does not cause 	
		other parameters to be recomputed.) 									
	   
</BLOCKQUOTE>

<P><TT><B>setAmpFloor(x)</B></TT>
<BLOCKQUOTE>  	Set the amplitude floor (lowest detected spectral amplitude), in  			
		(negative) dB, for this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>setWindowWidth(x)</B></TT>
<BLOCKQUOTE>  	Set the frequency-domain main lobe width (measured between 
		zero-crossings) of the analysis window used by this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>setFreqFloor(x)</B></TT>
<BLOCKQUOTE>  	Set the amplitude floor (minimum instantaneous Partial  				
		frequency), in Hz, for this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>setFreqDrift(x)</B></TT>
<BLOCKQUOTE>  	Set the maximum allowable frequency difference between 					
		consecutive Breakpoints in a Partial envelope for this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>setHopTime(x)</B></TT>
<BLOCKQUOTE>  	Set the hop time (which corresponds approximately to the average
		density of Partial envelope Breakpoint data) for this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>setCropTime(x)</B></TT>
<BLOCKQUOTE>  	Set the crop time (maximum temporal displacement of a time-
		frequency data point from the time-domain center of the analysis
		window, beyond which data points are considered &quot;unreliable&quot;)
		for this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>setBwRegionWidth(x)</B></TT>
<BLOCKQUOTE>  	Set the width (in Hz) of the Bandwidth Association regions
		used by this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>AnalyzerCopy(other)</B></TT>
<BLOCKQUOTE>  	Construct and return a new Analyzer having identical
	parameter configuration to another Analyzer.			
   
</BLOCKQUOTE>

<A name="s2_2_">
<H3>2.2. class BreakpointEnvelope</H3></A>
<P><TT><B>BreakpointEnvelope()</B></TT>
<BLOCKQUOTE>  	Construct and return a new BreakpointEnvelope having no 
		breakpoints and an implicit value of 0. everywhere, 
		until the first breakpoint is inserted.			
	   
</BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Destroy this BreakpointEnvelope. 								
	   
</BLOCKQUOTE>

<P><TT><B>valueAt(x)</B></TT>
<BLOCKQUOTE>  	Return the interpolated value of this BreakpointEnvelope at 
		the specified time.							
	   
</BLOCKQUOTE>

<P><TT><B>insertBreakpoint(time,value)</B></TT>
<BLOCKQUOTE>  	Insert a breakpoint representing the specified (time, value) 
		pair into this BreakpointEnvelope. If there is already a 
		breakpoint at the specified time, it will be replaced with 
		the new breakpoint.
	   
</BLOCKQUOTE>

<P><TT><B>BreakpointEnvelopeCopy(other)</B></TT>
<BLOCKQUOTE>  	Construct and return a new BreakpointEnvelope that is
	a copy of this BreapointEnvelope (has the same value
	as this BreakpointEnvelope everywhere).			
   
</BLOCKQUOTE>

<P><TT><B>BreakpointEnvelopeWithValue(initialValue)</B></TT>
<BLOCKQUOTE>  	Construct and return a new BreakpointEnvelope having a 
	single breakpoint at 0. having the specified initialValue.
   
</BLOCKQUOTE>

<A name="s2_3_">
<H3>2.3. class ExportSpc</H3></A>
<P><TT><B>ExportSpc(midiPitch)</B></TT>
<BLOCKQUOTE>  	Construct a new ExportSpc instance configured from the 
		given MIDI note number. All other ExportSpc parameters
		are computed fromthe specified note number.
	   
</BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Destroy this ExportSpc instance.
	   
</BLOCKQUOTE>

<P><TT><B>write(filename,partials)</B></TT>
<BLOCKQUOTE>  	Export the given list of Partials to an spc file having the
		specified path (or name) according to the current configuration 
		of this ExportSpc instance.
	   
</BLOCKQUOTE>

<P><TT><B>configure(midiPitch)</B></TT>
<BLOCKQUOTE>  	Set the MIDI note number (69.00 = A440) for this spc file,
		and recompute all other parameters to default values.			
	   
</BLOCKQUOTE>

<P><TT><B>midiPitch()</B></TT>
<BLOCKQUOTE>  	Return the MIDI note number (69.00 = A440) for this spc file.
	   
</BLOCKQUOTE>

<P><TT><B>numPartials()</B></TT>
<BLOCKQUOTE>  	Return the number of partials in spc file, may 
		be 32, 64, 128, or 256.
	   
</BLOCKQUOTE>

<P><TT><B>refLabel()</B></TT>
<BLOCKQUOTE>  	Return the label of the reference partial for this ExportSpc
		instance. A reference label of 1 indicates the fundamental.
		The reference label is used for filling in frequencies during 
		time gaps in other partials. 
	   
</BLOCKQUOTE>

<P><TT><B>enhanced()</B></TT>
<BLOCKQUOTE>  	Return true if this spc file is in bandwidth-enhanced format,
		false if it is in pure sinusoidal format.
	   
</BLOCKQUOTE>

<P><TT><B>hop()</B></TT>
<BLOCKQUOTE>  	Return the frame duration (in seconds) for this spc file.
	   
</BLOCKQUOTE>

<P><TT><B>attackThreshold()</B></TT>
<BLOCKQUOTE>  	Return the amplitude threshold for cropping the start of the 
		spc file. This is specified as a fraction of maximum amplitude 
		of the sound, with a value between 0.0 and 1.0. If the value is 
		0.0, this indicates no cropping at the start of the spc file.
	   
</BLOCKQUOTE>

<P><TT><B>startFreqTime()</B></TT>
<BLOCKQUOTE>  	Return the time (in seconds) at which frequency in attack is 
		considered stable.  Frequencies before this time are modified 
		in the spc file to avoid real-time morphing artifacts when the 
		spc file is used in Kyma. This returns 0.0 if the spc file has 
		no modified attack frequencies.
	   
</BLOCKQUOTE>

<P><TT><B>endTime()</B></TT>
<BLOCKQUOTE>  	Return the time (in seconds) at which the end of the spc file 
		is truncated. This returns 0.0 if the spc file is not truncate 
		at the end.
	   
</BLOCKQUOTE>

<P><TT><B>endApproachTime()</B></TT>
<BLOCKQUOTE>  	Return a value in seconds that indicates how long before the 
		end of the spc file the amplitude, frequency, and bandwidth 
		values are modified to make a gradual transition to the spectral 
		content at the end of the spc file.  This returns 0.0 if no such 
		modifications are done in the spc file.	
	   
</BLOCKQUOTE>

<P><TT><B>markerTime()</B></TT>
<BLOCKQUOTE>  	Return the time (in seconds) at which a marker is inserted in 
		the spc file. This returns 0.0 if no marker is inserted into 
		the spc file.
	   
</BLOCKQUOTE>

<P><TT><B>setMidiPitch(x)</B></TT>
<BLOCKQUOTE>  	Set the MIDI note number (69.00 = A440) for this 
		spc file. (Does not cause other parameters to be 
		recomputed.) 			
	   
</BLOCKQUOTE>

<P><TT><B>setNumPartials(x)</B></TT>
<BLOCKQUOTE>  	Set the number of partials in spc file, may 
		be 32, 64, 128, or 256.
	   
</BLOCKQUOTE>

<P><TT><B>setRefLabel(x)</B></TT>
<BLOCKQUOTE>  	Set the label of the reference partial for this ExportSpc
		instance. A reference label of 1 indicates the fundamental.
		The reference partial is used for filling in frequencies 
		during time gaps in other partials. 
	   
</BLOCKQUOTE>

<P><TT><B>setEnhanced(x)</B></TT>
<BLOCKQUOTE>  	Set the type of spc file: true for bandwidth-enhanced format,
		false for pure sinusoidal format.
	  
</BLOCKQUOTE>

<P><TT><B>setHop(x)</B></TT>
<BLOCKQUOTE>  	Set the frame duration (in seconds) for this spc file.
	   
</BLOCKQUOTE>

<P><TT><B>setAttackThreshold(x)</B></TT>
<BLOCKQUOTE>  	Set the amplitude threshold for cropping the start of the spc 
		file. This is specified as a fraction of maximum amplitude of 
		the sound, with a value between 0.0 and 1.0.  Specify 0.0 for 
		no cropping of the start of the spc file.
	   
</BLOCKQUOTE>

<P><TT><B>setStartFreqTime(x)</B></TT>
<BLOCKQUOTE>  	Set the time (in seconds) at which frequency in attack is 
		considered stable.  Frequencies before this time are modified 
		in the spc file to avoid real-time morphing artifacts when the 
		spc file is used in Kyma. Specify 0.0 to avoid modified attack 
		frequencies.
	   
</BLOCKQUOTE>

<P><TT><B>setEndTime(x)</B></TT>
<BLOCKQUOTE>  	Set the time (in seconds) to truncate the end of the spc file.
		Set this to the 0.0 (or, equivalently, to the last end time of 
		any partial in the sound) to avoid truncating the end of the 
		spc file.
	   
</BLOCKQUOTE>

<P><TT><B>setEndApproachTime(x)</B></TT>
<BLOCKQUOTE>  	Set how long (in seconds) before the end of the spc file the 
		amplitude, frequency, and bandwidth values are to be modified 
		to make a gradual transition to the spectral content at the 
		end of the spc file. Specify 0.0 to avoid these modifications 
		in the spc file.	
	   
</BLOCKQUOTE>

<P><TT><B>setMarkerTime(x)</B></TT>
<BLOCKQUOTE>  	Set the time (in seconds) at which a marker is inserted in the 
		spc file. Only one marker is inserted into the spc file; it will
		be inserted at the time specified with setMarkerTime().  
		Specify 0.0 to avoid inserting a marker into the spc file.
	   
</BLOCKQUOTE>

<A name="s2_4_">
<H3>2.4. class PartialList</H3></A>
<P><TT><B>PartialList()</B></TT>
<BLOCKQUOTE>  	Return a new empty PartialList.
	   
</BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Destroy this PartialList.
	   
</BLOCKQUOTE>

<P><TT><B>clear()</B></TT>
<BLOCKQUOTE>  	Remove (and destroy) all the Partials from this PartialList,
		leaving it empty.
	   
</BLOCKQUOTE>

<P><TT><B>size()</B></TT>
<BLOCKQUOTE>  	Return the number of Partials in this PartialList.
	   
</BLOCKQUOTE>

<P><TT><B>splice(other)</B></TT>
<BLOCKQUOTE>  	Splice all the Partials in the other PartialList onto the end of
		this PartialList, leaving the other empty.
	   
</BLOCKQUOTE>

<P><TT><B>PartialListCopy(other)</B></TT>
<BLOCKQUOTE>  	Return a new PartialList that is a copy of this 
	PartialList (i.e. has identical Partials).
   
</BLOCKQUOTE>

<A name="s2_5_">
<H3>2.5. class SampleVector</H3></A>
<P><TT><B>SampleVector(size)</B></TT>
<BLOCKQUOTE>  	Return a new SampleVector having the specified number of samples,
		all of whose value is 0. 
		
		If no size is specified, 0 is assumed.
	   
</BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Destroy this SampleVector.
	    
</BLOCKQUOTE>

<P><TT><B>size()</B></TT>
<BLOCKQUOTE>  	Return the number of samples represented by this SampleVector.
	   
</BLOCKQUOTE>

<P><TT><B>resize(size)</B></TT>
<BLOCKQUOTE>  	Change the number of samples represented by this SampleVector. If
		the given size is greater than the current size, all new samples 
		will have value 0. If the given size is less than the current 
		size, then samples in excess of the given size are removed.
	   
</BLOCKQUOTE>

<P><TT><B>clear()</B></TT>
<BLOCKQUOTE>  	Remove all samples from this SampleVector, and set its
	 	size to zero.
	     
</BLOCKQUOTE>

<P><TT><B>getAt(idx)</B></TT>
<BLOCKQUOTE>  	Return the value of the sample at the given position (index) in
		this SampleVector.
	   
</BLOCKQUOTE>

<P><TT><B>setAt(idx,x)</B></TT>
<BLOCKQUOTE>  	Set the value of the sample at the given position (index) in
		this SampleVector.
	   
</BLOCKQUOTE>

<P><TT><B>SampleVectorCopy(other)</B></TT>
<BLOCKQUOTE>  	Return a new SampleVector that is a copy of this 
	SampleVector, having the same number of samples, 
	and samples at every position in the copy having 
	the same value as the corresponding sample in
	this SampleVector.
   
</BLOCKQUOTE>

<A name="s3_">
<HR><H2>3. Non-object-based procedures</H2></A>
<P>
	Operations in Loris that need not be accessed though object
	interfaces are represented as simple functions.
<P><TT><B>channelize(partials,refFreqEnvelope,refLabel)</B></TT>
<BLOCKQUOTE>  	Label Partials in a PartialList with the integer nearest to
	the amplitude-weighted average ratio of their frequency envelope
	to a reference frequency envelope. The frequency spectrum is 
	partitioned into non-overlapping channels whose time-varying 
	center frequencies track the reference frequency envelope. 
	The reference label indicates which channel's center frequency
	is exactly equal to the reference envelope frequency, and other
	channels' center frequencies are multiples of the reference 
	envelope frequency divided by the reference label. Each Partial 
	in the PartialList is labeled with the number of the channel
	that best fits its frequency envelope. The quality of the fit
	is evaluated at the breakpoints in the Partial envelope and
	weighted by the amplitude at each breakpoint, so that high-
	amplitude breakpoints contribute more to the channel decision.
	Partials are labeled, but otherwise unmodified. In particular, 
	their frequencies are not modified in any way.
   
</BLOCKQUOTE>

<P><TT><B>dilate(partials,initial_times,target_times)</B></TT>
<BLOCKQUOTE>  	Dilate Partials in a PartialList according to the given 
	initial and target time points. Partial envelopes are 
	stretched and compressed so that temporal features at
	the initial time points are aligned with the final time
	points. Time points are sorted, so Partial envelopes are 
	are only stretched and compressed, but breakpoints are not
	reordered. Duplicate time points are allowed. There must be
	the same number of initial and target time points.
	
	The time points are passed as strings; convert any native
	collection to a string representation, numerical elements
	will be extracted, other characters will be ignored.
   
</BLOCKQUOTE>

<P><TT><B>distill(partials)</B></TT>
<BLOCKQUOTE>  	Distill labeled (channelized)  Partials in a PartialList into a 
	PartialList containing a single (labeled) Partial per label. 
	The distilled PartialList will contain as many Partials as
	there were non-zero labels in the original PartialList. Unlabeled 
	(label 0) Partials are eliminated.
   
</BLOCKQUOTE>

<P><TT><B>exportAiff(path,vec,samplerate,nchannels,bitsPerSamp)</B></TT>
<BLOCKQUOTE>  	Export audio samples stored in a SampleVector to an AIFF file
	having the specified number of channels and sample rate at the 
	given file path (or name). The floating point samples in the 
	SampleVector are clamped to the range (-1.,1.) and converted 
	to integers having bitsPerSamp bits.
   
</BLOCKQUOTE>

<P><TT><B>exportSdif(path,partials,hop)</B></TT>
<BLOCKQUOTE>  	Export Partials in a PartialList to a SDIF file at the specified
	file path (or name). SDIF data is written in the 1TRC format.  
	For more information about SDIF, see the SDIF website at:
		www.ircam.fr/equipes/analyse-synthese/sdif/  
		
	The hop parameter is currently used to specify a time-domain 
	resampling of the Partial envelopes. This parameter is 
	deprecated, and will be removed in future versions, which 
	will have explicit resampling functionality. If hop is 0., 
	Partial envelopes will not be resampled, and all Partial 
	envelope data will be stored.
	
	If unspecified, hop defaults to 0.
   
</BLOCKQUOTE>

<P><TT><B>importAiff(path)</B></TT>
<BLOCKQUOTE>  	Import audio samples stored in an AIFF file at the given file
	path (or name). The samples are converted to floating point 
	values on the range (-1.,1.) and returned in a SampleVector, 
	which is sized to (exactly) accomodate all the samples 
	in the file. Use infoAiff( path ) to get the sample rate
	and the number of channels.
   
</BLOCKQUOTE>

<P><TT><B>importSdif(path)</B></TT>
<BLOCKQUOTE>  	Import Partials from an SDIF file at the given file path (or 
	name), and return them in a PartialList.
	For more information about SDIF, see the SDIF website at:
		www.ircam.fr/equipes/analyse-synthese/sdif/  
   
</BLOCKQUOTE>

<P><TT><B>infoAiff(path)</B></TT>
<BLOCKQUOTE>  	Return the number of sample frames, sample rate, and number 
		of channels of audio samples stored in an AIFF file at the 
		given file path (or name). The samples themselves are obtained 
		using importAiff( path ). 
	   
</BLOCKQUOTE>

<P><TT><B>morph(src0,src1,ffreq,famp,fbw)</B></TT>
<BLOCKQUOTE>  	Morph labeled Partials in two PartialLists according to the
	given frequency, amplitude, and bandwidth (noisiness) morphing
	envelopes, and return the morphed Partials in a PartialList. 
	Loris morphs Partials by interpolating frequency, amplitude, 
	and bandwidth envelopes of corresponding Partials in the
	source PartialLists. For more information about the Loris
	morphing algorithm, see the Loris website: 
	www.cerlsoundgroup.org/Loris/
   
</BLOCKQUOTE>

<P><TT><B>synthesize(partials,srate)</B></TT>
<BLOCKQUOTE>  	Synthesize Partials in a PartialList at the given sample
	rate, and return the (floating point) samples in a SampleVector.
	The SampleVector is sized to hold as many samples as are needed 
	for the complete synthesis of all the Partials in the PartialList. 
   
</BLOCKQUOTE>

<A name="s4_">
<HR><H2>4. Utility functions</H2></A>
<P>
	These procedures are generally useful but are not yet  
	represented by classes in the Loris core.
<P><TT><B>copyByLabel(src,label,dst)</B></TT>
<BLOCKQUOTE>  	Append copies of Partials in the source PartialList having the
	specified label to the destination PartialList. The source list
	is unmodified.
   
</BLOCKQUOTE>

<P><TT><B>createFreqReference(partials,numSamples,minFreq,maxFreq)</B></TT>
<BLOCKQUOTE>  	Return a newly-constructed BreakpointEnvelope comprising the
	specified number of samples of the frequency envelope of the
	longest Partial in a PartialList. Only Partials whose frequency
	at the Partial's loudest (highest amplitude) breakpoint is
	within the given frequency range are considered. 
	
	For very simple sounds, this frequency reference may be a 
	good first approximation to a reference envelope for
	channelization (see channelize()).
   
</BLOCKQUOTE>

<P><TT><B>scaleAmp(partials,ampEnv)</B></TT>
<BLOCKQUOTE>  	Scale the amplitude of the Partials in a PartialList according 
	to an envelope representing a time-varying amplitude scale value.
   
</BLOCKQUOTE>

<P><TT><B>scaleNoiseRatio(partials,noiseEnv)</B></TT>
<BLOCKQUOTE>  	Scale the relative noise content of the Partials in a PartialList 
	according to an envelope representing a (time-varying) noise energy 
	scale value.
   
</BLOCKQUOTE>

<P><TT><B>shiftPitch(partials,pitchEnv)</B></TT>
<BLOCKQUOTE>  	Shift the pitch of all Partials in a PartialList according to 
	the given pitch envelope. The pitch envelope is assumed to have 
	units of cents (1/100 of a halfstep).
   
</BLOCKQUOTE>


</BODY>
</HTML>
