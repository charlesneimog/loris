<HTML>
<HEAD>
<TITLE>
Python module: loris</TITLE>
<BODY BGCOLOR="#ffffff">
<H1>Python module: loris</H1>

<HR><H1> Contents </H1>
<UL><LI> <A HREF="#s1_">1. Version</A>
<LI> <A HREF="#s2_">2. class Analyzer</A>
<LI> <A HREF="#s3_">3. class BreakpointEnvelope</A>
<LI> <A HREF="#s4_">4. class PartialList</A>
<LI> <A HREF="#s5_">5. class SampleVector</A>
<LI> <A HREF="#s6_">6. Non-object-based procedures</A>
<LI> <A HREF="#s7_">7. Utility functions</A>
</UL>

<A name="s1_">
<HR><H2>1. Version</H2></A>
<P><TT><B>__version__ = Loris 1.0beta1 </B></TT>

<A name="s2_">
<HR><H2>2. class Analyzer</H2></A>
<P>	An Analyzer represents a configuration of parameters for
	performing Reassigned Bandwidth-Enhanced Additive Analysis
	of sampled waveforms. This analysis process yields a collection 
	of Partials, each having a trio of synchronous, non-uniformly-
	sampled breakpoint envelopes representing the time-varying 
	frequency, amplitude, and noisiness of a single bandwidth-
	enhanced sinusoid. 

	For more information about Reassigned Bandwidth-Enhanced 
	Analysis and the Reassigned Bandwidth-Enhanced Additive Sound 
	Model, refer to the Loris website: 
	<a href="http://www.cerlsoundgroup.org/Loris/" 
	name="Loris web site">www.cerlsoundgroup.org/Loris/</a>
	
<P><TT><B>Analyzer(resolutionHz)</B></TT>
<BLOCKQUOTE>  	Construct and return a new Analyzer configured with the given	
		frequency resolution (minimum instantaneous frequency	
		difference between Partials). All other Analyzer parameters 	
		are computed from the specified frequency resolution. 			
	   
</BLOCKQUOTE>

<P><TT><B>AnalyzerCopy(other)</B></TT>
<BLOCKQUOTE>  	Construct and return a new Analyzer having identical
		parameter configuration to another Analyzer.			
	   
</BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Destroy this Analyzer. 								
	   
</BLOCKQUOTE>

<P><TT><B>analyze(vec,srate)</B></TT>
<BLOCKQUOTE>  	Analyze a SampleVector of (mono) samples at the given sample rate 	  	
		(in Hz) and return the resulting Partials in a PartialList. 												
	   
</BLOCKQUOTE>

<P><TT><B>configure(resolutionHz)</B></TT>
<BLOCKQUOTE>  	Configure this Analyzer with the given frequency resolution 
		(minimum instantaneous frequency difference between Partials). 
		All other Analyzer parameters are (re-)computed from the 
		frequency resolution. 		
	   
</BLOCKQUOTE>

<P><TT><B>freqResolution()</B></TT>
<BLOCKQUOTE>  	Return the frequency resolution (minimum instantaneous frequency  		
		difference between Partials) for this Analyzer. 	
	   
</BLOCKQUOTE>

<P><TT><B>ampFloor()</B></TT>
<BLOCKQUOTE>  	Return the amplitude floor (lowest detected spectral amplitude),  			
		in (negative) dB, for this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>windowWidth()</B></TT>
<BLOCKQUOTE>  	Return the frequency-domain main lobe width (measured between 
		zero-crossings) of the analysis window used by this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>freqFloor()</B></TT>
<BLOCKQUOTE>  	Return the frequency floor (minimum instantaneous Partial  				
		frequency), in Hz, for this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>hopTime()</B></TT>
<BLOCKQUOTE>  	Return the hop time (which corresponds approximately to the 
		average density of Partial envelope Breakpoint data) for this 
		Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>freqDrift()</B></TT>
<BLOCKQUOTE>  	Return the maximum allowable frequency difference between 					
		consecutive Breakpoints in a Partial envelope for this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>cropTime()</B></TT>
<BLOCKQUOTE>  	Return the crop time (maximum temporal displacement of a time-
		frequency data point from the time-domain center of the analysis
		window, beyond which data points are considered &quot;unreliable&quot;)
		for this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>bwRegionWidth()</B></TT>
<BLOCKQUOTE>  	Return the width (in Hz) of the Bandwidth Association regions
		used by this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>setFreqResolution(x)</B></TT>
<BLOCKQUOTE>  	Set the frequency resolution (minimum instantaneous frequency  		
		difference between Partials) for this Analyzer. (Does not cause 	
		other parameters to be recomputed.) 									
	   
</BLOCKQUOTE>

<P><TT><B>setAmpFloor(x)</B></TT>
<BLOCKQUOTE>  	Set the amplitude floor (lowest detected spectral amplitude), in  			
		(negative) dB, for this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>setWindowWidth(x)</B></TT>
<BLOCKQUOTE>  	Set the frequency-domain main lobe width (measured between 
		zero-crossings) of the analysis window used by this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>setFreqFloor(x)</B></TT>
<BLOCKQUOTE>  	Set the amplitude floor (minimum instantaneous Partial  				
		frequency), in Hz, for this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>setFreqDrift(x)</B></TT>
<BLOCKQUOTE>  	Set the maximum allowable frequency difference between 					
		consecutive Breakpoints in a Partial envelope for this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>setHopTime(x)</B></TT>
<BLOCKQUOTE>  	Set the hop time (which corresponds approximately to the average
		density of Partial envelope Breakpoint data) for this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>setCropTime(x)</B></TT>
<BLOCKQUOTE>  	Set the crop time (maximum temporal displacement of a time-
		frequency data point from the time-domain center of the analysis
		window, beyond which data points are considered &quot;unreliable&quot;)
		for this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>setBwRegionWidth(x)</B></TT>
<BLOCKQUOTE>  	Set the width (in Hz) of the Bandwidth Association regions
		used by this Analyzer.
	   
</BLOCKQUOTE>

<A name="s3_">
<HR><H2>3. class BreakpointEnvelope</H2></A>
<P>
	A BreakpointEnvelope represents a linear segment breakpoint 
	function with infinite extension at each end (that is, the 
	values past either end of the breakpoint function have the 
	values at the nearest end).
<P><TT><B>BreakpointEnvelope()</B></TT>
<BLOCKQUOTE>  	Construct and return a new BreakpointEnvelope having no 
		breakpoints and an implicit value of 0. everywhere, 
		until the first breakpoint is inserted.			
	   
</BLOCKQUOTE>

<P><TT><B>BreakpointEnvelopeWithValue(initialValue)</B></TT>
<BLOCKQUOTE>  	Construct and return a new BreakpointEnvelope having a 
		single breakpoint at 0. having the specified initialValue.
</BLOCKQUOTE>

<P><TT><B>BreakpointEnvelopeCopy(other)</B></TT>
<BLOCKQUOTE>  	Construct and return a new BreakpointEnvelope that is
		a copy of this BreapointEnvelope (has the same value
		as this BreakpointEnvelope everywhere).			
	   
</BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Destroy this BreakpointEnvelope. 								
	   
</BLOCKQUOTE>

<P><TT><B>valueAt(x)</B></TT>
<BLOCKQUOTE>  	Return the interpolated value of this BreakpointEnvelope at 
		the specified time.							
	   
</BLOCKQUOTE>

<P><TT><B>insertBreakpoint(time,value)</B></TT>
<BLOCKQUOTE>  	Insert a breakpoint representing the specified (time, value) 
		pair into this BreakpointEnvelope. If there is already a 
		breakpoint at the specified time, it will be replaced with 
		the new breakpoint.
	   
</BLOCKQUOTE>

<A name="s4_">
<HR><H2>4. class PartialList</H2></A>
<P>
	A PartialList represents a collection of Bandwidth-Enhanced 
	Partials, each having a trio of synchronous, non-uniformly-
	sampled breakpoint envelopes representing the time-varying 
	frequency, amplitude, and noisiness of a single bandwidth-
	enhanced sinusoid.

	For more information about Bandwidth-Enhanced Partials and the  
	Reassigned Bandwidth-Enhanced Additive Sound Model, refer to
	the Loris website:  
	<a href="http://www.cerlsoundgroup.org/Loris/" 
	name="Loris web site">www.cerlsoundgroup.org/Loris/</a>
<P><TT><B>PartialList()</B></TT>
<BLOCKQUOTE>  	Return a new empty PartialList.
	   
</BLOCKQUOTE>

<P><TT><B>PartialListCopy(other)</B></TT>
<BLOCKQUOTE>  	Return a new PartialList that is a copy of this 
		PartialList (i.e. has identical Partials).
	   
</BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Destroy this PartialList.
	   
</BLOCKQUOTE>

<P><TT><B>clear()</B></TT>
<BLOCKQUOTE>  	Remove (and destroy) all the Partials from this PartialList,
		leaving it empty.
	   
</BLOCKQUOTE>

<P><TT><B>size()</B></TT>
<BLOCKQUOTE>  	Return the number of Partials in this PartialList.
	   
</BLOCKQUOTE>

<P><TT><B>splice(other)</B></TT>
<BLOCKQUOTE>  	Splice all the Partials in the other PartialList onto the end of
		this PartialList, leaving the other empty.
	   
</BLOCKQUOTE>

<A name="s5_">
<HR><H2>5. class SampleVector</H2></A>
	A SampleVector represents a vector of floating point samples of
	an audio waveform. In Loris, the samples are assumed to have 
	values on the range (-1., 1.) (though this is not enforced or 
	checked). 
<P><TT><B>SampleVector(size)</B></TT>
<BLOCKQUOTE>  	Return a new SampleVector having the specified number of samples,
		all of whose value is 0. 
		
		If no size is specified, 0 is assumed.
	   
</BLOCKQUOTE>

<P><TT><B>SampleVectorCopy(other)</B></TT>
<BLOCKQUOTE>  	Return a new SampleVector that is a copy of this 
		SampleVector, having the same number of samples, 
		and samples at every position in the copy having 
		the same value as the corresponding sample in
		this SampleVector.
	   
</BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Destroy this SampleVector.
	    
</BLOCKQUOTE>

<P><TT><B>size()</B></TT>
<BLOCKQUOTE>  	Return the number of samples represented by this SampleVector.
	   
</BLOCKQUOTE>

<P><TT><B>resize(size)</B></TT>
<BLOCKQUOTE>  	Change the number of samples represented by this SampleVector. If
		the given size is greater than the current size, all new samples 
		will have value 0. If the given size is less than the current 
		size, then samples in excess of the given size are removed.
	   
</BLOCKQUOTE>

<P><TT><B>clear()</B></TT>
<BLOCKQUOTE>  	Remove all samples from this SampleVector, and set its
	 	size to zero.
	     
</BLOCKQUOTE>

<P><TT><B>getAt(idx)</B></TT>
<BLOCKQUOTE>  	Return the value of the sample at the given position (index) in
		this SampleVector.
	   
</BLOCKQUOTE>

<P><TT><B>setAt(idx,x)</B></TT>
<BLOCKQUOTE>  	Set the value of the sample at the given position (index) in
		this SampleVector.
	   
</BLOCKQUOTE>

<A name="s6_">
<HR><H2>6. Non-object-based procedures</H2></A>
<P>
	Operations in Loris that need not be accessed though object
	interfaces are represented as simple functions.
<P><TT><B>channelize(partials,refFreqEnvelope,refLabel)</B></TT>
<BLOCKQUOTE>  	Label Partials in a PartialList with the integer nearest to
	the amplitude-weighted average ratio of their frequency envelope
	to a reference frequency envelope. The frequency spectrum is 
	partitioned into non-overlapping channels whose time-varying 
	center frequencies track the reference frequency envelope. 
	The reference label indicates which channel's center frequency
	is exactly equal to the reference envelope frequency, and other
	channels' center frequencies are multiples of the reference 
	envelope frequency divided by the reference label. Each Partial 
	in the PartialList is labeled with the number of the channel
	that best fits its frequency envelope. The quality of the fit
	is evaluated at the breakpoints in the Partial envelope and
	weighted by the amplitude at each breakpoint, so that high-
	amplitude breakpoints contribute more to the channel decision.
	Partials are labeled, but otherwise unmodified. In particular, 
	their frequencies are not modified in any way.
   
</BLOCKQUOTE>

<P><TT><B>dilate(partials,initial_times,target_times)</B></TT>
<BLOCKQUOTE>  	Dilate Partials in a PartialList according to the given 
	initial and target time points. Partial envelopes are 
	stretched and compressed so that temporal features at
	the initial time points are aligned with the final time
	points. Time points are sorted, so Partial envelopes are 
	are only stretched and compressed, but breakpoints are not
	reordered. Duplicate time points are allowed. There must be
	the same number of initial and target time points.
	
	The time points are passed as strings; convert any native
	collection to a string representation, numerical elements
	will be extracted, other characters will be ignored.
   
</BLOCKQUOTE>

<P><TT><B>distill(partials)</B></TT>
<BLOCKQUOTE>  	Distill labeled (channelized)  Partials in a PartialList into a 
	PartialList containing a single (labeled) Partial per label. 
	The distilled PartialList will contain as many Partials as
	there were non-zero labels in the original PartialList. Unlabeled 
	(label 0) Partials are eliminated.
   
</BLOCKQUOTE>

<P><TT><B>exportAiff(path,vec,samplerate,nchannels,bitsPerSamp)</B></TT>
<BLOCKQUOTE>  	Export audio samples stored in a SampleVector to an AIFF file
	having the specified number of channels and sample rate at the 
	given file path (or name). The floating point samples in the 
	SampleVector are clamped to the range (-1.,1.) and converted 
	to integers having bitsPerSamp bits.
   
</BLOCKQUOTE>

<P><TT><B>exportSdif(path,partials,hop)</B></TT>
<BLOCKQUOTE>  	Export Partials in a PartialList to a SDIF file at the specified
	file path (or name). SDIF data is written in the 1TRC format.  
	For more information about SDIF, see the SDIF website at:
		<a href="http://www.ircam.fr/equipes/analyse-synthese/sdif/" 
		name="IRCAM SDIF web site">www.ircam.fr/equipes/analyse-synthese/sdif/</a>  
<BR>		
	The hop parameter is currently used to specify a time-domain 
	resampling of the Partial envelopes. This parameter is 
	deprecated, and will be removed in future versions, which 
	will have explicit resampling functionality. If hop is 0., 
	Partial envelopes will not be resampled, and all Partial 
	envelope data will be stored.
	
	If unspecified, hop defaults to 0.
   
</BLOCKQUOTE>

<P><TT><B>importAiff(path)</B></TT>
<BLOCKQUOTE>  	Import audio samples stored in an AIFF file at the given file
	path (or name). The samples are converted to floating point 
	values on the range (-1.,1.) and returned in a SampleVector, 
	which is sized to (exactly) accomodate all the samples 
	in the file. Use infoAiff( path ) to get the sample rate
	and the number of channels.
   
</BLOCKQUOTE>

<P><TT><B>importSdif(path)</B></TT>
<BLOCKQUOTE>  	Import Partials from an SDIF file at the given file path (or 
	name), and return them in a PartialList.
	For more information about SDIF, see the SDIF website at:
		<a href="http://www.ircam.fr/equipes/analyse-synthese/sdif/" 
		name="IRCAM SDIF web site">www.ircam.fr/equipes/analyse-synthese/sdif/</a>  
   
</BLOCKQUOTE>

<P><TT><B>infoAiff(path)</B></TT>
<BLOCKQUOTE>  	Return the number of sample frames, sample rate, and number 
		of channels of audio samples stored in an AIFF file at the 
		given file path (or name). The samples themselves are obtained 
		using importAiff( path ). 
	   
</BLOCKQUOTE>

<P><TT><B>morph(src0,src1,ffreq,famp,fbw)</B></TT>
<BLOCKQUOTE>  	Morph labeled Partials in two PartialLists according to the
	given frequency, amplitude, and bandwidth (noisiness) morphing
	envelopes, and return the morphed Partials in a PartialList. 
	Loris morphs Partials by interpolating frequency, amplitude, 
	and bandwidth envelopes of corresponding Partials in the
	source PartialLists. For more information about the Loris
	morphing algorithm, see the Loris website: 
	<a href="http://www.cerlsoundgroup.org/Loris/" 
	name="Loris web site">www.cerlsoundgroup.org/Loris/</a>
   
</BLOCKQUOTE>

<P><TT><B>synthesize(partials,srate)</B></TT>
<BLOCKQUOTE>  	Synthesize Partials in a PartialList at the given sample
	rate, and return the (floating point) samples in a SampleVector.
	The SampleVector is sized to hold as many samples as are needed 
	for the complete synthesis of all the Partials in the PartialList. 
   
</BLOCKQUOTE>

<A name="s7_">
<HR><H2>7. Utility functions</H2></A>
<P>
	These procedures are generally useful but are not yet  
	represented by classes in the Loris core.
<P><TT><B>copyByLabel(src,label,dst)</B></TT>
<BLOCKQUOTE>  	Append copies of Partials in the source PartialList having the
	specified label to the destination PartialList. The source list
	is unmodified.
   
</BLOCKQUOTE>

<P><TT><B>createFreqReference(partials,numSamples,minFreq,maxFreq)</B></TT>
<BLOCKQUOTE>  	Return a newly-constructed BreakpointEnvelope comprising the
	specified number of samples of the frequency envelope of the
	longest Partial in a PartialList. Only Partials whose frequency
	at the Partial's loudest (highest amplitude) breakpoint is
	within the given frequency range are considered. 
	
	For very simple sounds, this frequency reference may be a 
	good first approximation to a reference envelope for
	channelization (see channelize()).
   
</BLOCKQUOTE>

<P><TT><B>scaleAmp(partials,ampEnv)</B></TT>
<BLOCKQUOTE>  	Scale the amplitude of the Partials in a PartialList according 
	to an envelope representing a time-varying amplitude scale value.
   
</BLOCKQUOTE>

<P><TT><B>scaleNoiseRatio(partials,noiseEnv)</B></TT>
<BLOCKQUOTE>  	Scale the relative noise content of the Partials in a PartialList 
	according to an envelope representing a (time-varying) noise energy 
	scale value.
   
</BLOCKQUOTE>

<P><TT><B>shiftPitch(partials,pitchEnv)</B></TT>
<BLOCKQUOTE>  	Shift the pitch of all Partials in a PartialList according to 
	the given pitch envelope. The pitch envelope is assumed to have 
	units of cents (1/100 of a halfstep).
   
</BLOCKQUOTE>


</BODY>
</HTML>
