<HTML>
<HEAD>
<TITLE>
Python module: loris</TITLE>
<BODY BGCOLOR="#ffffff">
<H1>Python module: loris</H1>

<HR><H1> Contents </H1>
<UL><LI> <A HREF="#s1_">1. Version</A>
<LI> <A HREF="#s2_">2. Loris class interfaces</A>
<UL><LI> <A HREF="#s2_1_">2.1. class PartialList</A>
<LI> <A HREF="#s2_2_">2.2. class Partial</A>
<LI> <A HREF="#s2_3_">2.3. class Breakpoint</A>
<LI> <A HREF="#s2_4_">2.4. class Analyzer</A>
<LI> <A HREF="#s2_5_">2.5. class BreakpointEnvelope</A>
<LI> <A HREF="#s2_6_">2.6. class ExportSpc</A>
<LI> <A HREF="#s2_7_">2.7. class SampleVector</A>
<LI> <A HREF="#s2_8_">2.8. class AiffFile</A>
</UL><LI> <A HREF="#s3_">3. Non-object-based procedures</A>
<LI> <A HREF="#s4_">4. Utility functions</A>
</UL>

<A name="s1_">
<HR><H2>1. Version</H2></A>
<P><TT><B>version = 'Loris 1.0beta3' </B></TT>

<A name="s2_">
<HR><H2>2. Loris class interfaces</H2></A>
<A name="s2_1_">
<H3>2.1. class PartialList</H3></A>
	A PartialList represents a collection of Bandwidth-Enhanced 
	Partials, each having a trio of synchronous, non-uniformly-
	sampled breakpoint envelopes representing the time-varying 
	frequency, amplitude, and noisiness of a single bandwidth-
	enhanced sinusoid.

	For more information about Bandwidth-Enhanced Partials and the  
	Reassigned Bandwidth-Enhanced Additive Sound Model, refer to
	the Loris website: www.cerlsoundgroup.org/Loris/
	
<P><TT><B>PartialList()</B></TT>
<BLOCKQUOTE>  	Return a new empty PartialList.
	   
</BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Destroy this PartialList.
	   
</BLOCKQUOTE>

<P><TT><B>clear()</B></TT>
<BLOCKQUOTE>  	Remove (and destroy) all the Partials from this PartialList,
		leaving it empty.
	   
</BLOCKQUOTE>

<P><TT><B>copy()</B></TT>
<BLOCKQUOTE>  	Return a new PartialList that is a copy of this 
		PartialList (i.e. has identical Partials).
	   
</BLOCKQUOTE>

<P><TT><B>size()</B></TT>
<BLOCKQUOTE>  	Return the number of Partials in this PartialList.
	   
</BLOCKQUOTE>

<P><TT><B>first()</B></TT>
<BLOCKQUOTE>  	Return an iterator refering to the first Partial in this PartialList.
	   
</BLOCKQUOTE>

<P><TT><B>last()</B></TT>
<BLOCKQUOTE>  	Return an iterator refering to the last Partial in this PartialList.
	   
</BLOCKQUOTE>

<P><TT><B>append(iter)</B></TT>
<BLOCKQUOTE>  	Append a copy of the Partial referenced by the specified iterator
		to the end of this PartialList.
	   
</BLOCKQUOTE>

<P><TT><B>splice(otherPartials)</B></TT>
<BLOCKQUOTE>  	Splice all the Partials in the other PartialList onto the end of
		this PartialList, leaving the other empty.
	   
</BLOCKQUOTE>

<A name="s2_2_">
<H3>2.2. class Partial</H3></A>
	The Partial class in the Loris scripting interface represents both
	a Loris::Partial and an iterator on a list of Partials, so its interface
	includes access and mutation of Partials and iterator behavior, like
	next() and atEnd().
	
	Partials (iterators on PartialLists) can only be created using the 
	PartialList members first() and last() (a temporary condition, probably).

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Delete this Partial reference (doesn't remove it from the PartialList).
	   
</BLOCKQUOTE>

<P><TT><B>next()</B></TT>
<BLOCKQUOTE>  	Advance this PartialList iterator to the next position in the list.
	   
</BLOCKQUOTE>

<P><TT><B>atEnd()</B></TT>
<BLOCKQUOTE>  	Return true if this PartialList iterator refers to a position past
		the end of the list (does not refer to a valid Partial). Otherwise
		return false.
	   
</BLOCKQUOTE>

<P><TT><B>label()</B></TT>
<BLOCKQUOTE>   	Return this Partial's label.
	   
</BLOCKQUOTE>

<P><TT><B>initialPhase()</B></TT>
<BLOCKQUOTE>   	Return this Partial's starting phase.
	   
</BLOCKQUOTE>

<P><TT><B>startTime()</B></TT>
<BLOCKQUOTE>   	Return this Partial's start time.
	   
</BLOCKQUOTE>

<P><TT><B>endTime()</B></TT>
<BLOCKQUOTE>   	Return this Partial's end time.
	   
</BLOCKQUOTE>

<P><TT><B>duration()</B></TT>
<BLOCKQUOTE>   	Return this Partial's duration.
	   
</BLOCKQUOTE>

<P><TT><B>countBreakpoints()</B></TT>
<BLOCKQUOTE>   	Return this Partial's number of Breakpoints.
	   
</BLOCKQUOTE>

<P><TT><B>frequencyAt(time)</B></TT>
<BLOCKQUOTE>   	Return this Partial's interpolated frequency at the specified time.
	   
</BLOCKQUOTE>

<P><TT><B>amplitudeAt(time)</B></TT>
<BLOCKQUOTE>   	Return this Partial's interpolated amplitude at the specified time.
	   
</BLOCKQUOTE>

<P><TT><B>bandwidthAt(time)</B></TT>
<BLOCKQUOTE>   	Return this Partial's interpolated bandwidth at the specified time.
	   
</BLOCKQUOTE>

<P><TT><B>phaseAt(time)</B></TT>
<BLOCKQUOTE>   	Return this Partial's interpolated phase at the specified time.
	   
</BLOCKQUOTE>

<P><TT><B>setLabel(l)</B></TT>
<BLOCKQUOTE>  	Assign a new label to this Partial.
	   
</BLOCKQUOTE>

<P><TT><B>removeFromList()</B></TT>
<BLOCKQUOTE>  	Remove this Partial from its PartialList, and advance the
		iterator, so that the iterator is still valid (represents
		a valid list position, though it may be atEnd) but refers 
		to the next Partial in the list, or is atEnd.
	   
</BLOCKQUOTE>

<P><TT><B>first()</B></TT>
<BLOCKQUOTE>  	Return the first Breakpoint in this Partial.
	   
</BLOCKQUOTE>

<P><TT><B>last()</B></TT>
<BLOCKQUOTE>  	Return the last Breakpoint in this Partial.
	   
</BLOCKQUOTE>

<A name="s2_3_">
<H3>2.3. class Breakpoint</H3></A>
	The Breakpoint class in the Loris scripting interface represents both
	a Loris::Breakpoint and an iterator on a Loris Partial, so its interface
	includes access and mutation of Breakpoint data and iterator behavior, like
	next() and atEnd().
	
	Breakpoints (iterators on PartialLists) can only be created using the 
	Partial members first() and last().

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Delete this Breakpoint reference (does not remove from the Partial).
	   
</BLOCKQUOTE>

<P><TT><B>frequency()</B></TT>
<BLOCKQUOTE>  	Return the frequency of this Breakpoint. 
	   
</BLOCKQUOTE>

<P><TT><B>amplitude()</B></TT>
<BLOCKQUOTE>  	Return the amplitude of this Breakpoint. 
	   
</BLOCKQUOTE>

<P><TT><B>bandwidth()</B></TT>
<BLOCKQUOTE>  	Return the bandwidth of this Breakpoint. 
	   
</BLOCKQUOTE>

<P><TT><B>phase()</B></TT>
<BLOCKQUOTE>  	Return the phase of this Breakpoint. 
	   
</BLOCKQUOTE>

<P><TT><B>setFrequency(x)</B></TT>
<BLOCKQUOTE>  	Assign the frequency of this Breakpoint. 
	   
</BLOCKQUOTE>

<P><TT><B>setAmplitude(x)</B></TT>
<BLOCKQUOTE>  	Assign the amplitude of this Breakpoint. 
	   
</BLOCKQUOTE>

<P><TT><B>setBandwidth(x)</B></TT>
<BLOCKQUOTE>  	Assign the bandwidth of this Breakpoint. 
	   
</BLOCKQUOTE>

<P><TT><B>setPhase(x)</B></TT>
<BLOCKQUOTE>  	Assign the phase of this Breakpoint. 
	   
</BLOCKQUOTE>

<P><TT><B>time()</B></TT>
<BLOCKQUOTE>  	Return the time of this Breakpoint (not mutable).
	   
</BLOCKQUOTE>

<P><TT><B>next()</B></TT>
<BLOCKQUOTE>  	Advance this iterator to the next position (Breakpoint)
		in the Partial. 
	   
</BLOCKQUOTE>

<P><TT><B>atEnd()</B></TT>
<BLOCKQUOTE>  	Return true if this iterator refers to a position past the end 
		of the Partial's envelope (does not refer to a valid Breakpoint).
		Otherwise return false.
	   
</BLOCKQUOTE>

<A name="s2_4_">
<H3>2.4. class Analyzer</H3></A>
	An Analyzer represents a configuration of parameters for
	performing Reassigned Bandwidth-Enhanced Additive Analysis
	of sampled waveforms. This analysis process yields a collection 
	of Partials, each having a trio of synchronous, non-uniformly-
	sampled breakpoint envelopes representing the time-varying 
	frequency, amplitude, and noisiness of a single bandwidth-
	enhanced sinusoid. 

	For more information about Reassigned Bandwidth-Enhanced 
	Analysis and the Reassigned Bandwidth-Enhanced Additive Sound 
	Model, refer to the Loris website: www.cerlsoundgroup.org/Loris/

<P><TT><B>Analyzer(resolutionHz)</B></TT>
<BLOCKQUOTE>  	Construct and return a new Analyzer configured with the given	
		frequency resolution (minimum instantaneous frequency	
		difference between Partials). All other Analyzer parameters 	
		are computed from the specified frequency resolution. 			
	   
</BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Destroy this Analyzer. 								
	   
</BLOCKQUOTE>

<P><TT><B>analyze(vec,srate)</B></TT>
<BLOCKQUOTE>  	Analyze a SampleVector of (mono) samples at the given sample rate 	  	
		(in Hz) and return the resulting Partials in a PartialList. 												
	   
</BLOCKQUOTE>

<P><TT><B>configure(resolutionHz)</B></TT>
<BLOCKQUOTE>  	Configure this Analyzer with the given frequency resolution 
		(minimum instantaneous frequency difference between Partials). 
		All other Analyzer parameters are (re-)computed from the 
		frequency resolution. 		
	   
</BLOCKQUOTE>

<P><TT><B>copy()</B></TT>
<BLOCKQUOTE>  	Construct and return a new Analyzer having identical
		parameter configuration to another Analyzer.			
	   
</BLOCKQUOTE>

<P><TT><B>freqResolution()</B></TT>
<BLOCKQUOTE>  	Return the frequency resolution (minimum instantaneous frequency  		
		difference between Partials) for this Analyzer. 	
	   
</BLOCKQUOTE>

<P><TT><B>ampFloor()</B></TT>
<BLOCKQUOTE>  	Return the amplitude floor (lowest detected spectral amplitude),  			
		in (negative) dB, for this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>windowWidth()</B></TT>
<BLOCKQUOTE>  	Return the frequency-domain main lobe width (measured between 
		zero-crossings) of the analysis window used by this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>freqFloor()</B></TT>
<BLOCKQUOTE>  	Return the frequency floor (minimum instantaneous Partial  				
		frequency), in Hz, for this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>hopTime()</B></TT>
<BLOCKQUOTE>  	Return the hop time (which corresponds approximately to the 
		average density of Partial envelope Breakpoint data) for this 
		Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>freqDrift()</B></TT>
<BLOCKQUOTE>  	Return the maximum allowable frequency difference between 					
		consecutive Breakpoints in a Partial envelope for this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>cropTime()</B></TT>
<BLOCKQUOTE>  	Return the crop time (maximum temporal displacement of a time-
		frequency data point from the time-domain center of the analysis
		window, beyond which data points are considered &quot;unreliable&quot;)
		for this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>bwRegionWidth()</B></TT>
<BLOCKQUOTE>  	Return the width (in Hz) of the Bandwidth Association regions
		used by this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>setFreqResolution(x)</B></TT>
<BLOCKQUOTE>  	Set the frequency resolution (minimum instantaneous frequency  		
		difference between Partials) for this Analyzer. (Does not cause 	
		other parameters to be recomputed.) 									
	   
</BLOCKQUOTE>

<P><TT><B>setAmpFloor(x)</B></TT>
<BLOCKQUOTE>  	Set the amplitude floor (lowest detected spectral amplitude), in  			
		(negative) dB, for this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>setWindowWidth(x)</B></TT>
<BLOCKQUOTE>  	Set the frequency-domain main lobe width (measured between 
		zero-crossings) of the analysis window used by this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>setFreqFloor(x)</B></TT>
<BLOCKQUOTE>  	Set the amplitude floor (minimum instantaneous Partial  				
		frequency), in Hz, for this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>setFreqDrift(x)</B></TT>
<BLOCKQUOTE>  	Set the maximum allowable frequency difference between 					
		consecutive Breakpoints in a Partial envelope for this Analyzer. 				
	   
</BLOCKQUOTE>

<P><TT><B>setHopTime(x)</B></TT>
<BLOCKQUOTE>  	Set the hop time (which corresponds approximately to the average
		density of Partial envelope Breakpoint data) for this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>setCropTime(x)</B></TT>
<BLOCKQUOTE>  	Set the crop time (maximum temporal displacement of a time-
		frequency data point from the time-domain center of the analysis
		window, beyond which data points are considered &quot;unreliable&quot;)
		for this Analyzer.
	   
</BLOCKQUOTE>

<P><TT><B>setBwRegionWidth(x)</B></TT>
<BLOCKQUOTE>  	Set the width (in Hz) of the Bandwidth Association regions
		used by this Analyzer.
	   
</BLOCKQUOTE>

<A name="s2_5_">
<H3>2.5. class BreakpointEnvelope</H3></A>
	A BreakpointEnvelope represents a linear segment breakpoint 
	function with infinite extension at each end (that is, the 
	values past either end of the breakpoint function have the 
	values at the nearest end).

<P><TT><B>BreakpointEnvelope()</B></TT>
<BLOCKQUOTE>  	Construct and return a new BreakpointEnvelope having no 
		breakpoints and an implicit value of 0. everywhere, 
		until the first breakpoint is inserted.			
	   
</BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Destroy this BreakpointEnvelope. 								
	   
</BLOCKQUOTE>

<P><TT><B>copy()</B></TT>
<BLOCKQUOTE>  	Construct and return a new BreakpointEnvelope that is
		a copy of this BreapointEnvelope (has the same value
		as this BreakpointEnvelope everywhere).			
	   
</BLOCKQUOTE>

<P><TT><B>valueAt(x)</B></TT>
<BLOCKQUOTE>  	Return the interpolated value of this BreakpointEnvelope at 
		the specified time.							
	   
</BLOCKQUOTE>

<P><TT><B>insertBreakpoint(time,value)</B></TT>
<BLOCKQUOTE>  	Insert a breakpoint representing the specified (time, value) 
		pair into this BreakpointEnvelope. If there is already a 
		breakpoint at the specified time, it will be replaced with 
		the new breakpoint.
	   
</BLOCKQUOTE>

<P><TT><B>BreakpointEnvelopeWithValue(initialValue)</B></TT>
<BLOCKQUOTE>  	Construct and return a new BreakpointEnvelope having a 
	single breakpoint at 0. having the specified initialValue.
   
</BLOCKQUOTE>

<A name="s2_6_">
<H3>2.6. class ExportSpc</H3></A>
	An ExportSpc represents a configuration of parameters for
	exporting a collection of Bandwidth-Enhanced partials to 
	an spc-format file for use with the Symbolic Sound Kyma
	System.

<P><TT><B>ExportSpc(midiPitch)</B></TT>
<BLOCKQUOTE>  	Construct a new ExportSpc instance configured from the 
		given MIDI note number. All other ExportSpc parameters
		are computed fromthe specified note number.
	   
</BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Destroy this ExportSpc instance.
	   
</BLOCKQUOTE>

<P><TT><B>write(filename,partials)</B></TT>
<BLOCKQUOTE>  	Export the given list of Partials to an spc file having the
		specified path (or name) according to the current configuration 
		of this ExportSpc instance.
	   
</BLOCKQUOTE>

<P><TT><B>configure(midiPitch)</B></TT>
<BLOCKQUOTE>  	Set the MIDI note number (69.00 = A440) for this spc file,
		and recompute all other parameters to default values.			
	   
</BLOCKQUOTE>

<P><TT><B>midiPitch()</B></TT>
<BLOCKQUOTE>  	Return the MIDI note number (69.00 = A440) for this spc file.
	   
</BLOCKQUOTE>

<P><TT><B>numPartials()</B></TT>
<BLOCKQUOTE>  	Return the number of partials in spc file, may 
		be 32, 64, 128, or 256.
	   
</BLOCKQUOTE>

<P><TT><B>refLabel()</B></TT>
<BLOCKQUOTE>  	Return the label of the reference partial for this ExportSpc
		instance. A reference label of 1 indicates the fundamental.
		The reference label is used for filling in frequencies during 
		time gaps in other partials. 
	   
</BLOCKQUOTE>

<P><TT><B>enhanced()</B></TT>
<BLOCKQUOTE>  	Return true if this spc file is in bandwidth-enhanced format,
		false if it is in pure sinusoidal format.
	   
</BLOCKQUOTE>

<P><TT><B>hop()</B></TT>
<BLOCKQUOTE>  	Return the frame duration (in seconds) for this spc file.
	   
</BLOCKQUOTE>

<P><TT><B>attackThreshold()</B></TT>
<BLOCKQUOTE>  	Return the amplitude threshold for cropping the start of the 
		spc file. This is specified as a fraction of maximum amplitude 
		of the sound, with a value between 0.0 and 1.0. If the value is 
		0.0, this indicates no cropping at the start of the spc file.
	   
</BLOCKQUOTE>

<P><TT><B>startFreqTime()</B></TT>
<BLOCKQUOTE>  	Return the time (in seconds) at which frequency in attack is 
		considered stable.  Frequencies before this time are modified 
		in the spc file to avoid real-time morphing artifacts when the 
		spc file is used in Kyma. This returns 0.0 if the spc file has 
		no modified attack frequencies.
	   
</BLOCKQUOTE>

<P><TT><B>endTime()</B></TT>
<BLOCKQUOTE>  	Return the time (in seconds) at which the end of the spc file 
		is truncated. This returns 0.0 if the spc file is not truncate 
		at the end.
	   
</BLOCKQUOTE>

<P><TT><B>endApproachTime()</B></TT>
<BLOCKQUOTE>  	Return a value in seconds that indicates how long before the 
		end of the spc file the amplitude, frequency, and bandwidth 
		values are modified to make a gradual transition to the spectral 
		content at the end of the spc file.  This returns 0.0 if no such 
		modifications are done in the spc file.	
	   
</BLOCKQUOTE>

<P><TT><B>markerTime()</B></TT>
<BLOCKQUOTE>  	Return the time (in seconds) at which a marker is inserted in 
		the spc file. This returns 0.0 if no marker is inserted into 
		the spc file.
	   
</BLOCKQUOTE>

<P><TT><B>setMidiPitch(x)</B></TT>
<BLOCKQUOTE>  	Set the MIDI note number (69.00 = A440) for this 
		spc file. (Does not cause other parameters to be 
		recomputed.) 			
	   
</BLOCKQUOTE>

<P><TT><B>setNumPartials(x)</B></TT>
<BLOCKQUOTE>  	Set the number of partials in spc file, may 
		be 32, 64, 128, or 256.
	   
</BLOCKQUOTE>

<P><TT><B>setRefLabel(x)</B></TT>
<BLOCKQUOTE>  	Set the label of the reference partial for this ExportSpc
		instance. A reference label of 1 indicates the fundamental.
		The reference partial is used for filling in frequencies 
		during time gaps in other partials. 
	   
</BLOCKQUOTE>

<P><TT><B>setEnhanced(x)</B></TT>
<BLOCKQUOTE>  	Set the type of spc file: true for bandwidth-enhanced format,
		false for pure sinusoidal format.
	  
</BLOCKQUOTE>

<P><TT><B>setHop(x)</B></TT>
<BLOCKQUOTE>  	Set the frame duration (in seconds) for this spc file.
	   
</BLOCKQUOTE>

<P><TT><B>setAttackThreshold(x)</B></TT>
<BLOCKQUOTE>  	Set the amplitude threshold for cropping the start of the spc 
		file. This is specified as a fraction of maximum amplitude of 
		the sound, with a value between 0.0 and 1.0.  Specify 0.0 for 
		no cropping of the start of the spc file.
	   
</BLOCKQUOTE>

<P><TT><B>setStartFreqTime(x)</B></TT>
<BLOCKQUOTE>  	Set the time (in seconds) at which frequency in attack is 
		considered stable.  Frequencies before this time are modified 
		in the spc file to avoid real-time morphing artifacts when the 
		spc file is used in Kyma. Specify 0.0 to avoid modified attack 
		frequencies.
	   
</BLOCKQUOTE>

<P><TT><B>setEndTime(x)</B></TT>
<BLOCKQUOTE>  	Set the time (in seconds) to truncate the end of the spc file.
		Set this to the 0.0 (or, equivalently, to the last end time of 
		any partial in the sound) to avoid truncating the end of the 
		spc file.
	   
</BLOCKQUOTE>

<P><TT><B>setEndApproachTime(x)</B></TT>
<BLOCKQUOTE>  	Set how long (in seconds) before the end of the spc file the 
		amplitude, frequency, and bandwidth values are to be modified 
		to make a gradual transition to the spectral content at the 
		end of the spc file. Specify 0.0 to avoid these modifications 
		in the spc file.	
	   
</BLOCKQUOTE>

<P><TT><B>setMarkerTime(x)</B></TT>
<BLOCKQUOTE>  	Set the time (in seconds) at which a marker is inserted in the 
		spc file. Only one marker is inserted into the spc file; it will
		be inserted at the time specified with setMarkerTime().  
		Specify 0.0 to avoid inserting a marker into the spc file.
	   
</BLOCKQUOTE>

<A name="s2_7_">
<H3>2.7. class SampleVector</H3></A>
	A SampleVector represents a vector of floating point samples of
	an audio waveform. In Loris, the samples are assumed to have 
	values on the range (-1., 1.) (though this is not enforced or 
	checked). 

<P><TT><B>SampleVector(size)</B></TT>
<BLOCKQUOTE>  	Return a new SampleVector having the specified number of samples,
		all of whose value is 0. 
		
		If no size is specified, 0 is assumed.
	   
</BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Destroy this SampleVector.
	    
</BLOCKQUOTE>

<P><TT><B>size()</B></TT>
<BLOCKQUOTE>  	Return the number of samples represented by this SampleVector.
	   
</BLOCKQUOTE>

<P><TT><B>resize(size)</B></TT>
<BLOCKQUOTE>  	Change the number of samples represented by this SampleVector. If
		the given size is greater than the current size, all new samples 
		will have value 0. If the given size is less than the current 
		size, then samples in excess of the given size are removed.
	   
</BLOCKQUOTE>

<P><TT><B>clear()</B></TT>
<BLOCKQUOTE>  	Remove all samples from this SampleVector, and set its
	 	size to zero.
	   
</BLOCKQUOTE>

<P><TT><B>copy()</B></TT>
<BLOCKQUOTE>  	Return a new SampleVector that is a copy of this 
		SampleVector, having the same number of samples, 
		and samples at every position in the copy having 
		the same value as the corresponding sample in
		this SampleVector.
	   
</BLOCKQUOTE>

<P><TT><B>getAt(idx)</B></TT>
<BLOCKQUOTE>  	Return the value of the sample at the given position (index) in
		this SampleVector.
	   
</BLOCKQUOTE>

<P><TT><B>setAt(idx,x)</B></TT>
<BLOCKQUOTE>  	Set the value of the sample at the given position (index) in
		this SampleVector.
	   
</BLOCKQUOTE>

<A name="s2_8_">
<H3>2.8. class AiffFile</H3></A>
	An AiffFile represents a sample file (on disk) in the Audio Interchange
	File Format. The file is read from disk and the samples stored in memory
	upon construction of an AiffFile instance. The samples are accessed by 
	the samples() method, which converts them to double precision floats and
	returns them in a SampleVector.

<P><TT><B>AiffFile(filename)</B></TT>
<BLOCKQUOTE>  	Import an AIFF file with the specified file name
		or path.
	   
</BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>  	Delete this AIFF data (does not affect data on disk).
	   
</BLOCKQUOTE>

<P><TT><B>channels()</B></TT>
<BLOCKQUOTE>  	Return the number of channels of sample data this AIFF file.
	   
</BLOCKQUOTE>

<P><TT><B>sampleFrames()</B></TT>
<BLOCKQUOTE>  	Return the number of frames of sample data this AIFF file.
	   
</BLOCKQUOTE>

<P><TT><B>sampleRate()</B></TT>
<BLOCKQUOTE>  	Return the sample rate in Hz of the sample data this AIFF file.
	   
</BLOCKQUOTE>

<P><TT><B>sampleSize()</B></TT>
<BLOCKQUOTE>  	Return the size in bits of the sample data this AIFF file.
	   
</BLOCKQUOTE>

<P><TT><B>samples()</B></TT>
<BLOCKQUOTE>  	Return a SampleVector containing the AIFF samples from this AIFF 
		file as double precision floats on the range -1,1.
	   
</BLOCKQUOTE>

<A name="s3_">
<HR><H2>3. Non-object-based procedures</H2></A>
<P>
	Operations in Loris that need not be accessed though object
	interfaces are represented as simple functions.
<P><TT><B>channelize(partials,refFreqEnvelope,refLabel)</B></TT>
<BLOCKQUOTE>  	Label Partials in a PartialList with the integer nearest to
	the amplitude-weighted average ratio of their frequency envelope
	to a reference frequency envelope. The frequency spectrum is 
	partitioned into non-overlapping channels whose time-varying 
	center frequencies track the reference frequency envelope. 
	The reference label indicates which channel's center frequency
	is exactly equal to the reference envelope frequency, and other
	channels' center frequencies are multiples of the reference 
	envelope frequency divided by the reference label. Each Partial 
	in the PartialList is labeled with the number of the channel
	that best fits its frequency envelope. The quality of the fit
	is evaluated at the breakpoints in the Partial envelope and
	weighted by the amplitude at each breakpoint, so that high-
	amplitude breakpoints contribute more to the channel decision.
	Partials are labeled, but otherwise unmodified. In particular, 
	their frequencies are not modified in any way.
   
</BLOCKQUOTE>

<P><TT><B>dilate(partials,initial_times,target_times)</B></TT>
<BLOCKQUOTE>  	Dilate Partials in a PartialList according to the given 
	initial and target time points. Partial envelopes are 
	stretched and compressed so that temporal features at
	the initial time points are aligned with the final time
	points. Time points are sorted, so Partial envelopes are 
	are only stretched and compressed, but breakpoints are not
	reordered. Duplicate time points are allowed. There must be
	the same number of initial and target time points.
	
	The time points are passed as strings; convert any native
	collection to a string representation, numerical elements
	will be extracted, other characters will be ignored.
   
</BLOCKQUOTE>

<P><TT><B>distill(partials)</B></TT>
<BLOCKQUOTE>  	Distill labeled (channelized)  Partials in a PartialList into a 
	PartialList containing a single (labeled) Partial per label. 
	The distilled PartialList will contain as many Partials as
	there were non-zero labels in the original PartialList. Unlabeled 
	(label 0) Partials are eliminated.
   
</BLOCKQUOTE>

<P><TT><B>exportAiff(path,samples,samplerate,nchannels,bitsPerSamp)</B></TT>
<BLOCKQUOTE>  	Export audio samples stored in a SampleVector to an AIFF file
		having the specified number of channels and sample rate at the 
		given file path (or name). The floating point samples in the 
		SampleVector are clamped to the range (-1.,1.) and converted 
		to integers having bitsPerSamp bits.
	   
</BLOCKQUOTE>

<P><TT><B>exportSdif(path,partials,hop)</B></TT>
<BLOCKQUOTE>  	Export Partials in a PartialList to a SDIF file at the specified
	file path (or name). SDIF data is written in the 1TRC format.  
	For more information about SDIF, see the SDIF website at:
		www.ircam.fr/equipes/analyse-synthese/sdif/  
		
	The hop parameter is currently used to specify a time-domain 
	resampling of the Partial envelopes. This parameter is 
	deprecated, and will be removed in future versions, which 
	will have explicit resampling functionality. If hop is 0., 
	Partial envelopes will not be resampled, and all Partial 
	envelope data will be stored.
	
	If unspecified, hop defaults to 0.
   
</BLOCKQUOTE>

<P><TT><B>importAiff(path)</B></TT>
<BLOCKQUOTE>  	Import audio samples stored in an AIFF file at the given file
	path (or name). The samples are converted to floating point 
	values on the range (-1.,1.) and returned in a SampleVector, 
	which is sized to (exactly) accomodate all the samples 
	in the file. Use infoAiff( path ) to get the sample rate
	and the number of channels.
   
</BLOCKQUOTE>

<P><TT><B>importSdif(path)</B></TT>
<BLOCKQUOTE>  	Import Partials from an SDIF file at the given file path (or 
	name), and return them in a PartialList.
	For more information about SDIF, see the SDIF website at:
		www.ircam.fr/equipes/analyse-synthese/sdif/  
   
</BLOCKQUOTE>

<P><TT><B>infoAiff(path)</B></TT>
<BLOCKQUOTE>  	Return the number of sample frames, sample rate, and number 
		of channels of audio samples stored in an AIFF file at the 
		given file path (or name). The samples themselves are obtained 
		using importAiff( path ). 
	   
</BLOCKQUOTE>

<P><TT><B>morph(src0,src1,ffreq,famp,fbw)</B></TT>
<BLOCKQUOTE>  	Morph labeled Partials in two PartialLists according to the
	given frequency, amplitude, and bandwidth (noisiness) morphing
	envelopes, and return the morphed Partials in a PartialList. 
	Loris morphs Partials by interpolating frequency, amplitude, 
	and bandwidth envelopes of corresponding Partials in the
	source PartialLists. For more information about the Loris
	morphing algorithm, see the Loris website: 
	www.cerlsoundgroup.org/Loris/
   
</BLOCKQUOTE>

<P><TT><B>synthesize(partials,srate)</B></TT>
<BLOCKQUOTE>  	Synthesize Partials in a PartialList at the given sample
	rate, and return the (floating point) samples in a SampleVector.
	The SampleVector is sized to hold as many samples as are needed 
	for the complete synthesis of all the Partials in the PartialList. 
   
</BLOCKQUOTE>

<A name="s4_">
<HR><H2>4. Utility functions</H2></A>
<P>
	These procedures are generally useful but are not yet  
	represented by classes in the Loris core.
<P><TT><B>copyByLabel(src,label,dst)</B></TT>
<BLOCKQUOTE>  	Append copies of Partials in the source PartialList having the
	specified label to the destination PartialList. The source list
	is unmodified.
   
</BLOCKQUOTE>

<P><TT><B>createFreqReference(partials,numSamples,minFreq,maxFreq)</B></TT>
<BLOCKQUOTE>  	Return a newly-constructed BreakpointEnvelope comprising the
	specified number of samples of the frequency envelope of the
	longest Partial in a PartialList. Only Partials whose frequency
	at the Partial's loudest (highest amplitude) breakpoint is
	within the given frequency range are considered. 
	
	For very simple sounds, this frequency reference may be a 
	good first approximation to a reference envelope for
	channelization (see channelize()).
   
</BLOCKQUOTE>

<P><TT><B>scaleAmp(partials,ampEnv)</B></TT>
<BLOCKQUOTE>  	Scale the amplitude of the Partials in a PartialList according 
	to an envelope representing a time-varying amplitude scale value.
   
</BLOCKQUOTE>

<P><TT><B>scaleNoiseRatio(partials,noiseEnv)</B></TT>
<BLOCKQUOTE>  	Scale the relative noise content of the Partials in a PartialList 
	according to an envelope representing a (time-varying) noise energy 
	scale value.
   
</BLOCKQUOTE>

<P><TT><B>shiftPitch(partials,pitchEnv)</B></TT>
<BLOCKQUOTE>  	Shift the pitch of all Partials in a PartialList according to 
	the given pitch envelope. The pitch envelope is assumed to have 
	units of cents (1/100 of a halfstep).
   
</BLOCKQUOTE>

<P><TT><B>sift(partials)</B></TT>
<BLOCKQUOTE>  	Lippold's wacky experimental sifting thingie: 
		If any two partials with same label overlap in time,
		keep only the longer of the two partials.
		Set the label of the shorter duration partial to zero.
	   
</BLOCKQUOTE>


</BODY>
</HTML>
