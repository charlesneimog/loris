<html>
<head>
<title>
Loris procedural interface</title>
<body bgcolor="#ffffff">
<h1>Loris procedural interface - version 1.0</h1>

This document describes the functions in the 
C-linkable procedural interface for Loris. 

<hr><h1> Contents </h1>
<ul><li> <a href="#s1_">1. Analyzer object interface</a>
<li> <a href="#s2_">2. BreakpointEnvelope object interface</a>
<li> <a href="#s3_">3. PartialList object interface</a>
<li> <a href="#s4_">4. SampleVector object interface</a>
<li> <a href="#s5_">5. Non-object-based procedures and utility functions</a>
<li> <a href="#s7_">6. Notification and exception handlers</a>
<li> <a href="#s8_">7. Version macros</a>
</ul>

<a name="s1_">
<hr><h2>1. Analyzer object interface</h2></a>
<p>
	An Analyzer represents a configuration of parameters for
	performing Reassigned Bandwidth-Enhanced Additive Analysis
	of sampled waveforms. This analysis process yields a collection 
	of Partials, each having a trio of synchronous, non-uniformly-
	sampled breakpoint envelopes representing the time-varying 
	frequency, amplitude, and noisiness of a single bandwidth-
	enhanced sinusoid. <p>

	For more information about Reassigned Bandwidth-Enhanced 
	Analysis and the Reassigned Bandwidth-Enhanced Additive Sound 
	Model, refer to the Loris website: 
	<a href="http://www.cerlsoundgroup.org/Loris/" 
	name="Loris web site">www.cerlsoundgroup.org/Loris/</a><p>
	
	In C++, Analyzer is Loris::Analyzer, defined in Analyzer.h.
	
<p><tt><b>createAnalyzer( double resolution, double windowWidth )</b></tt>
<blockquote>[ returns Analyzer *  ]
<br>  	Construct and return a new Analyzer configured with the given	
	frequency resolution (minimum instantaneous frequency	
	difference between Partials) and analysis window main 
	lobe width (between zeros). All other Analyzer parameters 	
	are computed from the specified  resolution and window width.   
</blockquote>

<p><tt><b>destroyAnalyzer( Analyzer * a )</b></tt>
<blockquote>[ returns void  ]
<br>  	Destroy this Analyzer. 								
   
</blockquote>

<p><tt><b>analyzer_analyze( Analyzer * a, 
					   const SampleVector * vec, double srate,
					   PartialList * partials )</b></tt>
<blockquote>[ returns void  ]
<br>  	Analyze a vector of (mono) samples at the given sample rate 	  	
	(in Hz) and append the extracted Partials to the given 
	PartialList. 												
   
</blockquote>

<p><tt><b>analyzer_getAmpFloor( const Analyzer * a )</b></tt>
<blockquote>[ returns double  ]
<br>  	Return the amplitude floor (lowest detected spectral amplitude),  			
	in (negative) dB, for this Analyzer. 				
   
</blockquote>

<p><tt><b>analyzer_getBwRegionWidth( const Analyzer * a )</b></tt>
<blockquote>[ returns double  ]
<br>  	Return the width (in Hz) of the Bandwidth Association regions
	used by this Analyzer.<p>
	
	This parameter is deprecated and not generally useful. It will be
	removed in a future release.
   
</blockquote>

<p><tt><b>analyzer_getCropTime( const Analyzer * a )</b></tt>
<blockquote>[ returns double  ]
<br>  	Return the crop time (maximum temporal displacement of a time-
	frequency data point from the time-domain center of the analysis
	window, beyond which data points are considered &quot;unreliable&quot;)
	for this Analyzer.<p>
	
	This parameter is deprecated and not generally useful. It will be
	removed in a future release.
   
</blockquote>

<p><tt><b>analyzer_getFreqDrift( const Analyzer * a )</b></tt>
<blockquote>[ returns double  ]
<br>  	Return the maximum allowable frequency difference between 					
	consecutive Breakpoints in a Partial envelope for this Analyzer. 				
   
</blockquote>

<p><tt><b>analyzer_getFreqFloor( const Analyzer * a )</b></tt>
<blockquote>[ returns double  ]
<br>  	Return the frequency floor (minimum instantaneous Partial  				
	frequency), in Hz, for this Analyzer. 				
   
</blockquote>

<p><tt><b>analyzer_getFreqResolution( const Analyzer * a )</b></tt>
<blockquote>[ returns double  ]
<br>  	Return the frequency resolution (minimum instantaneous frequency  		
	difference between Partials) for this Analyzer. 	
   
</blockquote>

<p><tt><b>analyzer_getHopTime( const Analyzer * a )</b></tt>
<blockquote>[ returns double  ]
<br>  	Return the hop time (which corresponds approximately to the 
	average density of Partial envelope Breakpoint data) for this 
	Analyzer.
   
</blockquote>

<p><tt><b>analyzer_getWindowWidth( const Analyzer * a )</b></tt>
<blockquote>[ returns double  ]
<br>  	Return the frequency-domain main lobe width (measured between 
	zero-crossings) of the analysis window used by this Analyzer. 				
   
</blockquote>

<p><tt><b>analyzer_setAmpFloor( Analyzer * a, double x )</b></tt>
<blockquote>[ returns void  ]
<br>  	Set the amplitude floor (lowest detected spectral amplitude), in  			
	(negative) dB, for this Analyzer. 				
   
</blockquote>

<p><tt><b>analyzer_setBwRegionWidth( Analyzer * a, double x )</b></tt>
<blockquote>[ returns void  ]
<br>  	Set the width (in Hz) of the Bandwidth Association regions
	used by this Analyzer.<p>
	
	This parameter is deprecated and not generally useful. It will be
	removed in a future release.
   
</blockquote>

<p><tt><b>analyzer_setCropTime( Analyzer * a, double x )</b></tt>
<blockquote>[ returns void  ]
<br>  	Set the crop time (maximum temporal displacement of a time-
	frequency data point from the time-domain center of the analysis
	window, beyond which data points are considered &quot;unreliable&quot;)
	for this Analyzer.<p>
	
	This parameter is deprecated and not generally useful. It will be
	removed in a future release.
   
</blockquote>

<p><tt><b>analyzer_setFreqDrift( Analyzer * a, double x )</b></tt>
<blockquote>[ returns void  ]
<br>  	Set the maximum allowable frequency difference between 					
	consecutive Breakpoints in a Partial envelope for this Analyzer. 				
   
</blockquote>

<p><tt><b>analyzer_setFreqFloor( Analyzer * a, double x )</b></tt>
<blockquote>[ returns void  ]
<br>  	Set the amplitude floor (minimum instantaneous Partial  				
	frequency), in Hz, for this Analyzer.
   
</blockquote>

<p><tt><b>analyzer_setHopTime( Analyzer * a, double x )</b></tt>
<blockquote>[ returns void  ]
<br>  	Set the hop time (which corresponds approximately to the average
	density of Partial envelope Breakpoint data) for this Analyzer.
   
</blockquote>

<p><tt><b>analyzer_setFreqResolution( Analyzer * a, double x )</b></tt>
<blockquote>[ returns void  ]
<br>  	Set the frequency resolution (minimum instantaneous frequency  		
	difference between Partials) for this Analyzer. (Does not cause 	
	other parameters to be recomputed.) 									
   
</blockquote>

<p><tt><b>analyzer_setWindowWidth( Analyzer * a, double x )</b></tt>
<blockquote>[ returns void  ]
<br>  	Set the frequency-domain main lobe width (measured between 
	zero-crossings) of the analysis window used by this Analyzer. 				
   
</blockquote>


<a name="s2_">
<hr><h2>2. BreakpointEnvelope object interface</h2></a>
<p>
	A BreakpointEnvelope represents a linear segment breakpoint 
	function with infinite extension at each end (that is, the 
	values past either end of the breakpoint function have the 
	values at the nearest end).<p>

	In C++, a BreakpointEnvelope is a Loris::BreakpointEnvelope.
<p><tt><b>createBreakpointEnvelope()</b></tt>
<blockquote>[ returns BreakpointEnvelope *  ]
<br>  	Construct and return a new BreakpointEnvelope having no 
	breakpoints (and an implicit value of 0. everywhere).			
   
</blockquote>

<p><tt><b>destroyBreakpointEnvelope( BreakpointEnvelope * env )</b></tt>
<blockquote>[ returns void  ]
<br>  	Destroy this BreakpointEnvelope. 								
   
</blockquote>

<p><tt><b>breakpointEnvelope_insertBreakpoint( BreakpointEnvelope * env,
					double time, double val )</b></tt>
<blockquote>[ returns void  ]
<br>  	Insert a breakpoint representing the specified (time, value) 
	pair into this BreakpointEnvelope. If there is already a 
	breakpoint at the specified time, it will be replaced with 
	the new breakpoint.
   
</blockquote>

<p><tt><b>breakpointEnvelope_valueAt( BreakpointEnvelope * env, 
								   double time )</b></tt>
<blockquote>[ returns double  ]
<br>  	Return the interpolated value of this BreakpointEnvelope at the 
	specified time.							
   
</blockquote>

<a name="s3_">
<hr><h2>3. PartialList object interface</h2></a>
<p>
	A PartialList represents a collection of Bandwidth-Enhanced 
	Partials, each having a trio of synchronous, non-uniformly-
	sampled breakpoint envelopes representing the time-varying 
	frequency, amplitude, and noisiness of a single bandwidth-
	enhanced sinusoid.<p>

	For more information about Bandwidth-Enhanced Partials and the  
	Reassigned Bandwidth-Enhanced Additive Sound Model, refer to
	the Loris website:  
	<a href="http://www.cerlsoundgroup.org/Loris/" 
	name="Loris web site">www.cerlsoundgroup.org/Loris/</a><p>

	In C++, a PartialList is a std::list< Loris::Partial >.
<p><tt><b>createPartialList()</b></tt>
<blockquote>[ returns PartialList *  ]
<br>  	Return a new empty PartialList.
   
</blockquote>

<p><tt><b>destroyPartialList( PartialList * plist )</b></tt>
<blockquote>[ returns void  ]
<br>  	Destroy this PartialList.
   
</blockquote>

<p><tt><b>partialList_clear( PartialList * plist )</b></tt>
<blockquote>[ returns void  ]
<br>  	Remove (and destroy) all the Partials from this PartialList,
	leaving it empty.
   
</blockquote>

<p><tt><b>partialList_copy( PartialList * plist, 
					   const PartialList * src )</b></tt>
<blockquote>[ returns void  ]
<br>  	Make this PartialList a copy of the source PartialList by making
	copies of all of the Partials in the source and adding them to 
	this PartialList.
   
</blockquote>

<p><tt><b>partialList_size( const PartialList * plist )</b></tt>
<blockquote>[ returns unsigned long  ]
<br>  	Return the number of Partials in this PartialList.
   
</blockquote>

<p><tt><b>partialList_splice( PartialList * plist, 
						 PartialList * src )</b></tt>
<blockquote>[ returns void  ]
<br>  	Splice all the Partials in the source PartialList onto the end of
	this PartialList, leaving the source empty.
   
</blockquote>

<a name="s4_">
<hr><h2>4. SampleVector object interface</h2></a>
<p>
	A SampleVector represents a vector of floating point samples of
	an audio waveform. In Loris, the samples are assumed to have 
	values on the range (-1., 1.) (though this is not enforced or 
	checked). 

	In C++, a SampleVector is a std::vector< double >.
<p><tt><b>createSampleVector( unsigned long size )</b></tt>
<blockquote>[ returns SampleVector *  ]
<br>  	Return a new SampleVector having the specified number of samples,
	all of whose value is 0. 
	
	If no size is specified, 0 is assumed.
   
</blockquote>

<p><tt><b>destroySampleVector( SampleVector * vec )</b></tt>
<blockquote>[ returns void  ]
<br>  	Destroy this SampleVector.
   
</blockquote>

<p><tt><b>sampleVector_copy( SampleVector * vec, 
						const SampleVector * src )</b></tt>
<blockquote>[ returns void  ]
<br>  	Make this SampleVector a copy of the source SampleVector, having 
	the same number of samples, and samples at every position in this
	SampleVector having the same value as the corresponding sample in
	the source.
   
</blockquote>

<p><tt><b>sampleVector_getAt( const SampleVector * vec, unsigned long idx )</b></tt>
<blockquote>[ returns double  ]
<br>  	Return the value of the sample at the given position (index) in
	this SampleVector.
   
</blockquote>

<p><tt><b>sampleVector_getLength( const SampleVector * vec )</b></tt>
<blockquote>[ returns unsigned long  ]
<br>  	Return the number of samples represented by this SampleVector.
   
</blockquote>

<p><tt><b>sampleVector_setAt( SampleVector * vec, unsigned long idx, double x )</b></tt>
<blockquote>[ returns void  ]
<br>  	Set the value of the sample at the given position (index) in
	this SampleVector.
   
</blockquote>

<p><tt><b>sampleVector_setLength( SampleVector * vec, unsigned long size )</b></tt>
<blockquote>[ returns void  ]
<br>  	Change the number of samples represented by this SampleVector. If
	the given size is greater than the current size, all new samples 
	will have value 0. If the given size is less than the current 
	size, then samples in excess of the given size are removed.
   
</blockquote>

<a name="s5_">
<hr><h2>5. Non-object-based procedures and utility functions.</h2></a>
<p>
	Operations in Loris that need not be accessed though object
	interfaces are represented as simple functions.
<p><tt><b>channelize( PartialList * partials, 
				 BreakpointEnvelope * refFreqEnvelope, int refLabel )</b></tt>
<blockquote>[ returns void  ]
<br>  	Label Partials in a PartialList with the integer nearest to
	the amplitude-weighted average ratio of their frequency envelope
	to a reference frequency envelope. The frequency spectrum is 
	partitioned into non-overlapping channels whose time-varying 
	center frequencies track the reference frequency envelope. 
	The reference label indicates which channel's center frequency
	is exactly equal to the reference envelope frequency, and other
	channels' center frequencies are multiples of the reference 
	envelope frequency divided by the reference label. Each Partial 
	in the PartialList is labeled with the number of the channel
	that best fits its frequency envelope. The quality of the fit
	is evaluated at the breakpoints in the Partial envelope and
	weighted by the amplitude at each breakpoint, so that high-
	amplitude breakpoints contribute more to the channel decision.
	Partials are labeled, but otherwise unmodified. In particular, 
	their frequencies are not modified in any way.
   
</blockquote>

<p><tt><b>copyByLabel( const PartialList * src, long label, PartialList * dst )</b></tt>
<blockquote>[ returns void  ]
<br>  	Append copies of Partials in the source PartialList having the
	specified label to the destination PartialList. The source list
	is unmodified.
   
</blockquote>

<p><tt><b>createFreqReference( PartialList * partials, 
							   double minFreq, double maxFreq, 
							   long numSamps )</b></tt>
<blockquote>[ returns BreakpointEnvelope *  ]
<br>  Return a newly-constructed BreakpointEnvelope by sampling the 
	frequency envelope of the longest Partial in a PartialList. 
	Only Partials whose frequency at the Partial's loudest (highest 
	amplitude) breakpoint is within the given frequency range are 
	considered. The envelope will have the specified number of samples.
	If the specified number of samples is 0, then the
	longest Partial's frequency envelope is sampled every 30 ms
	(No fewer than 10 samples are used, so the sampling maybe more
	dense for very short Partials.) <p>
	
	For very simple sounds, this frequency reference may be a 
	good first approximation to a reference envelope for
	channelization (see channelize()).<p>
	
	Clients are responsible for disposing of the newly-constructed 
	BreakpointEnvelope.
   
</blockquote>

<p><tt><b>crop( PartialList * partials, double begintime, double endtime)</b></tt>
<blockquote>  	Trim Partials by removing Breakpoints outside a specified time span.
	Insert a Breakpoint at the boundary when cropping occurs.
</blockquote>



<p><tt><b>dilate( PartialList * partials, 
			 double * initial, double * target, int npts )</b></tt>
<blockquote>[ returns void  ]
<br>  	Dilate Partials in a PartialList according to the given 
	initial and target time points. Partial envelopes are 
	stretched and compressed so that temporal features at
	the initial time points are aligned with the final time
	points. Time points are sorted, so Partial envelopes are 
	are only stretched and compressed, but breakpoints are not
	reordered. Duplicate time points are allowed. There must be
	the same number of initial and target time points.<p>
	
	The time points are passed as strings; convert any native
	collection to a string representation, numerical elements
	will be extracted, other characters will be ignored.
   
</blockquote>

<p><tt><b>distill( PartialList * partials )</b></tt>
<blockquote>[ returns void  ]
<br>  	Distill labeled (channelized)  Partials in a PartialList into a 
	PartialList containing a single (labeled) Partial per label. 
	The distilled PartialList will contain as many Partials as
	there were non-zero labels (non-empty channels)
	in the original PartialList. Additionally, unlabeled (label 0) Partials are 
	"collated" into groups of temporally non-overlapping Partials,
	assigned an unused label, and fused into a single Partial per
	group.
   
</blockquote>

<p><tt><b>exportAiff( const char * path, const SampleVector * vec, 
				 double samplerate, int nchannels, int bitsPerSamp )</b></tt>
<blockquote>[ returns void  ]
<br>  	Export audio samples stored in a SampleVector to an AIFF file
	having the specified number of channels and sample rate at the 
	given file path (or name). The floating point samples in the 
	SampleVector are clamped to the range (-1.,1.) and converted 
	to integers having bitsPerSamp bits.
   
</blockquote>

<p><tt><b>exportSdif( const char * path, PartialList * partials )</b></tt>
<blockquote>[ returns void  ]
<br>  	Export Partials in a PartialList to a SDIF file at the specified
	file path (or name). SDIF data is described by RBEM and RBEL 
	matrices. 
	For more information about SDIF, see the SDIF web site at:
		www.ircam.fr/equipes/analyse-synthese/sdif/ 
   
</blockquote>

<p><tt><b>exportSpc( const char * path, PartialList * partials, double midiPitch, 
				int enhanced, double endApproachTime )</b></tt>
<blockquote>[ returns void  ]
<br>  	Export Partials in a PartialList to a Spc file at the specified file
	path (or name). The fractional MIDI pitch must be specified. The 
	enhanced parameter defaults to true (for bandwidth-enhanced spc files), 
	but can be specified false for pure-sines spc files. The endApproachTime 
	parameter is in seconds. A nonzero endApproachTime indicates that the plist does 
	not include a release, but rather ends in a static spectrum corresponding 
	to the final breakpoint values of the partials. The endApproachTime
	specifies how long before the end of the sound the amplitude, frequency, 
	and bandwidth values are to be modified to make a gradual transition to 
	the static spectrum.   
</blockquote>

<p><tt><b>importAiff( const char * path, SampleVector * vec, 
				 double * samplerate, int * nchannels )</b></tt>
<blockquote>[ returns void  ]
<br>  	Import audio samples stored in an AIFF file at the given file
	path (or name). The samples are converted to floating point 
	values on the range (-1.,1.) and stored in the given 
	SampleVector, which is resized to (exactly) accomodate all the 
	samples from in the file. If samplerate is not a NULL pointer, 
	then, on return, it points to the value of the sample rate (in
	Hz) of the AIFF samples. Similarly, if nchannels is not a NULL
	pointer, then, on return, it points to the value of the number
	of channels of audio data represented by the AIFF samples.
   
</blockquote>

<p><tt><b>importSdif( const char * path, PartialList * partials )</b></tt>
<blockquote>[ returns void  ]
<br>  	Import Partials from an SDIF file at the given file path (or 
	name), and append them to a PartialList.
	For more information about SDIF, see the SDIF website at:
		<a href="http://www.ircam.fr/equipes/analyse-synthese/sdif/" 
		name="IRCAM SDIF web site">www.ircam.fr/equipes/analyse-synthese/sdif/</a>  
   
</blockquote>

<p><tt><b>importSpc( const char * path, PartialList * partials )</b></tt>
<blockquote>[ returns void  ]
<br>  	Import Partials from an Spc file at the given file path (or 
	name), and return them in a PartialList.   
</blockquote>

<p><tt><b>morph( const PartialList * src0, const PartialList * src1, 
			const BreakpointEnvelope * ffreq, 
			const BreakpointEnvelope * famp, 
			const BreakpointEnvelope * fbw, 
			PartialList * dst )</b></tt>
<blockquote>[ returns void  ]
<br>  	Morph labeled Partials in two PartialLists according to the
	given frequency, amplitude, and bandwidth (noisiness) morphing
	envelopes, and append the morphed Partials to the destination 
	PartialList. Loris morphs Partials by interpolating frequency,
	amplitude, and bandwidth envelopes of corresponding Partials in 
	the source PartialLists. For more information about the Loris
	morphing algorithm, see the Loris website: 
	<a href="http://www.cerlsoundgroup.org/Loris/" 
	name="Loris web site">www.cerlsoundgroup.org/Loris/</a>
   
</blockquote>

<p><tt><b>resample( PartialList * partials, double interval )</b></tt>
<blockquote>  	Resample all Partials in a PartialList using the specified
	sampling interval, so that the Breakpoints in the Partial 
	envelopes will all lie on a common temporal grid.
	The Breakpoint times in resampled Partials will comprise a  
	contiguous sequence of integer multiples of the sampling interval,
	beginning with the multiple nearest to the Partial's start time and
	ending with the multiple nearest to the Partial's end time. Resampling
	is performed in-place. 
</blockquote>

<p><tt><b>scaleAmp( PartialList * partials, BreakpointEnvelope * ampEnv )</b></tt>
<blockquote>[ returns void  ]
<br>  	Scale the amplitude of the Partials in a PartialList according 
	to an envelope representing a time-varying amplitude scale value.
   
</blockquote>

<p><tt><b>scaleBandwidth( PartialList * partials, BreakpointEnvelope * bwEnv )</b></tt>
<blockquote>  	Scale the bandwidth of the Partials in a PartialList according 
	to an envelope representing a time-varying bandwidth scale value.
	   
</blockquote>

<p><tt><b>scaleFrequency( PartialList * partials, BreakpointEnvelope * freqEnv )</b></tt>
<blockquote>  	Scale the frequency of the Partials in a PartialList according 
	to an envelope representing a time-varying frequency scale value.
	   
</blockquote>

<p><tt><b>scaleNoiseRatio( PartialList * partials, BreakpointEnvelope * noiseEnv )</b></tt>
<blockquote>[ returns void  ]
<br>  	Scale the relative noise content of the Partials in a PartialList 
	according to an envelope representing a (time-varying) noise energy 
	scale value.
   
</blockquote>

<p><tt><b>shiftPitch( PartialList * partials, BreakpointEnvelope * pitchEnv )</b></tt>
<blockquote>[ returns void  ]
<br>  	Shift the pitch of all Partials in a PartialList according to 
	the given pitch envelope. The pitch envelope is assumed to have 
	units of cents (1/100 of a halfstep).
   
</blockquote>

<p><tt><b>shiftTime( PartialList * partials, double offset )</b></tt>
<blockquote>  	Shift the time of all the Breakpoints in a Partial by a 
	constant amount.
	   
</blockquote>


<p><tt><b>synthesize( const PartialList * partials,
				 SampleVector * samples,  
				 double srate )</b></tt>
<blockquote>[ returns void  ]
<br>  	Synthesize Partials in a PartialList at the given sample
	rate, and store the (floating point) samples in a SampleVector.
	The SampleVector is resized, if necessary, to hold as many
	samples as are needed for the complete synthesis of all the
	Partials in the PartialList. The SampleVector is not 
	cleared before synthesis, so newly synthesized samples are
	added to any previously computed samples in the SampleVector.
   
</blockquote>

<p><tt><b>sift( PartialList * partials )</b></tt>
<blockquote>[ returns void  ]
<br>    Eliminate overlapping Partials having the same label
    (except zero). If any two partials with same label
    overlap in time, keep only the longer of the two.
    Set the label of the shorter duration partial to zero.

</blockquote>


<a name="s7_">
<hr><h2>6. Notification and exception handlers</h2></a>
<p>
	An exception handler and a notifier may be specified. Both 
	are functions taking a const char * argument and returning
	void.
<p><tt><b>setExceptionHandler( void(*f)(const char *) )</b></tt>
<blockquote>[ returns void  ]
<br>  	Specify a function to call when reporting exceptions. The 
	function takes a const char * argument, and returns void.
   
</blockquote>

<p><tt><b>setNotifier( void(*f)(const char *) )</b></tt>
<blockquote>[ returns void  ]
<br>  	Specify a notification function. The function takes a 
	const char * argument, and returns void.
   
</blockquote>

<a name="s8_">
<hr><h2>7. Version macros</h2></a>
<p>
	The following macros, defined in <tt>loris.h</tt>, specify major,
	minor, and subminor version numbers for the Loris library.

<ul>
	<li><tt>LORIS_MAJOR_VERSION</tt> </li>
	<li><tt>LORIS_MINOR_VERSION</tt> </li>
	<li><tt>LORIS_SUBMINOR_VERSION</tt> </li>
</ul>

Additionally, the macro
<tt>LORIS_VERSION_STR</tt> is a character string describing the Loris release.<p>

For example, in the ninth beta release of Loris 1.0 (subminor version 0), the 
macros have the definitions:
<ul>
	<li><tt>LORIS_MAJOR_VERSION</tt> &nbsp;&nbsp;1 </li>
	<li><tt>LORIS_MINOR_VERSION</tt> &nbsp;&nbsp;0 </li>
	<li><tt>LORIS_SUBMINOR_VERSION</tt> &nbsp;&nbsp;0 </li>
	<li><tt>LORIS_VERSION_STR</tt> &nbsp;&nbsp;"1.0beta9" </li>
</ul>

<hr align="Center" size="3">    
<table cellspacing="0" cellpadding="1" width="100%">
  <tbody>
	<tr>
	  <td valign="Top">Last updated on 7 May 2002
	  </td>
	  <td align="Right" valign="Top"><a href="http://www.cerlsoundgroup.org/Loris/">www.cerlsoundgroup.org/Loris/</a>
	  </td>
	</tr>       
  </tbody>    

</body>
</html>
