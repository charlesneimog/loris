<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
	<title>Loris C++ API</title>
	<meta name="generator" content="BBEdit 6.1.2+">
</head>
<body BGCOLOR="#ffffff">

<h1>Loris C++ API - version 1.0</h1>

This document describes the public interfaces for the 
classes in the Loris C++ class library. 

<a name="contents"><h1>Classes</h1></a>
<ul>
<li><a href="#AiffFile">AiffFile</a>
<li><a href="#Analyzer">Analyzer</a>
<li><a href="#Breakpoint">Breakpoint</a>
<li><a href="#BreakpointEnvelope">BreakpointEnvelope</a>
<li><a href="#BreakpointUtils">BreakpointUtils</a>
<li><a href="#Channelizer">Channelizer</a>
<li><a href="#Dilator">Dilator</a>
<li><a href="#Distiller">Distiller</a>
<li><a href="#Envelope">Envelope</a>
<li><a href="#Exception">Exception</a>
<li><a href="#FrequencyReference">FrequencyReference</a>
<li><a href="#Morpher">Morpher</a>
<li><a href="#Notifier">Notifier</a>
<li><a href="#Oscillator">Oscillator</a>
<li><a href="#Partial">Partial</a>
<li><a href="#PartialList">PartialList</a>
<li><a href="#PartialUtils">PartialUtils</a>
<li><a href="#SdifFile">SdifFile</a>
<li><a href="#Sieve">Sieve</a>
<li><a href="#SpcFile">SpcFile</a>
<li><a href="#Synthesizer">Synthesizer</a>
</ul>

<a name="AiffFile">
<hr><h2>AiffFile</h2></a>
<p>
Class AiffFile represents a AIFF-format samples file, and
manages file I/O and sample conversion. Construction of an 
AiffFile from a stream or filename automatically imports 
the sample data. The static Export() members export samples 
(doubles) to a AIFF file using the specified stream or filename.
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>

<p><tt><b>AiffFile( const std::string & filename )</b></tt>
<blockquote>
<br>
Initialize an instance of AiffFile by importing data from
the file having the specified filename or path.
</blockquote>

<p><tt><b>AiffFile( std::istream & s )</b></tt>
<blockquote>
<br>
Initialize an instance of AiffFile by importing data from
the specified istream.
</blockquote>

<h4>Header Access</h4>
<p><tt><b>channels( void ) const</b></tt>
<blockquote>[ returns int  ]
<br>
Return the number of channels of sample data represented in this
AiffFile (e.g. 1 for mono, 2 for stereo, etc).
</blockquote>

<p><tt><b>sampleFrames( void ) const</b></tt>
<blockquote>[ returns unsigned long  ]
<br>
Return the number of sample frames represented in this AiffFile.
A sample frame contains one sample per channel for a single sample
interval (e.g. mono and stereo samples files having a sample rate of
44100 Hz both have 44100 sample frames per second of audio samples).
</blockquote>

<p><tt><b>sampleRate( void ) const</b></tt>
<blockquote>[ returns double  ]
<br>
Return the sampling freqency in Hz for the sample data in this
AiffFile.
</blockquote>

<p><tt><b>sampleSize( void ) const</b></tt>
<blockquote>[ returns int  ]
<br>
Return the size in bits of a single, integer audio sample in this AiffFile.
</blockquote>

<h4>Sample Access</h4>
<p><tt><b>getSamples( double * bufBegin, double * bufEnd )</b></tt>
<blockquote>[ returns void  ]
<br>
Convert the integer sample data to doubles and store in on the half-open
(STL-style) range [bufBegin, bufEnd). bufEnd represents a position after
the last valid position in the buffer, no sample is written at bufEnd.
To convert ten samples into a buffer, use <br>
<tt>myAiffFile.getSamples(myBuf, myBuf+10);</tt><br>
</blockquote>

<h4>Export (static)</h4>
<p><tt><b>static Export( const std::string & filename, double rate, int chans, int bits, <br>
					const double * bufBegin, const double * bufEnd )</b></tt>
<blockquote>[ returns void  ]
<br>
Export the sample data on the half-open (STL-style) range [bufBegin, bufEnd)
to a AIFF samples file having the specified file name or path, using the 
specified sample rate (in Hz), number of channels, and sample size (in bits).
bufEnd represents a position after the last valid position in the buffer, no 
sample is read from *bufEnd.
</blockquote>

<p><tt><b>static Export( std::ostream & s, double rate, int chans, int bits, <br>
					const double * bufBegin, const double * bufEnd )</b></tt>
<blockquote>[ returns void  ]
<br>
Export the sample data on the half-open (STL-style) range [bufBegin, bufEnd)
in the format of a AIFF samples file on the specified ostream, using the 
specified sample rate (in Hz), number of channels, and sample size (in bits).
bufEnd represents a position after the last valid position in the buffer, no 
sample is read from *bufEnd.
</blockquote>
					
<p><a href="#contents"><small>Contents</small></a>	

<a name="Analyzer">
<hr><h2>Analyzer</h2></a>
<p>
Class Analyzer represents a configuration of parameters for
performing Reassigned Bandwidth-Enhanced Additive Analysis
of sampled waveforms. This analysis process yields a collection 
of <a href="#Partial">Partials</a>, each having a trio of synchronous, non-uniformly-
sampled breakpoint envelopes representing the time-varying 
frequency, amplitude, and noisiness of a single bandwidth-
enhanced sinusoid. 
<p>
For more information about Reassigned Bandwidth-Enhanced 
Analysis and the Reassigned Bandwidth-Enhanced Additive Sound 
Model, refer to the Loris website: 
<a href="http://www.cerlsoundgroup.org/Loris/">www.cerlsoundgroup.org/Loris/</a>.
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>Analyzer( double resolutionHz )</b></tt>
<blockquote>
<br>
Construct and return a new Analyzer configured with the given	
frequency resolution (minimum instantaneous frequency	
difference between Partials). All other Analyzer parameters 	
are computed from the specified frequency resolution. 	
</blockquote>


<p><tt><b>Analyzer( double resolutionHz, double windowWidthHz )
</b></tt>
<blockquote>
<br>
Construct and return a new Analyzer configured with the given	
frequency resolution (minimum instantaneous frequency	
difference between Partials) and analysis window width
(main lobe, zero-to-zero). All other Analyzer parameters 	
are computed from the specified resolution and window width. 
</blockquote>


<p><tt><b>Analyzer( const Analyzer & other )
</b></tt>
<blockquote>
<br>
Construct and return a new Analyzer having identical
parameter configuration to another Analyzer. The list of 
collected Partials is not copied. 	
</blockquote>	

<p><tt><b>~Analyzer( void )</b></tt>
<blockquote>
<br>
Destroy this Analyzer.
</blockquote>

<h4>Configuration</h4>
<p><tt><b>operator = ( const Analyzer & rhs )
</b></tt>
<blockquote>[ returns Analyzer &  ]
<br>
Assignment operator:
change this Analyzer's parameter configuration to 
be identical to that of another Analyzer. The list of 
collected Partials is not copied or otherwise modified.
</blockquote>	

<p><tt><b> configure( double resolutionHz, double windowWidthHz )</b></tt>
<blockquote>[ returns void ]
<br>
Configure this Analyzer with the given frequency resolution 
(minimum instantaneous frequency difference between Partials)
and analysis window width (main lobe, zero-to-zero, in Hz). 
All other Analyzer parameters are (re-)computed from the 
frequency resolution and window width.
</blockquote>

<h4>Analysis</h4>
<p><tt><b>analyze( const double * bufBegin, const double * bufEnd, double srate )</b></tt>
<blockquote>[ returns void ]
<br>
Analyze a range of (mono) samples at the given sample rate 	  	
(in Hz) and append the extracted Partials to Analyzer's 
PartialList. 												
</blockquote>

<h4>Parameter Access</h4>
<p><tt><b> ampFloor( void ) const</b></tt>
<blockquote>[ returns double ]
<br>
Return the amplitude floor (lowest detected spectral amplitude),  			
in (negative) dB, for this Analyzer. 				
</blockquote>

<p><tt><b> bwRegionWidth( void ) const</b></tt>
<blockquote>[ returns double ]
<br>
Return the width (in Hz) of the Bandwidth Association regions
used by this Analyzer.<p>

This parameter is deprecated and not generally useful. It will be
removed in a future release.
</blockquote>

<p><tt><b> cropTime( void ) const </b></tt>
<blockquote>[ return double ]
<br>
Return the crop time (maximum temporal displacement of a time-
frequency data point from the time-domain center of the analysis
window, beyond which data points are considered "unreliable")
for this Analyzer.<p>

This parameter is deprecated and not generally useful. It will be
removed in a future release.

</blockquote>

<p><tt><b> freqDrift( void ) const</b></tt>
<blockquote>[ returns double ]
<br>
Return the maximum allowable frequency difference between 					
consecutive Breakpoints in a Partial envelope for this Analyzer. 				
</blockquote>

<p><tt><b> freqFloor( void ) const </b></tt>
<blockquote>[ returns double ]
<br>
Return the frequency floor (minimum instantaneous Partial  				
frequency), in Hz, for this Analyzer.
</blockquote>

<p><tt><b>freqResolution( void ) const</b></tt>
<blockquote>[ returns double ]
<br>
Return the frequency resolution (minimum instantaneous frequency  		
difference between Partials) for this Analyzer.
</blockquote>

<p><tt><b> hopTime( void ) const </b></tt>
<blockquote>[ returns double ]
<br>
Return the hop time (which corresponds approximately to the 
average density of Partial envelope Breakpoint data) for this 
Analyzer.
</blockquote>

<p><tt><b> windowWidth( void ) const</b></tt>
<blockquote>[ returns double ]
<br>
Return the frequency-domain main lobe width (measured between 
zero-crossings) of the analysis window used by this Analyzer. 				
</blockquote>

<h4>Parameter Mutation</h4>

<p><tt><b> setAmpFloor( double x ) </b></tt>
<blockquote>[ returns void ]
<br>
Set the amplitude floor (lowest detected spectral amplitude), in  			
(negative) dB, for this Analyzer. 				
</blockquote>

<p><tt><b> setBwRegionWidth( double x ) </b></tt>
<blockquote>[ returns void ]
<br>
Set the width (in Hz) of the Bandwidth Association regions
used by this Analyzer.<p>

This parameter is deprecated and not generally useful. It will be
removed in a future release.

</blockquote>

<p><tt><b> setCropTime( double x )</b></tt>
<blockquote>[ returns void ]
<br>
Set the crop time (maximum temporal displacement of a time-
frequency data point from the time-domain center of the analysis
window, beyond which data points are considered "unreliable")
for this Analyzer.<p>

This parameter is deprecated and not generally useful. It will be
removed in a future release.

</blockquote>

<p><tt><b> setFreqDrift( double x )</b></tt>
<blockquote>[ returns void ]
<br>
Set the maximum allowable frequency difference between 					
consecutive Breakpoints in a Partial envelope for this Analyzer.
</blockquote>

<p><tt><b> setFreqFloor( double x ) </b></tt>
<blockquote>[ returns void ]
<br>
Set the amplitude floor (minimum instantaneous Partial  				
frequency), in Hz, for this Analyzer.
</blockquote>

<p><tt><b> setFreqResolution( double x ) </b></tt>
<blockquote>[ returns void ]
<br>
Set the frequency resolution (minimum instantaneous frequency  		
difference between Partials) for this Analyzer. (Does not cause 	
other parameters to be recomputed.) 									
</blockquote>

<p><tt><b> setHopTime( double x )</b></tt>
<blockquote>[ returns void ]
<br>
Set the hop time (which corresponds approximately to the average
density of Partial envelope Breakpoint data) for this Analyzer.
</blockquote>

<p><tt><b> setWindowWidth( double x ) </b></tt>
<blockquote>[ returns void ]
<br>
Set the frequency-domain main lobe width (measured between 
zero-crossings) of the analysis window used by this Analyzer. 				
</blockquote>

<h4>PartialList Access</h4>
<p><tt><b> partials( void )</b></tt>
<blockquote>[ returns PartialList & ]
<br>
Return a mutable reference to this Analyzer's list of 
analyzed Partials. 
</blockquote>

<p><tt><b> partials( void ) const</b></tt>
<blockquote>[ returns const PartialList & ]
<br>
Return an immutable (const) reference to this Analyzer's 
list of analyzed Partials. 
</blockquote>

<p><a href="#contents"><small>Contents</small></a>	

<a name="Breakpoint">
<hr><h2>Breakpoint</h2></a>
<p>
Class Breakpoint represents a single breakpoint in the
Partial parameter (frequency, amplitude, bandwidth) envelope.
Instantaneous phase is also stored, but is only used at the onset of 
a partial, or when it makes a transition from zero to nonzero amplitude.
<p>
Loris Partials represent reassigned bandwidth-enhanced model components.
A Partial consists of a chain of Breakpoints describing the time-varying
frequency, amplitude, and bandwidth (noisiness) of the component.
For more information about Reassigned Bandwidth-Enhanced 
Analysis and the Reassigned Bandwidth-Enhanced Additive Sound 
Model, refer to the Loris website: 
<a href="http://www.cerlsoundgroup.org/Loris/">www.cerlsoundgroup.org/Loris/</a>.
<p>
Breakpoint is a leaf class, do not subclass.
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>Breakpoint( void )</b></tt>
<blockquote>
<br>
Construct a new Breakpoint with all parameters initialized to 0.
</blockquote>

<p><tt><b>Breakpoint( double f, double a, double b, double p = 0. )</b></tt>
<blockquote>
<br>
Construct a new Breakpoint with frequency, amplitude, and bandwidth
initialized to f, a, and b, respectively, and phase initialized to
p, if specified, or 0 otherwise.
</blockquote>

<h4>Comparison</h4>
<p><tt><b> operator == ( const Breakpoint & rhs ) const</b></tt>
<blockquote>[ returns bool ]
<br>
Comparison operator: return true if the frequency, amplitude, 
bandwidth, and phase of this Breakpoint are equal to those of
the Breakpoint rhs. Otherwise, return false.
</blockquote>

<h4>Attribute Access</h4>
<p><tt><b> amplitude( void ) const </b></tt>
<blockquote>[ returns double ]
<br>
Return the amplitude of this Breakpoint.
</blockquote>

<p><tt><b> bandwidth( void ) const </b></tt>
<blockquote>[ returns double ]
<br>
Return the bandwidth (noisiness) coefficient of this Breakpoint.
</blockquote>

<p><tt><b> frequency( void ) const</b></tt>
<blockquote>[ returns double ]
<br>
Return the frequency of this Breakpoint.
</blockquote>

<p><tt><b> phase( void ) const </b></tt>
<blockquote>[ returns double ]
<br>
Return the phase of this Breakpoint.
</blockquote>

<h4>Attribute Mutation</h4>
<p><tt><b> setAmplitude( double x )</b></tt>
<blockquote>[ returns void ]
<br>
Set the amplitude of this Breakpoint.
</blockquote>

<p><tt><b> setBandwidth( double x )</b></tt>
<blockquote>[ returns void ]
<br>
Set the bandwidth (noisiness) coefficient of this Breakpoint.
</blockquote>

<p><tt><b> setFrequency( double x )</b></tt>
<blockquote>[ returns void ]
<br>
Set the frequency of this Breakpoint.
</blockquote>

<p><tt><b> setPhase( double x ) </b></tt>
<blockquote>[ returns void ]
<br>
Set the phase of this Breakpoint.
</blockquote>

				
<p><a href="#contents"><small>Contents</small></a>	

<a name="BreakpointEnvelope">
<hr><h2>BreakpointEnvelope</h2></a>
<p>
A BreakpointEnvelope represents a linear segment breakpoint 
function with infinite extension at each end (that is, evalutaing 
the envelope past either end of the breakpoint function yields the 
value at the nearest end point).
<p>
BreakpointEnvelope implements the Envelope interface, described
by the abstract class <a href="#Envelope">Envelope</a>. 
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>BreakpointEnvelope( void )</b></tt>
<blockquote>
<br>
Construct and return a new BreakpointEnvelope having no 
breakpoints (and an implicit value of 0. everywhere).
</blockquote>

<p><tt><b>BreakpointEnvelope( double initialValue )</b></tt>
<blockquote>
<br>
Construct and return a new BreakpointEnvelope having a 
single breakpoint at 0. (and an implicit value everywhere)
of initialValue.
</blockquote>		

<p><tt><b>BreakpointEnvelope( const BreakpointEnvelope & other )</b></tt>
<blockquote>
<br>
Construct and return a new BreakpointEnvelope that is
a copy of this BreapointEnvelope (has the same value
as this BreakpointEnvelope everywhere).			
</blockquote>

<p><tt><b>~BreakpointEnvelope( void )</b></tt>
<blockquote>
<br>
Destroy this BreakpointEnvelope. 								
</blockquote>


<h4>Envelope Interface</h4>
<p><tt><b> clone( void ) const</b></tt>
<blockquote>[ returns BreakpointEnvelope *  ]
<br>
Return an exact copy of this BreakpointEnvelope
(following the Prototype pattern).
</blockquote>


<p><tt><b> valueAt( double x ) const</b></tt>
<blockquote>[ returns double  ]
<br>
Return the linearly-interpolated value of this BreakpointEnvelope at 
the specified time.							
</blockquote>


<h4>Envelope Composition</h4>
<p><tt><b> insertBreakpoint( double time, double value )</b></tt>
<blockquote>[ returns void  ]
<br>
Insert a breakpoint representing the specified (time, value) 
pair into this BreakpointEnvelope. If there is already a 
breakpoint at the specified time, it will be replaced with 
the new breakpoint.
</blockquote>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="BreakpointUtils">
<hr><h2>BreakpointUtils</h2></a>
<p>
BreakpointUtils represents a collection of utility functions and 
function objects for applying STL searching and sorting algorithms 
to collections of Loris Breakpoints. BreakpointUtils is a namespace
within the Loris namespace, unless compiled with NO_LORIS_NAMESPACE,
in which case it is a class (having only static members and private
constructors).
<p>
<h4>Free Functions</h4>
<p><tt><b> addNoiseEnergy( Breakpoint & bp, double enoise )</b></tt>
<blockquote>[ returns void  ]
<br>
Add noise (bandwidth) energy to a Breakpoint by computing new 
amplitude and bandwidth values. enoise may be negative, but 
noise energy cannot be removed (negative energy added) in excess 
of the current noise energy.
</blockquote>

<h4>Predicates</h4>
	<p><tt><b>struct frequency_between : 
		public std::unary_function&lt; const Breakpoint, bool &gt;</b></tt>
<blockquote>[ returns bool  ]
<br>
Predicate functor returning true if its Breakpoint argument 
has frequency between specified bounds, and false otherwise, constructed
<pre>
Loris::BreakpointUtils::frequency_between( double lowerbound, double upperbound )
</pre>
</blockquote>

<h4>Comparitors</h4>

<p><tt><b>struct less_frequency : 
public std::binary_function&lt; const Breakpoint, const Breakpoint, bool &gt;
</b></tt>
<blockquote>[ returns bool  ]
<br>
Comparitor (binary) functor returning true if its first Breakpoint
argument has frequency less than that of its second Breakpoint argument,
and false otherwise.
</blockquote>	


<p><tt><b>struct greater_amplitude : 
public std::binary_function&lt; const Breakpoint, const Breakpoint, bool &gt;
</b></tt>
<blockquote>[ returns bool  ]
<br>
Comparitor (binary) functor returning true if its first Breakpoint
argument has amplitude greater than that of its second Breakpoint argument,
and false otherwise.
</blockquote>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Channelizer">
<hr><h2>Channelizer</h2></a>
<p>
Class Channelizer represents an algorithm for automatic labeling of a
collection (STL range) of Partials. Partials must be labeled in
preparation for morphing (see <a href="#Morpher">Morpher</a>) to
establish correspondences between Partials in the morph source and
target sounds.
<p>
Channelized partials are labeled according to their adherence to a
harmonic frequency structure with a time-varying fundamental frequency.
The frequency spectrum is partitioned into non-overlapping channels
having time-varying center frequencies that are harmonic (integer)
multiples of a specified reference frequency envelope, and each channel
is identified by a unique label equal to its harmonic number. Each
Partial is assigned the label corresponding to the channel containing
the greatest portion of its (the Partial's) energy.
<p>
A reference frequency Envelope for channelization and the channel number
to which it corresponds (1 for an Envelope that tracks the Partial at
the fundamental frequency) must be specified. The reference Envelope can
be constructed explcitly, point by point (using, for example, the <a
href="#BreakpointEnvelope">BreakpointEnvelope</a> class), or constructed
automatically using the <a
href="#FrequencyReference">FrequencyReference</a> class.
<p>
Channelizer is a leaf class, do not subclass. 
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>Channelizer( const Envelope & refChanFreq, int refChanLabel )
</b></tt>
<blockquote>
<br>
Construct a new Channelizer using the specified reference frequency
Envelope to represent the channel numbered refChanLabel.
</blockquote>	

<p><tt><b>Channelizer( const Channelizer & other )
</b></tt>
<blockquote>
<br>
Construct a new Channelizer that is an exact copy of this Channelizer
(uses the same reference frequency Envelope to represent the same 
channel).
</blockquote>	

<p><tt><b>~Channelizer( void )
</b></tt>
<blockquote>
<br>
Destroy this Channelizer.
</blockquote>	

<p><tt><b> operator=( const Channelizer & rhs )
</b></tt>
<blockquote>[ returns Channelizer &  ]
<br>
Assignment operator: make this Channelizer an exact copy of rhs 
(use the same set of frequency channels).
</blockquote>	


<h4>Channelizing</h4>
<p><tt><b> channelize( PartialList::iterator begin, PartialList::iterator end ) const
</b></tt>
<blockquote>[ returns void  ]
<br>
Assign each Partial in the specified half-open (STL-style) range
the label corresponding to the frequency channel containing the
greatest portion of its (the Partial's) energy.
</blockquote>	


<p><tt><b> operator() ( PartialList::iterator begin, PartialList::iterator end ) const
</b></tt>
<blockquote>[ returns void  ]
<br>
Function call operator: same as channelize().
</blockquote>	
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Dilator">
<hr><h2>Dilator</h2></a>
<p>
Class Dilator represents an algorithm for for non-uniformly expanding
and contracting the Partial parameter envelopes according to the initial
and target (desired) times of temporal features.
<p>
It is frequently necessary to redistribute temporal events in this way
in preparation for a sound morph. For example, when morphing instrument
tones, it is common to align the attack, sustain, and release portions
of the source sounds by dilating or contracting those temporal regions.
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>Dilator( void )
</b></tt>
<blockquote>
<br>
Construct a new Dilator with no time points.
</blockquote>	

<p><tt><b>template&lt;typename Iter1, typename Iter2&gt;<br>
Dilator( Iter1 ibegin, Iter1 iend, Iter2 tbegin )
</b></tt>
<blockquote>
<br>
Construct a new Dilator using a range of initial time points
and a range of target (desired) time points. The client must
ensure that the target range has at least as many elements as
the initial range.
<p>
If compiled with NO_TEMPLATE_MEMBERS defined, this constructor
is defined:
<pre>
Dilator( const double * ibegin, const double * iend, const double * tbegin )
</pre>
</blockquote>
	
<p><tt><b>~Dilator( void )
</b></tt>
<blockquote>
<br>
Destroy this Dilator.
</blockquote>	
	
<p><tt><b> insert( double i, double t )
</b></tt>
<blockquote>[ returns void  ]
<br>
Specify a pair of initial and target time points to be used
by this Dilator, corresponding, for example, to the initial
and desired time of a particular temporal feature in an
analyzed sound.
</blockquote>	

<h4>Dilation</h4>
<p><tt><b> dilate( Partial & p )
</b></tt>
<blockquote>[ returns void  ]
<br>
Non-uniformly expand and contract the parameter envelopes of the
specified Partial according to this Dilator's stored initial and 
target (desired) times.
</blockquote>	

<p><tt><b> operator() ( Partial & p )
</b></tt>
<blockquote>[ returns void  ]
<br>
Function call operator: same as dilate( Partial & p ).
</blockquote>	

		
<p><tt><b>template&lt;typename Iter&gt;<br>
 dilate( Iter dilate_begin, Iter dilate_end )
</b></tt>
<blockquote>[ returns void  ]
<br>
Non-uniformly expand and contract the parameter envelopes of the each
Partial in the specified half-open range according to this Dilator's
stored initial and target (desired) times.
<p>
If compiled with NO_TEMPLATE_MEMBERS defined, this member
is defined:
<pre>
dilate( PartialList::iterator dilate_begin, PartialList::iterator dilate_end  )
</pre>
</blockquote>	

<p><tt><b>template&lt;typename Iter&gt;<br>
 operator() ( Iter dilate_begin, Iter dilate_end  )
</b></tt>
<blockquote>[ returns void  ]
<br>
Function call operator: same as dilate( Iter dilate_begin, Iter dilate_end )
<p>
If compiled with NO_TEMPLATE_MEMBERS defined, this member
is defined:
<pre>
operator() ( PartialList::iterator dilate_begin, PartialList::iterator dilate_end )
</pre>
</blockquote>	

<p><tt><b> warpTime( double currentTime )</b></tt>
<blockquote>[ returns double  ]
<br>
Return the dilated time value corresponding to the specified 
initial time.
</blockquote>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Distiller">
<hr><h2>Distiller</h2></a>
<p>
Class Distiller represents an algorithm for "distilling" a group of
Partials that logically represent a single component into a single
Partial.
<p>
The sound morphing algorithm in Loris requires that Partials in a
given source be labeled uniquely, that is, no two Partials can have
the same label. The Distiller enforces this condition. All Partials
identified with a particular frequency channel (see <a
href="#Channelizer">Channelizer</a>), and, therefore, having a common
label, are distilled into a single Partial, leaving at most a single
Partial per frequency channel and label. Channels that contain no
Partials are not represented in the distilled data. Partials that are
not labeled, that is, Partials having label 0, are unaffected by the
distillation process. All unlabeled Partials remain unlabeled and
unmodified in the distilled partial set.
<p>
Distillation modifies the Partial container (a PartialList). All 
Partials in the distilled range having a common label are replaced
by a single Partial in the distillation process.
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>Distiller( void )</b></tt>
<blockquote>
<br>
Construct a new Distiller.
</blockquote>

<p><tt><b>~Distiller( void )</b></tt>
<blockquote>
<br>
Destroy this Distiller.
</blockquote>
	
<h4>Distillation</h4>

<p><tt><b> distill( PartialList & container, PartialList::iterator dist_begin, 
PartialList::iterator dist_end )
</b></tt>
<blockquote>[ returns void  ]
<br>
Distill Partial on the specified half-open (STL-style) range in the
specified container (PartialList). 
</blockquote>	

<p><tt><b> distill( PartialList & container )</b></tt>
<blockquote>[ returns void  ]
<br>
Distill all Partials in the specified container (PartialList).
</blockquote>

<p><tt><b> operator() ( PartialList & container, PartialList::iterator dist_begin, 
PartialList::iterator dist_end )
</b></tt>
<blockquote>[ returns void  ]
<br>
Function call operator: same as distill( PartialList & container, PartialList::iterator dist_begin, 
PartialList::iterator dist_end ). 
</blockquote>
	
<p><a href="#contents"><small>Contents</small></a>	

<a name="Envelope">
<hr><h2>Envelope</h2></a>
<p>
Class Envelope is an abstract base class, specifying interface for
prototypable (clonable) objects representing generic, real-valued
(double) functions of one real-valued (double) time argument. Derived
classes (like <a href="#BreakpointEnvelope">BreakpointEnvelope</a>)
must implement valueAt() and clone(), the latter to support the
Prototype pattern. Clients of Envelope, like <a
href="#Morpher">Morpher</a> and <a href="#Distiller">Distiller</a>,
can use prototype Envelopes to make their own private Envelopes.
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>~Envelope( void )</b></tt>
<blockquote>
<br>
Destroy this Envelope (virtual to allow subclassing). 								
</blockquote>


<h4>Envelope Interface</h4>
<p><tt><b> clone( void ) const</b></tt>
<blockquote>[ returns Envelope *  ]
<br>
Return an exact copy of this Envelope
(following the Prototype pattern). (abstract)
</blockquote>


<p><tt><b> valueAt( double x ) const</b></tt>
<blockquote>[ returns double  ]
<br>
Return the value of this Envelope at the specified time.	
(abstract)						
</blockquote>

				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Exception">
<hr><h2>Exception</h2></a>
<p>
Class Exception is a generic exception class for reporting exceptional 
circumstances in Loris. Exception is derived from std:exception, 
and is the base for a hierarchy of derived exception classes
in Loris:
<ul>
	<li>class Exception</li>
	<ul>
		<li>class AssertionFailure (thrown by the Assert(invariant) macro)</li>
		<li>class IndexOutOfBounds</li>
		<li>class FileIOException</li>
		<li>class InvalidObject</li>
		<ul>
			<li>class InvalidIterator</li>
			<li>class InvalidArgument</li>
			<li>class InvalidPartial (defined in Partial.h)</li>
		</ul>
	</ul>
</ul>
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>Exception( const std::string & desc, const std::string & where = "" )</b></tt>
<blockquote>
<br>
Construct a new Exception with the specified description and, optionally
a string identifying the location at which the exception as thrown. The
Throw( Exception_Class, description_string ) macro generates a location
string automatically using __FILE__ and __LINE__.
</blockquote>
    
<p><tt><b> ~Exception( void )</b></tt>
<blockquote>
<br>
Destroy this Exception.
</blockquote>

<h4>std::exception Interface</h4>
<p><tt><b> what( void ) const</b></tt>
<blockquote>[ returns const char *  ]
<br>
Return a description of this Exception in the form of a
C-style string (char pointer).
</blockquote>
	
<h4>Description String Access</h4>
<p><tt><b> append( const std::string & str )</b></tt>
<blockquote>[ returns Exception &  ]
<br>
Append the specified string to this Exception's description,
and return a reference to this Exception.
</blockquote>

<p><tt><b> str( void ) const</b></tt>
<blockquote>[ returns const std::string &  ]
<br>
Return a refernce to this Exception's description string.
</blockquote>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="FrequencyReference">
<hr><h2>FrequencyReference</h2></a>
<p>
Class FrequencyReference represents a reference frequency envelope
derived from the longest Partial found in a given range of Partials,
and in a specified (average) frequency range. This reference envelope
can be used for channelizing the Partials in preparation for morphing
(see <a href="#Channelizer">Channelizer</a>).
<p>
FrequencyReference implements the Envelope interface (see
<a href="#Envelope">Envelope</a>).
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>FrequencyReference( PartialList::const_iterator begin, 
PartialList::const_iterator end, 
double minFreq, double maxFreq, long numSamps )
</b></tt>
<blockquote>
<br>
Construct a new FrequencyReference derived from the longest Partial
in the specified half-open (STL-style) range of Partials that lies
within the speficied average frequency range. Sample that longest
Partial at numSamps points to construct the reference envelope.
</blockquote>						
						
<p><tt><b>FrequencyReference( PartialList::const_iterator begin, 
PartialList::const_iterator end, 
double minFreq, double maxFreq )
</b></tt>
<blockquote>
<br>
Construct a new FrequencyReference derived from the longest Partial
in the specified half-open (STL-style) range of Partials that lies
within the speficied average frequency range. Sample that longest
Partial at every Breakpoint to construct the reference envelope.
</blockquote>		
				
<p><tt><b>FrequencyReference( const FrequencyReference & other )</b></tt>
<blockquote>
<br>
Construct a new FrequencyReference that is an exact copy of the
specified FrequencyReference.
</blockquote>

<p><tt><b>~FrequencyReference()</b></tt>
<blockquote>
<br>
Destroy this FrequencyReference.
</blockquote>

<p><tt><b> operator= ( const FrequencyReference & other )</b></tt>
<blockquote>[ returns FrequencyReference &  ]
<br>
Assignment operator: make this FrequencyReference an exact copy 
of the specified FrequencyReference.
</blockquote>

<h4>Conversion to BreakpointEnvelope</h4>
<p><tt><b> envelope( void ) const</b></tt>
<blockquote>[ returns BreakpointEnvelope  ]
<br>
Return a BreakpointEnvelope that evaluates indentically to this
FrequencyReference at all time.
</blockquote>

<h4>Envelope Interface</h4>
<p><tt><b> clone( void ) const</b></tt>
<blockquote>[ returns FrequencyReference *  ]
<br>
Return an exact copy of this FrequencyReference (following the
Prototype pattern).
</blockquote>
	
<p><tt><b> valueAt( double x ) const</b></tt>
<blockquote>[ returns double  ]
<br>
Return the frequency value (in Hz) of this FrequencyReference at the
specified time.
</blockquote>

				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Morpher">
<hr><h2>Morpher</h2></a>
<p>
Class Morpher performs sound morphing and Partial parameter
envelope interpolation according to a trio of frequency, amplitude,
and bandwidth morphing functions, described by Envelopes.
Sound morphing is achieved by interpolating the time-varying 
frequencies, amplitudes, and bandwidths of corresponding partials 
obtained from reassigned bandwidth-enhanced analysis of the source 
and target sounds. Partial correspondences may be established by 
labeling, using instances of the Channelizer and Distiller classes.
<p>
The Morpher collects morphed Partials in a PartialList, that is
accessible to clients.
<p>
For more information about sound morphing using 
the Reassigned Bandwidth-Enhanced Additive Sound 
Model, refer to the Loris website: 
<a href="http://www.cerlsoundgroup.org/Loris/">www.cerlsoundgroup.org/Loris/</a>.
<p>
Morpher is a leaf class, do not subclass.
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>Morpher( const Envelope & f )
</b></tt>
<blockquote>
<br>
Construct a new Morpher using the same morphing envelope for 
frequency, amplitude, and bandwidth (noisiness).
</blockquote>	
<p><tt><b>Morpher( const Envelope & ff, const Envelope & af, const Envelope & bwf )
</b></tt>
<blockquote>
<br>
Construct a new Morpher using the specified morphing envelopes for
frequency, amplitude, and bandwidth (noisiness).
</blockquote>	

<p><tt><b>~Morpher( void )
</b></tt>
<blockquote>
<br>
Destroy this Morpher.
</blockquote>	

	
<h4>Morphed Parameter Computation</h4>

<p><tt><b> morphParameters( const Breakpoint & srcBkpt, const Breakpoint & tgtBkpt, 
					  double time, Breakpoint & retBkpt )
</b></tt>
<blockquote>[ returns void  ]
<br>
Morph Breakpoint to Breakpoint:
compute morphed parameter values at the specified time, using
the source and target Breakpoints (assumed to correspond exactly 
to the specified time). Return the morphed Parameters in the
specified return Breakpoint.
</blockquote>	

					  

<p><tt><b> morphParameters( const Breakpoint & srcBkpt, const Partial & tgtPartial, 
					  double time, Breakpoint & retBkpt )
</b></tt>
<blockquote>[ returns void  ]
<br>
Morph Breakpoint to Partial:
compute morphed parameter values at the specified time, using
the source Breakpoint (assumed to correspond exactly to the
specified time) and the target Partial (whose parameters are
examined at the specified time). Return the morphed Parameters 
in the specified return Breakpoint.
<p>
The target Partial may be a dummy Partial (no Breakpoints).
</blockquote>	

					  

<p><tt><b> morphParameters( const Partial & srcPartial, const Breakpoint & tgtBkpt, 
					  double time, Breakpoint & retBkpt )
</b></tt>
<blockquote>[ returns void  ]
<br>
Morph Partial to Breakpoint:
compute morphed parameter values at the specified time, using
the source Partial (whose parameters are examined at the specified 
time) and the target Breakpoint (assumed to correspond exactly to 
the specified time). Return the morphed Parameters in the
specified return Breakpoint.
<p>
The source Partial may be a dummy Partial (no Breakpoints).
</blockquote>	

					  

<p><tt><b> morphParameters( const Partial & srcPartial, const Partial & tgtPartial, 
					  double time, Breakpoint & retBkpt )
</b></tt>
<blockquote>[ returns void  ]
<br>
Morph Partial to Partial:
compute morphed parameter values at the specified time, using
the source  and target Partials, both of whose parameters are 
examined at the specified time. Return the morphed Parameters 
in the specified return Breakpoint.
<p>
Either (or neither) the source or target Partial may be a dummy 
Partial (no Breakpoints), but not both.
</blockquote>	



<h4>Partial morphing</h4>

<p><tt><b> morphPartial( const Partial & src, const Partial & tgt, int assignLabel )
</b></tt>
<blockquote>[ returns Partial &  ]
<br>
Morph a pair of Partials to yield a new morphed Partial. 
Dummy Partials (having no Breakpoints) don't contribute to the
morph, except to cause their opposite to fade out. 
Either (or neither) the source or target Partial may be a dummy 
Partial (no Breakpoints), but not both. The morphed
Partial has Breakpoints at times corresponding to every Breakpoint 
in both source Partials. The morphed Partial is appended
to the Morpher's PartialList, and a reference to it is returned.
The new morphed Partial is assigned the specified label.
</blockquote>	



<p><tt><b> morph( PartialList::const_iterator beginSrc, 
			PartialList::const_iterator endSrc,
			PartialList::const_iterator beginTgt, 
			PartialList::const_iterator endTgt )
</b></tt>
<blockquote>[ returns void  ]
<br>
Morph two sounds (collections of Partials labeled to indicate
correspondences) into a single labeled collection of Partials.
Unlabeled Partials (having label 0) are crossfaded. The morphed
and crossfaded Partials are stored in the Morpher's PartialList.
<p>
The Partials in the first range are treated as components of the 
source sound, corresponding to a morph function value of 0, and  
those in the second are treated as components of the target sound, 
corresponding to a morph function value of 1.
</blockquote>	



<p><tt><b> crossfade( PartialList::const_iterator beginSrc, 
				PartialList::const_iterator endSrc,
				PartialList::const_iterator beginTgt, 
				PartialList::const_iterator endTgt )
</b></tt>
<blockquote>[ returns void  ]
<br>
Crossfade Partials with no correspondences.
<p>
Unlabeled Partials (having label 0) are considered to 
have no correspondences, so they are just faded out, and not 
actually morphed. This is the same as morphing each with an 
empty dummy Partial (having no Breakpoints). 
<p>
The Partials in the first range are treated as components of the 
source sound, corresponding to a morph function value of 0, and  
those in the second are treated as components of the target sound, 
corresponding to a morph function value of 1.
<p>
The crossfaded Partials are stored in the Morpher's PartialList.
</blockquote>	


<h4>Morphing Function Access/Mutation</h4>

<p><tt><b> setFrequencyFunction( const Envelope & f )
</b></tt>
<blockquote>[ returns void  ]
<br>
Assign a new frequency morphing envelope to this Morpher.
</blockquote>	

<p><tt><b> setAmplitudeFunction( const Envelope & f )
</b></tt>
<blockquote>[ returns void  ]
<br>
Assign a new amplitude morphing envelope to this Morpher.
</blockquote>	

<p><tt><b> setBandwidthFunction( const Envelope & f )
</b></tt>
<blockquote>[ returns void  ]
<br>
Assign a new bandwidth morphing envelope to this Morpher.
</blockquote>	


<p><tt><b> frequencyFunction( void ) const
</b></tt>
<blockquote>[ returns const Envelope &  ]
<br>
Return a reference to this Morpher's frequency morphing envelope.
</blockquote>	

<p><tt><b> amplitudeFunction( void ) const
</b></tt>
<blockquote>[ returns const Envelope &  ]
<br>
Return a reference to this Morpher's amplitude morphing envelope.
</blockquote>	

<p><tt><b> bandwidthFunction( void ) const
</b></tt>
<blockquote>[ returns const Envelope &  ]
<br>
Return a reference to this Morpher's bandwidth morphing envelope.
</blockquote>	

	
<h4>PartialList access</h4>

<p><tt><b> partials( void )
</b></tt>
<blockquote>[ returns PartialList &  ]
<br>
Return a reference to this Morpher's list of morphed Partials.
</blockquote>	


<p><tt><b> partials( void ) const
</b></tt>
<blockquote>[ returns const PartialList &  ]
<br>
Return a const reference to this Morpher's list of morphed Partials.
</blockquote>	
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Notifier">
<hr><h2>Notifier</h2></a>
<p>
A pair of dedicated streams, <code>notifier</code> and
<code>debugger</code>, are used for notification throughout the Loris
class library. These streams are used like <code>cout</code> or
<code>cerr</code>, but they buffer their contents until a newline is
receieved. Then they post their entire contents to a notification
handler. The default handler just prints to stderr, but other handlers
may be dynamically specified using setNotifierHandler() and
setDebuggerHandler().
<p>
<code>debugger</code> is enabled only when compiled with the
preprocessor macro Debug_Loris defined. It cannot be enabled using
setDebuggerHandler() if Debug_Loris is undefined.When Debug_Loris
is not defined, characters streamed onto debugger are never posted
nor are they otherwise accessible.
<p>
Notifier.h may be included in c files. The stream declarations
are omitted, but the notification handler routines are accessible.
<p>

<p><tt><b>static std::ostream & notifier
</b></tt>
<blockquote>
<br>
This stream is used throughout Loris (and may be used by clients)
to provide user feedback. Characters streamed onto notifier are
buffered until a newline is received, and then the entire contents
of the stream are flushed to the current notification handler (stderr,
by default).
</blockquote>	

<p><tt><b>static std::ostream & debugger
</b></tt>
<blockquote>
<br>
This stream is used throughout Loris (and may be used by clients)
to provide debugging information. Characters streamed onto debugger are
buffered until a newline is received, and then the entire contents
of the stream are flushed to the current debugger handler (stderr,
by default).
<p>
<code>debugger</code> is enabled only when compiled with the
preprocessor macro Debug_Loris defined. It cannot be enabled using
setDebuggerHandler() if Debug_Loris is undefined. When Debug_Loris
is not defined, characters streamed onto debugger are never posted
nor are they otherwise accessible.
</blockquote>	


<p><tt><b>typedef void(*NotificationHandler)(const char * s); <br>
setNotifierHandler( NotificationHandler fn )
</b></tt>
<blockquote>[ returns NotificationHandler  ]
<br>
Specify a new handling procedure for posting user feedback, and return
the current handler. 
</blockquote>	


<p><tt><b> setDebuggerHandler( NotificationHandler fn )
</b></tt>
<blockquote>[ returns NotificationHandler  ]
<br>
Specify a new handling procedure for posting debugging information, and return
the current handler. This has no effect unless compiled with the Debug_Loris
preprocessor macro defined.
</blockquote>	

<p><a href="#contents"><small>Contents</small></a>	

<a name="Oscillator">
<hr><h2>Oscillator</h2></a>
<p>
Class Oscillator represents the state of a single bandwidth-enhanced
sinusoidal oscillator used for synthesizing sounds from Reassigned
Bandwidth-Enhanced analysis data. Oscillator encapsulates the oscillator
state, including the instan- taneous radian frequency (radians per
sample), amplitude, bandwidth coefficient, and phase, and a filter
object used to generate the bandlimited stochastic modulator. Class <a
href="#Synthesizer">Synthesizer</a> uses an instance of Oscillator to
synthesize bandwidth-enhanced Partials.
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>

<p><tt><b>Oscillator( double radf, double a, double bw, double ph )
</b></tt>
<blockquote>
<br>
Construct a new Oscillator with the initial state parameters 
(radian frequencym amplitude, bandwidth coefficient, and phase)
as specified.
</blockquote>	

<p><tt><b>Oscillator( void )
</b></tt>
<blockquote>
<br>
Construct a new Oscillator with all state parameters initialized
to 0.
</blockquote>	

<p><tt><b>Oscillator( const Oscillator & other )
</b></tt>
<blockquote>
<br>
Construct a new Oscillator that has the same state paramters
as another Oscillator. The filter used by the new Oscillator
will have the same coefficients and response as the other
Oscillator, but the state of the filter delay lines is not 
copied.
</blockquote>	

<p><tt><b>~Oscillator( void )
</b></tt>
<blockquote>
<br>
Destroy this Oscillator.
</blockquote>	

		
<p><tt><b> operator= ( const Oscillator & other )
</b></tt>
<blockquote>[ returns Oscillator &  ]
<br>
Assignment operator: make this Oscillator an exact copy of
another Oscillator. The filter used by this Oscillator
will have the same coefficients and response as the other
Oscillator, but the state of the filter delay lines is not 
copied.
</blockquote>	


<h4>State Access</h4>
<p><tt><b> amplitude( void ) const
</b></tt>
<blockquote>[ returns double  ]
<br>
Return the current instantaneous amplitude of this Oscillator.
</blockquote>	

<p><tt><b> bandwidth( void ) const
</b></tt>
<blockquote>[ returns double  ]
<br>
Return the current instantaneous bandwidth coefficient of this
Oscillator.
</blockquote>	

<p><tt><b> phase( void ) const
</b></tt>
<blockquote>[ returns double  ]
<br>
Return the current instantaneous phase of this Oscillator.
</blockquote>	

<p><tt><b> radianFreq( void ) const
</b></tt>
<blockquote>[ returns double  ]
<br>
Return the current instantaneous frequency (in radians per sample)
of this Oscillator.
</blockquote>	


<h4>State Mutation</h4>
<p><tt><b> setAmplitude( double x )
</b></tt>
<blockquote>[ returns void  ]
<br>
Set the instantaneous amplitude of this Oscillator.
</blockquote>	

<p><tt><b> setBandwidth( double x )
</b></tt>
<blockquote>[ returns void  ]
<br>
Set the instantaneous bandwidth coefficient of this
Oscillator.

</blockquote>	

<p><tt><b> setPhase( double x )
</b></tt>
<blockquote>[ returns void  ]
<br>
Set the instantaneous phase of this Oscillator.
</blockquote>	

<p><tt><b> setRadianFreq( double x )
</b></tt>
<blockquote>[ returns void  ]
<br>
Set the instantaneous frequency (in radians per sample)
of this Oscillator.
</blockquote>	


<h4>Sample Generation</h4>
<p><tt><b> generateSamples( double * begin, double * end,
double targetFreq, double targetAmp, double targetBw )
</b></tt>
<blockquote>[ returns void  ]
<br>
Accumulate bandwidth-enhanced sinusoidal samples modulating the
oscillator state from its current values of radian frequency, amplitude,
and bandwidth to the specified target values. Accumulate samples into
the half-open (STL-style) range of doubles, starting at begin, and
ending before end (no sample is accumulated at end). The caller must
insure that the indices are valid. Target frequency and bandwidth are
checked to prevent aliasing and bogus bandwidth enhancement.
</blockquote>	
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Partial">
<hr><h2>Partial</h2></a>
<p>
An instance of class Partial represents a single component in the
reassigned bandwidth-enhanced additive model. A Partial consists of a
chain of <a href="#Breakpoint">Breakpoints</a> describing the
time-varying frequency, amplitude, and bandwidth (or noisiness)
envelopes of the component, and a 4-byte label. The <a
href="#Breakpoint">Breakpoints</a> are non-uniformly distributed in time.
For more information about Reassigned Bandwidth-Enhanced Analysis and
the Reassigned Bandwidth-Enhanced Additive Sound Model, refer to the
Loris website: <a
href="http://www.cerlsoundgroup.org/Loris/">www.cerlsoundgroup.org/Loris/</a>.
<p>
The constituent time-tagged <a href="#Breakpoint">Breakpoints</a> are
accessible through <code>Partial:iterator</code> and
<code>Partial::const_iterator</code> interfaces, which are typedefs for
PartialIterator and PartialConstIterator, respectively. These iterator
classes implement the interface for bidirectional iterators in the STL,
including pre and post-increment and decrement, and dereferencing.
Dereferencing a PartialIterator or PartialConstIterator yields a
reference to a Breakpoint. Additionally, these iterator classes have
<code>breakpoint()</code> and <code>time()</code> members, returning the
<a href="#Breakpoint">Breakpoint</a> (by reference) at the
current iterator position and the time (by value) corresponding to that
<a href="#Breakpoint">Breakpoint</a>.
<p>
Partial is a leaf class, do not subclass.
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>Partial( void )
</b></tt>
<blockquote>
<br>
Retun a new empty (no Breakpoints) Partial.
</blockquote>	

<p><tt><b>Partial( const Partial & other )
</b></tt>
<blockquote>
<br>
Return a new Partial that is an exact copy (has an identical set
of Breakpoints, at identical times, and the same label) of another 
Partial.
</blockquote>	

<p><tt><b>~Partial( void )
</b></tt>
<blockquote>
<br>
Destroy this Partial.
</blockquote>	

<h4>Comparison</h4>
<p><tt><b> operator== ( const Partial & rhs ) const
</b></tt>
<blockquote>[ returns bool  ]
<br>
Equality operator: return true if this Partial has an identical
parameter envelope (identical Breakpoints at identical times) and the
same label as the Partial rhs, otherwise return false.
</blockquote>	

<h4>Access</h4>
<p><tt><b> duration( void ) const
</b></tt>
<blockquote>[ returns double  ]
<br>
Return the duration (in seconds) spanned by the Breakpoints in this Partial.
Note that the synthesized onset time will differ, depending on the fade
time used to synthesize this Partial (see class <a
href="#Synthesizer">Synthesizer</a>).
</blockquote>	

<p><tt><b> endTime( void ) const
</b></tt>
<blockquote>[ returns double  ]
<br>
Return the time (in seconds) of the last Breakpoint in this Partial.
Note that the synthesized onset time will differ, depending on the fade
time used to synthesize this Partial (see class <a
href="#Synthesizer">Synthesizer</a>).
</blockquote>	

<p><tt><b> initialPhase( void ) const
</b></tt>
<blockquote>[ returns double  ]
<br>
Return the phase (in radians) of this Partial at its start time (the
phase of the first Breakpoint). Note that the initial synthesized phase
will differ, depending on the fade time used to synthesize this Partial
(see class <a href="#Synthesizer">Synthesizer</a>).
</blockquote>

<p><tt><b> label( void ) const
</b></tt>
<blockquote>[ returns int  ]
<br>
Return the 32-bit label for this Partial as an integer.
</blockquote>	

<p><tt><b> numBreakpoints( void ) const 
</b></tt>
<blockquote>[ returns long  ]
<br>
Return the number of Breakpoints in this Partial.
</blockquote>	

<p><tt><b> startTime( void ) const
</b></tt>
<blockquote>[ returns double  ]
<br>
Return the time (in seconds) of the first Breakpoint in this Partial.
Note that the synthesized onset time will differ, depending on the fade
time used to synthesize this Partial (see class <a
href="#Synthesizer">Synthesizer</a>).
</blockquote>	

<h4>Mutation</h4>
<p><tt><b> setLabel( int l )
</b></tt>
<blockquote>[ returns void  ]
<br>
Set the label for this Partial to the specified 32-bit value.
</blockquote>	

	
<h4>Iterator Access</h4>	
<p><tt><b> begin( void )
</b></tt>
<blockquote>[ returns PartialIterator  ]
<br>
Return a PartialIterator refering to the position of the first
Breakpoint in this Partial's envelope.
<p>
For const Partials, returns a PartialConstIterator.
</blockquote>	


<p><tt><b> end( void )
</b></tt>
<blockquote>[ returns PartialIterator  ]
<br>
Return a PartialIterator refering to the position past the last Breakpoint in
this Partial's envelope. The iterator returned by end() (like the
iterator returned by the end() member of any STL container) does not
refer to a valid Breakpoint.
<p>
For const Partials, returns a PartialConstIterator.
</blockquote>	


<p><tt><b> erase( PartialIterator & pos )
</b></tt>
<blockquote>[ returns void  ]
<br>
Breakpoint removal: erase the Breakpoint at the position of the given
PartialIterator (invalidating the PartialIterator).
</blockquote>	

<p><tt><b> findAfter( double time ) 
</b></tt>
<blockquote>[ returns PartialIterator  ]
<br>
Return a PartialIterator refering to the insertion position for a
Breakpoint at the specified time (that is, the position of the first
Breakpoint at a time later than the specified time).
<p>
For const Partials, returns a PartialConstIterator.
</blockquote>	

<p><tt><b> findNearest( double time )
</b></tt>
<blockquote>[ returns PartialIterator  ]
<br>
Return a PartialIterator refering to the position of the
Breakpoint in this Partial nearest the specified time.
<p>
For const Partials, returns a PartialConstIterator.
</blockquote>	

	
<p><tt><b> insert( double time, const Breakpoint & bp )
</b></tt>
<blockquote>[ returns PartialIterator  ]
<br>
Breakpoint insertion: insert a copy of the specified Breakpoint in the
parameter envelope at time (seconds), and return a PartialIterator
refering to the position of the inserted Breakpoint.
</blockquote>	

	
<h4>Parameter Interpolation/Extrapolation</h4>

<p><tt><b> amplitudeAt( double time ) const
</b></tt>
<blockquote>[ returns double  ]
<br>
Return the interpolated amplitude of this Partial at the specified time.
At times beyond the ends of the Partial, return zero. Throw an
InvalidPartial exception if this Partial has no Breakpoints.
</blockquote>	

<p><tt><b> bandwidthAt( double time ) const
</b></tt>
<blockquote>[ returns double  ]
<br>
Return the interpolated bandwidth (noisiness) coefficient of this
Partial at the specified time. At times beyond the ends of the Partial,
return the bandwidth coefficient at the nearest envelope endpoint. Throw
an InvalidPartial exception if this Partial has no Breakpoints.
</blockquote>	

<p><tt><b> frequencyAt( double time ) const
</b></tt>
<blockquote>[ returns double  ]
<br>
Return the interpolated frequency (in Hz) of this Partial at
the specified time. At times beyond the ends of the
Partial, return the frequency at the nearest envelope
endpoint. Throw an InvalidPartial exception if this
Partial has no Breakpoints.
</blockquote>	

<p><tt><b> phaseAt( double time ) const
</b></tt>
<blockquote>[ returns double  ]
<br>
Return the interpolated phase (in radians) of this Partial at the
specified time. At times beyond the ends of the Partial, return the
extrapolated from the nearest envelope endpoint (assuming constant
frequency, as reported by <code>frequencyAt()</code>). Throw an
InvalidPartial exception if this Partial has no Breakpoints.
</blockquote>	
 				
<p><a href="#contents"><small>Contents</small></a>	

				
<a name="PartialList">
<hr><h2>PartialList</h2></a>
<p>
Typedefs for std lists of Partials.
<p>
<pre>
typedef std::list< Loris::Partial > PartialList;
typedef std::list< Loris::Partial >::iterator PartialListIterator;
typedef std::list< Loris::Partial >::const_iterator PartialListConstIterator;
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="PartialUtils">
<hr><h2>PartialUtils</h2></a>
<p>
A group of Partial utility function objects for use with STL 
searching and sorting algorithms. PartialUtils is a namespace
within the Loris namespace, unless compiled with NO_NESTED_NAMESPACE,
in which case it is a class.

Lakos suggests protecting utility functions like this in a class 
definition, but I think a namespace is better, since that is really
what is being constructed.
<p>
<pre>
//	predicates:
	struct label_equals : 
		public std::binary_function< const Partial, int, bool >
	{
		bool operator()( const Partial & p, int label ) const 
			{ return p.label() == label; }
	};
	
//	comparitors:
	struct label_less : 
		public std::binary_function< const Partial, const Partial, bool >
	{
		bool operator()( const Partial & lhs, const Partial & rhs ) const 
			{ return lhs.label() < rhs.label(); }
	};
	
	struct duration_greater : 
		public std::binary_function< const Partial, const Partial, bool >
	{
		bool operator()( const Partial & lhs, const Partial & rhs ) const 
			{ return lhs.duration() > rhs.duration(); }
	};
	
//	functions on ranges of Partials:
	template <typename Iterator>
#if defined( NO_NESTED_NAMESPACE )
	static
#endif
	inline 
	pair<double,double>
	timeSpan( Iterator begin, Iterator end ) 
	{
		double tmin = 0., tmax = 0.;
		if ( begin != end )
		{
			Iterator it = begin;
			tmin = it->startTime();
			tmax = it->endTime();
			while( it != end )
			{
				tmin = std::min( tmin, it->startTime() );
				tmax = std::max( tmax, it->endTime() );
				++it;
			}
		}
		return std::make_pair(tmin, tmax);
	}
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="SdifFile">
<hr><h2>SdifFile</h2></a>
<p>
Definition of class SdifFile, which reads and writes SDIF files.
<p>
<pre>
//	construction (import):
//	(let compiler generate destructor)
	SdifFile( const std::string & infilename );
		
//	PartialList access:
	PartialList & partials( void ) { return _partials; }
	const PartialList & partials( void ) const { return _partials; }

//	export:
//	enhanced chooses between 4-column 1TRC (sine only) or 6-column RABP (reassigned and enhanced)
	static void Export( const std::string & filename, 
						const PartialList & plist, const bool enhanced = true);
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Sieve">
<hr><h2>Sieve</h2></a>
<p>
Sift labeled Partials: 
If any two partials with same label overlap in time,
keep only the longer of the two partials.
Set the label of the shorter duration partial to zero.
<p>
<pre>
//	construction:	
	explicit Sieve( double minGapTime = 0.0 );
	~Sieve( void );
	
//	sift:
	void sift( PartialList & sift_list );
	void sift( PartialList & sift_list, 
			   PartialList::iterator sieve_begin, 
			   PartialList::iterator sieve_end  );
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="SpcFile">
<hr><h2>SpcFile</h2></a>
<p>
Implementation of class SpcFile, which reads and writes SPC files.
<p>
<pre>
//	construction:
//	(let compiler generate destructor)
	SpcFile( const char *infilename );
		
//	PartialList access:
	PartialList & partials( void ) { return _partialsList; }
	const PartialList & partials( void ) const { return _partialsList; }

//	export:
//
//  the optional enhanced parameter;s default value is true (for bandwidth-enhanced spc files); it
//  can be specified false for pure-sines spc files.
//
//  it is normally left at its default 
//	the optional endApproachTime parameter is in seconds; its default value is zero (and has no effect).
//  a nonzero endApproachTime indicates that the plist does not include a release, but rather ends in a 
//  static spectrum corresponding to the final breakpoint values of the partials.  the endApproachTime
//  specifies how long before the end of the sound the amplitude, frequency, and bandwidth values are
//  to be modified to make a gradual transition to the static spectrum.
 	static void Export( const std::string & filename, const PartialList & plist, double midiPitch, 
				int enhanced = true, double endApproachTime = 0. );
	static void Export( std::ostream & file, const PartialList & plist, double midiPitch, 
				int enhanced = true, double endApproachTime = 0. );
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Synthesizer">
<hr><h2>Synthesizer</h2></a>
<p>
Definition of class of synthesizers of (reassigned) bandwidth-enhanced
partials. Synthesizer accumulates samples for one partial at a time
at a specified sample rate into a specified sample buffer.

The Synthesizer does not own its sample buffer, the client 
is responsible for its construction and destruction. Many 
Synthesizers may share a buffer. (But this class is not thread-safe.)
<p>
<pre>
//	construction:
	Synthesizer( double srate, double * bufStart, double * bufEnd );
	Synthesizer( const Synthesizer & other );
	~Synthesizer(void);
	
	Synthesizer & operator= ( const Synthesizer & other );
	
//	synthesis:
//
//	Synthesize a bandwidth-enhanced sinusoidal Partial with the specified 
//	timeShift (in seconds). Zero-amplitude Breakpoints are inserted
//	1 millisecond (Partial::FadeTime()) from either end of the Partial to reduce 
//	turn-on and turn-off artifacts. The client is responsible or insuring
//	that the buffer is long enough to hold all samples from the time-shifted
//	and padded Partials. Synthesizer will not generate samples outside the
//	buffer, but neither will any attempt be made to eliminate clicks at the
//	buffer boundaries.  
	void synthesize( const Partial & p, double timeShift = 0. ) const;	
	
//	function-call operator, for use as a functor:
	void operator() ( const Partial & p, double timeShift = 0. ) const
		{ synthesize( p, timeShift ) ; }

#if !defined(NO_TEMPLATE_MEMBERS)
//	Partial range operations:
	template<typename Iter>
	void synthesize( Iter begin_partials, Iter end_partials, double timeShift = 0. ) const
		{ while ( begin_partials != end_partials ) synthesize( *(begin_partials++), timeShift ); }

	template<typename Iter>
	void operator() ( Iter begin_partials, Iter end_partials, double timeShift = 0. ) const
		{ synthesize( begin_partials, end_partials, timeShift ); }
#endif
	
//	access:
	double sampleRate( void ) const { return _sampleRate; }
	
	double * samples( void ) { return _sampleBuffer; }
	const double * samples( void ) const { return _sampleBuffer; }
	
	long numSamples( void ) const { return _sampleBufferSize; }
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	





<hr align="Center" size="3">    
<table cellspacing="0" cellpadding="1" width="100%">
  <tbody>
	<tr>
	  <td valign="Top">Last updated on 20 May 2002
	  </td>
	  <td align="Right" valign="Top"><a href="http://www.cerlsoundgroup.org/Loris/">www.cerlsoundgroup.org/Loris/</a>
	  </td>
	</tr>       
  </tbody>    

</body>
</html>
