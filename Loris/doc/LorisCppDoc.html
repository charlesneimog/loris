<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
	<title>Loris C++ API</title>
	<meta name="generator" content="BBEdit 6.1.2+">
</head>
<body BGCOLOR="#ffffff">

<h1>Loris C++ API - version 1.0</h1>

This document describes the public interfaces for the 
classes in the Loris C++ class library. 

<a name="contents"><h1>Classes</h1></a>
<ul>
<li><a href="#AiffFile">AiffFile</a>
<li><a href="#Analyzer">Analyzer</a>
<li><a href="#Breakpoint">Breakpoint</a>
<li><a href="#BreakpointEnvelope">BreakpointEnvelope</a>
<li><a href="#BreakpointUtils">BreakpointUtils</a>
<li><a href="#Channelizer">Channelizer</a>
<li><a href="#Dilator">Dilator</a>
<li><a href="#Distiller">Distiller</a>
<li><a href="#Envelope">Envelope</a>
<li><a href="#Exception">Exception</a>
<li><a href="#FrequencyReference">FrequencyReference</a>
<li><a href="#Morpher">Morpher</a>
<li><a href="#Notifier">Notifier</a>
<li><a href="#Oscillator">Oscillator</a>
<li><a href="#Partial">Partial</a>
<li><a href="#PartialList">PartialList</a>
<li><a href="#PartialUtils">PartialUtils</a>
<li><a href="#SdifFile">SdifFile</a>
<li><a href="#Sieve">Sieve</a>
<li><a href="#SpcFile">SpcFile</a>
<li><a href="#Synthesizer">Synthesizer</a>
</ul>

<a name="AiffFile">
<hr><h2>AiffFile</h2></a>
<p>
Class AiffFile represents a AIFF-format samples file, and
manages file I/O and sample conversion. Construction of an 
AiffFile from a stream or filename automatically imports 
the sample data. The static Export() members export samples 
(doubles) to a AIFF file using the specified stream or filename.
<p>
<h3>Member Functions</h3>

<p><tt><b>AiffFile( const std::string & filename )</b></tt>
<blockquote>
<br>
Initialize an instance of AiffFile by importing data from
the file having the specified filename or path.
</blockquote>

<p><tt><b>AiffFile( std::istream & s )</b></tt>
<blockquote>
<br>
Initialize an instance of AiffFile by importing data from
the specified istream.
</blockquote>

<p><tt><b>channels( void ) const</b></tt>
<blockquote>[ returns int  ]
<br>
Return the number of channels of sample data represented in this
AiffFile (e.g. 1 for mono, 2 for stereo, etc).
</blockquote>

<p><tt><b>sampleFrames( void ) const</b></tt>
<blockquote>[ returns unsigned long  ]
<br>
Return the number of sample frames represented in this AiffFile.
A sample frame contains one sample per channel for a single sample
interval (e.g. mono and stereo samples files having a sample rate of
44100 Hz both have 44100 sample frames per second of audio samples).
</blockquote>

<p><tt><b>sampleRate( void ) const</b></tt>
<blockquote>[ returns double  ]
<br>
Return the sampling freqency in Hz for the sample data in this
AiffFile.
</blockquote>

<p><tt><b>sampleSize( void ) const</b></tt>
<blockquote>[ returns int  ]
<br>
Return the size in bits of a single, integer audio sample in this AiffFile.
</blockquote>

<p><tt><b>getSamples( double * bufBegin, double * bufEnd )</b></tt>
<blockquote>[ returns void  ]
<br>
Convert the integer sample data to doubles and store in on the half-open
(STL-style) range [bufBegin, bufEnd). bufEnd represents a position after
the last valid position in the buffer, no sample is written at bufEnd.
To convert ten samples into a buffer, use <br>
<tt>myAiffFile.getSamples(myBuf, myBuf+10);</tt><br>
</blockquote>

<h3>Static Member Functions</h3>
<p><tt><b>static Export( const std::string & filename, double rate, int chans, int bits, <br>
					const double * bufBegin, const double * bufEnd )</b></tt>
<blockquote>[ returns void  ]
<br>
Export the sample data on the half-open (STL-style) range [bufBegin, bufEnd)
to a AIFF samples file having the specified file name or path, using the 
specified sample rate (in Hz), number of channels, and sample size (in bits).
bufEnd represents a position after the last valid position in the buffer, no 
sample is read from *bufEnd.
</blockquote>

<p><tt><b>static Export( std::ostream & s, double rate, int chans, int bits, <br>
					const double * bufBegin, const double * bufEnd )</b></tt>
<blockquote>[ returns void  ]
<br>
Export the sample data on the half-open (STL-style) range [bufBegin, bufEnd)
in the format of a AIFF samples file on the specified ostream, using the 
specified sample rate (in Hz), number of channels, and sample size (in bits).
bufEnd represents a position after the last valid position in the buffer, no 
sample is read from *bufEnd.
</blockquote>
					
<p><a href="#contents"><small>Contents</small></a>	

<a name="Analyzer">
<hr><h2>Analyzer</h2></a>
<p>
Class Analyzer represents a configuration of parameters for
performing Reassigned Bandwidth-Enhanced Additive Analysis
of sampled waveforms. This analysis process yields a collection 
of <a href="#Partial">Partials</a>, each having a trio of synchronous, non-uniformly-
sampled breakpoint envelopes representing the time-varying 
frequency, amplitude, and noisiness of a single bandwidth-
enhanced sinusoid. 
<p>
For more information about Reassigned Bandwidth-Enhanced 
Analysis and the Reassigned Bandwidth-Enhanced Additive Sound 
Model, refer to the Loris website: 
<a href="http://www.cerlsoundgroup.org/Loris/">www.cerlsoundgroup.org/Loris/</a>.
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>Analyzer( double resolutionHz )</b></tt>
<blockquote>
<br>
Construct and return a new Analyzer configured with the given	
frequency resolution (minimum instantaneous frequency	
difference between Partials). All other Analyzer parameters 	
are computed from the specified frequency resolution. 	
</blockquote>


<p><tt><b>Analyzer( double resolutionHz, double windowWidthHz )
</b></tt>
<blockquote>
<br>
Construct and return a new Analyzer configured with the given	
frequency resolution (minimum instantaneous frequency	
difference between Partials) and analysis window width
(main lobe, zero-to-zero). All other Analyzer parameters 	
are computed from the specified resolution and window width. 
</blockquote>


<p><tt><b>Analyzer( const Analyzer & other )
</b></tt>
<blockquote>
<br>
Construct and return a new Analyzer having identical
parameter configuration to another Analyzer. The list of 
collected Partials is not copied. 	
</blockquote>	

<p><tt><b>~Analyzer( void )</b></tt>
<blockquote>
<br>
Destroy this Analyzer.
</blockquote>

<h4>Configuration</h4>
<p><tt><b>operator = ( const Analyzer & rhs )
</b></tt>
<blockquote>[ returns Analyzer &  ]
<br>
Assignment operator:
change this Analyzer's parameter configuration to 
be identical to that of another Analyzer. The list of 
collected Partials is not copied or otherwise modified.
</blockquote>	

<p><tt><b> configure( double resolutionHz, double windowWidthHz )</b></tt>
<blockquote>[ returns void ]
<br>
Configure this Analyzer with the given frequency resolution 
(minimum instantaneous frequency difference between Partials)
and analysis window width (main lobe, zero-to-zero, in Hz). 
All other Analyzer parameters are (re-)computed from the 
frequency resolution and window width.
</blockquote>

<h4>Analysis</h4>
<p><tt><b>analyze( const double * bufBegin, const double * bufEnd, double srate )</b></tt>
<blockquote>[ returns void ]
<br>
Analyze a range of (mono) samples at the given sample rate 	  	
(in Hz) and append the extracted Partials to Analyzer's 
PartialList. 												
</blockquote>

<h4>Parameter Access</h4>
<p><tt><b> ampFloor( void ) const</b></tt>
<blockquote>[ returns double ]
<br>
Return the amplitude floor (lowest detected spectral amplitude),  			
in (negative) dB, for this Analyzer. 				
</blockquote>

<p><tt><b> bwRegionWidth( void ) const</b></tt>
<blockquote>[ returns double ]
<br>
Return the width (in Hz) of the Bandwidth Association regions
used by this Analyzer.<p>

This parameter is deprecated and not generally useful. It will be
removed in a future release.
</blockquote>

<p><tt><b> cropTime( void ) const </b></tt>
<blockquote>[ return double ]
<br>
Return the crop time (maximum temporal displacement of a time-
frequency data point from the time-domain center of the analysis
window, beyond which data points are considered "unreliable")
for this Analyzer.<p>

This parameter is deprecated and not generally useful. It will be
removed in a future release.

</blockquote>

<p><tt><b> freqDrift( void ) const</b></tt>
<blockquote>[ returns double ]
<br>
Return the maximum allowable frequency difference between 					
consecutive Breakpoints in a Partial envelope for this Analyzer. 				
</blockquote>

<p><tt><b> freqFloor( void ) const </b></tt>
<blockquote>[ returns double ]
<br>
Return the frequency floor (minimum instantaneous Partial  				
frequency), in Hz, for this Analyzer.
</blockquote>

<p><tt><b>freqResolution( void ) const</b></tt>
<blockquote>[ returns double ]
<br>
Return the frequency resolution (minimum instantaneous frequency  		
difference between Partials) for this Analyzer.
</blockquote>

<p><tt><b> hopTime( void ) const </b></tt>
<blockquote>[ returns double ]
<br>
Return the hop time (which corresponds approximately to the 
average density of Partial envelope Breakpoint data) for this 
Analyzer.
</blockquote>

<p><tt><b> windowWidth( void ) const</b></tt>
<blockquote>[ returns double ]
<br>
Return the frequency-domain main lobe width (measured between 
zero-crossings) of the analysis window used by this Analyzer. 				
</blockquote>

<h4>Parameter Mutation</h4>

<p><tt><b> setAmpFloor( double x ) </b></tt>
<blockquote>[ returns void ]
<br>
Set the amplitude floor (lowest detected spectral amplitude), in  			
(negative) dB, for this Analyzer. 				
</blockquote>

<p><tt><b> setBwRegionWidth( double x ) </b></tt>
<blockquote>[ returns void ]
<br>
Set the width (in Hz) of the Bandwidth Association regions
used by this Analyzer.<p>

This parameter is deprecated and not generally useful. It will be
removed in a future release.

</blockquote>

<p><tt><b> setCropTime( double x )</b></tt>
<blockquote>[ returns void ]
<br>
Set the crop time (maximum temporal displacement of a time-
frequency data point from the time-domain center of the analysis
window, beyond which data points are considered "unreliable")
for this Analyzer.<p>

This parameter is deprecated and not generally useful. It will be
removed in a future release.

</blockquote>

<p><tt><b> setFreqDrift( double x )</b></tt>
<blockquote>[ returns void ]
<br>
Set the maximum allowable frequency difference between 					
consecutive Breakpoints in a Partial envelope for this Analyzer.
</blockquote>

<p><tt><b> setFreqFloor( double x ) </b></tt>
<blockquote>[ returns void ]
<br>
Set the amplitude floor (minimum instantaneous Partial  				
frequency), in Hz, for this Analyzer.
</blockquote>

<p><tt><b> setFreqResolution( double x ) </b></tt>
<blockquote>[ returns void ]
<br>
Set the frequency resolution (minimum instantaneous frequency  		
difference between Partials) for this Analyzer. (Does not cause 	
other parameters to be recomputed.) 									
</blockquote>

<p><tt><b> setHopTime( double x )</b></tt>
<blockquote>[ returns void ]
<br>
Set the hop time (which corresponds approximately to the average
density of Partial envelope Breakpoint data) for this Analyzer.
</blockquote>

<p><tt><b> setWindowWidth( double x ) </b></tt>
<blockquote>[ returns void ]
<br>
Set the frequency-domain main lobe width (measured between 
zero-crossings) of the analysis window used by this Analyzer. 				
</blockquote>

<h4>PartialList Access</h4>
<p><tt><b> partials( void )</b></tt>
<blockquote>[ returns PartialList & ]
<br>
Return a mutable reference to this Analyzer's list of 
analyzed Partials. 
</blockquote>

<p><tt><b> partials( void ) const</b></tt>
<blockquote>[ returns const PartialList & ]
<br>
Return an immutable (const) reference to this Analyzer's 
list of analyzed Partials. 
</blockquote>

<p><a href="#contents"><small>Contents</small></a>	

<a name="Breakpoint">
<hr><h2>Breakpoint</h2></a>
<p>
Class Breakpoint represents a single breakpoint in the
Partial parameter (frequency, amplitude, bandwidth) envelope.
Instantaneous phase is also stored, but is only used at the onset of 
a partial, or when it makes a transition from zero to nonzero amplitude.
<p>
Loris Partials represent reassigned bandwidth-enhanced model components.
A Partial consists of a chain of Breakpoints describing the time-varying
frequency, amplitude, and bandwidth (noisiness) of the component.
For more information about Reassigned Bandwidth-Enhanced 
Analysis and the Reassigned Bandwidth-Enhanced Additive Sound 
Model, refer to the Loris website: 
<a href="http://www.cerlsoundgroup.org/Loris/">www.cerlsoundgroup.org/Loris/</a>.
<p>
Breakpoint is a leaf class, do not subclass.
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>Breakpoint( void )</b></tt>
<blockquote>
<br>
Construct a new Breakpoint with all parameters initialized to 0.
</blockquote>

<p><tt><b>Breakpoint( double f, double a, double b, double p = 0. )</b></tt>
<blockquote>
<br>
Construct a new Breakpoint with frequency, amplitude, and bandwidth
initialized to f, a, and b, respectively, and phase initialized to
p, if specified, or 0 otherwise.
</blockquote>

<h4>Comparison</h4>
<p><tt><b> operator == ( const Breakpoint & rhs ) const</b></tt>
<blockquote>[ returns bool ]
<br>
Comparison operator: return true if the frequency, amplitude, 
bandwidth, and phase of this Breakpoint are equal to those of
the Breakpoint rhs. Otherwise, return false.
</blockquote>

<h4>Attribute Access</h4>
<p><tt><b> amplitude( void ) const </b></tt>
<blockquote>[ returns double ]
<br>
Return the amplitude of this Breakpoint.
</blockquote>

<p><tt><b> bandwidth( void ) const </b></tt>
<blockquote>[ returns double ]
<br>
Return the bandwidth (noisiness) coefficient of this Breakpoint.
</blockquote>

<p><tt><b> frequency( void ) const</b></tt>
<blockquote>[ returns double ]
<br>
Return the frequency of this Breakpoint.
</blockquote>

<p><tt><b> phase( void ) const </b></tt>
<blockquote>[ returns double ]
<br>
Return the phase of this Breakpoint.
</blockquote>

<h4>Attribute Mutation</h4>
<p><tt><b> setAmplitude( double x )</b></tt>
<blockquote>[ returns void ]
<br>
Set the amplitude of this Breakpoint.
</blockquote>

<p><tt><b> setBandwidth( double x )</b></tt>
<blockquote>[ returns void ]
<br>
Set the bandwidth (noisiness) coefficient of this Breakpoint.
</blockquote>

<p><tt><b> setFrequency( double x )</b></tt>
<blockquote>[ returns void ]
<br>
Set the frequency of this Breakpoint.
</blockquote>

<p><tt><b> setPhase( double x ) </b></tt>
<blockquote>[ returns void ]
<br>
Set the phase of this Breakpoint.
</blockquote>

				
<p><a href="#contents"><small>Contents</small></a>	

<a name="BreakpointEnvelope">
<hr><h2>BreakpointEnvelope</h2></a>
<p>
A BreakpointEnvelope represents a linear segment breakpoint 
function with infinite extension at each end (that is, evalutaing 
the envelope past either end of the breakpoint function yields the 
value at the nearest end point).
<p>
BreakpointEnvelope implements the Envelope interface, described
by the abstract class <a href="#Envelope">Envelope</a>. 
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>BreakpointEnvelope( void )</b></tt>
<blockquote>
<br>
Construct and return a new BreakpointEnvelope having no 
breakpoints (and an implicit value of 0. everywhere).
</blockquote>

<p><tt><b>BreakpointEnvelope( double initialValue )</b></tt>
<blockquote>
<br>
Construct and return a new BreakpointEnvelope having a 
single breakpoint at 0. (and an implicit value everywhere)
of initialValue.
</blockquote>		

<p><tt><b>BreakpointEnvelope( const BreakpointEnvelope & other )</b></tt>
<blockquote>
<br>
Construct and return a new BreakpointEnvelope that is
a copy of this BreapointEnvelope (has the same value
as this BreakpointEnvelope everywhere).			
</blockquote>

<p><tt><b>~BreakpointEnvelope( void )</b></tt>
<blockquote>
<br>
Destroy this BreakpointEnvelope. 								
</blockquote>


<h4>Envelope Interface</h4>
<p><tt><b> clone( void ) const</b></tt>
<blockquote>[ returns BreakpointEnvelope *  ]
<br>
Return an exact copy of this BreakpointEnvelope
(following the Prototype pattern).
</blockquote>


<p><tt><b> valueAt( double x ) const</b></tt>
<blockquote>[ returns double  ]
<br>
Return the linearly-interpolated value of this BreakpointEnvelope at 
the specified time.							
</blockquote>


<h4>Envelope Composition</h4>
<p><tt><b> insertBreakpoint( double time, double value )</b></tt>
<blockquote>[ returns void  ]
<br>
Insert a breakpoint representing the specified (time, value) 
pair into this BreakpointEnvelope. If there is already a 
breakpoint at the specified time, it will be replaced with 
the new breakpoint.
</blockquote>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="BreakpointUtils">
<hr><h2>BreakpointUtils</h2></a>
<p>
BreakpointUtils represents a collection of utility functions and 
function objects for applying STL searching and sorting algorithms 
to collections of Loris Breakpoints. BreakpointUtils is a namespace
within the Loris namespace, unless compiled with NO_LORIS_NAMESPACE,
in which case it is a class (having only static members and private
constructors).
<p>
<h4>Free Functions</h4>
<p><tt><b> addNoiseEnergy( Breakpoint & bp, double enoise )</b></tt>
<blockquote>[ returns void  ]
<br>
Add noise (bandwidth) energy to a Breakpoint by computing new 
amplitude and bandwidth values. enoise may be negative, but 
noise energy cannot be removed (negative energy added) in excess 
of the current noise energy.
</blockquote>

<h4>Predicates</h4>
	<p><tt><b>struct frequency_between : 
		public std::unary_function< const Breakpoint, bool ></b></tt>
<blockquote>[ returns bool  ]
<br>
Predicate functor returning true if its Breakpoint argument 
has frequency between specified bounds, and false otherwise, constructed
<pre>
Loris::BreakpointUtils::frequency_between( double lowerbound, double upperbound )
</pre>
</blockquote>

<h4>Comparitors</h4>

<p><tt><b>struct less_frequency : 
public std::binary_function< const Breakpoint, const Breakpoint, bool >
</b></tt>
<blockquote>[ returns bool  ]
<br>
Comparitor (binary) functor returning true if its first Breakpoint
argument has frequency less than that of its second Breakpoint argument,
and false otherwise.
</blockquote>	


<p><tt><b>struct greater_amplitude : 
public std::binary_function< const Breakpoint, const Breakpoint, bool >
</b></tt>
<blockquote>[ returns bool  ]
<br>
Comparitor (binary) functor returning true if its first Breakpoint
argument has amplitude greater than that of its second Breakpoint argument,
and false otherwise.
</blockquote>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Channelizer">
<hr><h2>Channelizer</h2></a>
<p>
Class Channelizer represents an algorithm for automatic labeling of a
collection (STL range) of Partials. Partials must be labeled in
preparation for morphing (see <a href="#Morpher">Morpher</a>) to
establish correspondences between Partials in the morph source and
target sounds.
<p>
Channelized partials are labeled according to their adherence to a
harmonic frequency structure with a time-varying fundamental frequency.
The frequency spectrum is partitioned into non-overlapping channels
having time-varying center frequencies that are harmonic (integer)
multiples of a specified reference frequency envelope, and each channel
is identified by a unique label equal to its harmonic number. Each
Partial is assigned the label corresponding to the channel containing
the greatest portion of its (the Partial's) energy.
<p>
A reference frequency Envelope for channelization and the channel number
to which it corresponds (1 for an Envelope that tracks the Partial at
the fundamental frequency) must be specified. The reference Envelope can
be constructed explcitly, point by point (using, for example, the <a
href="#BreakpointEnvelope">BreakpointEnvelope</a> class), or constructed
automatically using the <a
href="#FrequencyReference">FrequencyReference</a> class.
<p>
Channelizer is a leaf class, do not subclass. 
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>Channelizer( const Envelope & refChanFreq, int refChanLabel )
</b></tt>
<blockquote>
<br>
Construct a new Channelizer using the specified reference frequency
Envelope to represent the channel numbered refChanLabel.
</blockquote>	

<p><tt><b>Channelizer( const Channelizer & other )
</b></tt>
<blockquote>
<br>
Construct a new Channelizer that is an exact copy of this Channelizer
(uses the same reference frequency Envelope to represent the same 
channel).
</blockquote>	

<p><tt><b>~Channelizer( void )
</b></tt>
<blockquote>
<br>
Destroy this Channelizer.
</blockquote>	

<p><tt><b> operator=( const Channelizer & rhs )
</b></tt>
<blockquote>[ returns Channelizer &  ]
<br>
Assignment operator: make this Channelizer an exact copy of rhs 
(use the same set of frequency channels).
</blockquote>	


<h4>Channelizing</h4>
<p><tt><b> channelize( PartialList::iterator begin, PartialList::iterator end ) const
</b></tt>
<blockquote>[ returns void  ]
<br>
Assign each Partial in the specified half-open (STL-style) range
the label corresponding to the frequency channel containing the
greatest portion of its (the Partial's) energy.
</blockquote>	


<p><tt><b> operator() ( PartialList::iterator begin, PartialList::iterator end ) const
</b></tt>
<blockquote>[ returns void  ]
<br>
Function call operator: same as channelize().
</blockquote>	
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Dilator">
<hr><h2>Dilator</h2></a>
<p>
Class Dilator represents an algorithm for for non-uniformly expanding
and contracting the Partial parameter envelopes according to the initial
and target (desired) times of temporal features.
<p>
It is frequently necessary to redistribute temporal events in this way
in preparation for a sound morph. For example, when morphing instrument
tones, it is common to align the attack, sustain, and release portions
of the source sounds by dilating or contracting those temporal regions.
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>Dilator( void )
</b></tt>
<blockquote>
<br>
Construct a new Dilator with no time points.
</blockquote>	

<p><tt><b>template&lt;typename Iter1, typename Iter2&gt;<br>
Dilator( Iter1 ibegin, Iter1 iend, Iter2 tbegin )
</b></tt>
<blockquote>
<br>
Construct a new Dilator using a range of initial time points
and a range of target (desired) time points. The client must
ensure that the target range has at least as many elements as
the initial range.
<p>
If compiled with NO_TEMPLATE_MEMBERS defined, this constructor
is defined:
<pre>
Dilator( const double * ibegin, const double * iend, const double * tbegin )
</pre>
</blockquote>
	
<p><tt><b>~Dilator( void )
</b></tt>
<blockquote>
<br>
Destroy this Dilator.
</blockquote>	
	
<p><tt><b> insert( double i, double t )
</b></tt>
<blockquote>[ returns void  ]
<br>
Specify a pair of initial and target time points to be used
by this Dilator, corresponding, for example, to the initial
and desired time of a particular temporal feature in an
analyzed sound.
</blockquote>	

<h4>Dilation</h4>
<p><tt><b> dilate( Partial & p )
</b></tt>
<blockquote>[ returns void  ]
<br>
Non-uniformly expand and contract the parameter envelopes of the
specified Partial according to this Dilator's stored initial and 
target (desired) times.
</blockquote>	

<p><tt><b> operator() ( Partial & p )
</b></tt>
<blockquote>[ returns void  ]
<br>
Function call operator: same as dilate( Partial & p ).
</blockquote>	

		
<p><tt><b>template&lt;typename Iter&gt;<br>
 dilate( Iter dilate_begin, Iter dilate_end )
</b></tt>
<blockquote>[ returns void  ]
<br>
Non-uniformly expand and contract the parameter envelopes of the each
Partial in the specified half-open range according to this Dilator's
stored initial and target (desired) times.
<p>
If compiled with NO_TEMPLATE_MEMBERS defined, this member
is defined:
<pre>
dilate( PartialList::iterator dilate_begin, PartialList::iterator dilate_end  )
</pre>
</blockquote>	

<p><tt><b>template&lt;typename Iter&gt;<br>
 operator() ( Iter dilate_begin, Iter dilate_end  )
</b></tt>
<blockquote>[ returns void  ]
<br>
Function call operator: same as dilate( Iter dilate_begin, Iter dilate_end )
<p>
If compiled with NO_TEMPLATE_MEMBERS defined, this member
is defined:
<pre>
operator() ( PartialList::iterator dilate_begin, PartialList::iterator dilate_end )
</pre>
</blockquote>	

<p><tt><b> warpTime( double currentTime )</b></tt>
<blockquote>[ returns double  ]
<br>
Return the dilated time value corresponding to the specified 
initial time.
</blockquote>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Distiller">
<hr><h2>Distiller</h2></a>
<p>
Class Distiller represents an algorithm for "distilling" a group of
Partials that logically represent a single component into a single
Partial.
<p>
The sound morphing algorithm in Loris requires that Partials in a
given source be labeled uniquely, that is, no two Partials can have
the same label. The Distiller enforces this condition. All Partials
identified with a particular frequency channel (see <a
href="#Channelizer">Channelizer</a>), and, therefore, having a common
label, are distilled into a single Partial, leaving at most a single
Partial per frequency channel and label. Channels that contain no
Partials are not represented in the distilled data. Partials that are
not labeled, that is, Partials having label 0, are unaffected by the
distillation process. All unlabeled Partials remain unlabeled and
unmodified in the distilled partial set.
<p>
Distillation modifies the Partial container (a PartialList). All 
Partials in the distilled range having a common label are replaced
by a single Partial in the distillation process.
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>Distiller( void )</b></tt>
<blockquote>
<br>
Construct a new Distiller.
</blockquote>

<p><tt><b>~Distiller( void )</b></tt>
<blockquote>
<br>
Destroy this Distiller.
</blockquote>
	
<h4>Distillation</h4>

<p><tt><b> distill( PartialList & container, PartialList::iterator dist_begin, 
PartialList::iterator dist_end )
</b></tt>
<blockquote>[ returns void  ]
<br>
Distill Partial on the specified half-open (STL-style) range in the
specified container (PartialList). 
</blockquote>	

<p><tt><b> distill( PartialList & container )</b></tt>
<blockquote>[ returns void  ]
<br>
Distill all Partials in the specified container (PartialList).
</blockquote>

<p><tt><b> operator() ( PartialList & container, PartialList::iterator dist_begin, 
PartialList::iterator dist_end )
</b></tt>
<blockquote>[ returns void  ]
<br>
Function call operator: same as distill( PartialList & container, PartialList::iterator dist_begin, 
PartialList::iterator dist_end ). 
</blockquote>
	
<p><a href="#contents"><small>Contents</small></a>	

<a name="Envelope">
<hr><h2>Envelope</h2></a>
<p>
Abstract base class, specifying interface ( valueAt() and clone() ).
Derived classes must implement valueAt() and clone(), the latter to 
support the Prototype pattern.

Clients of Envelope, like Morpher, use the Prototype pattern to safely
take ownership of their Envelopes. Formerly, Handle<>s were used for this
purpose, but using them polymorphically seemed to trigger random and 
diverse compiler problems. Handle<>s are no longer part of Loris.

Envelope is an abstract base class representing a generic real (double) 
function of one real (double) argument. 
<p>
<pre>
	virtual double valueAt( double x ) const = 0;	
	virtual ~Envelope( void );
	
	virtual Envelope * clone( void ) const = 0;
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Exception">
<hr><h2>Exception</h2></a>
<p>
Generic exception class for reporting exceptional circumstances.
Can be a base class for more specific exception classes in Loris.
<p>
<pre>
//	construction:
	Exception( const std::string & str, const std::string & where = "" );

//	virtual destructor so it Exception can be subclassed:
	virtual ~Exception( void ) {}
	
//	access:
	const std::string & str( void ) const { return _sbuf; }
	const char * what( void ) const { return _sbuf.c_str(); }
	
	Exception & append( const std::string & str );
	
class AssertionFailure : public Exception
class IndexOutOfBounds : public Exception
class FileIOException : public Exception
class InvalidObject : public Exception
class InvalidIterator : public InvalidObject
class InvalidArgument : public Exception
class InvalidPartial : public InvalidObject (in Partial.h)

Throw( exType, report )	
Assert(test)
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="FrequencyReference">
<hr><h2>FrequencyReference</h2></a>
<p>
A functor class that creates a reference frequency envelope from
the longest Partial found in a given iterator range and in a 
specified frequency range. This class implements the Envelope
interface.
<p>
<pre>
	//	construction: 
	FrequencyReference( PartialList::const_iterator begin, 
						PartialList::const_iterator end, 
						double minFreq, double maxFreq, long numSamps );
	FrequencyReference( PartialList::const_iterator begin, 
						PartialList::const_iterator end, 
						double minFreq, double maxFreq );
	FrequencyReference( const FrequencyReference & other );
	FrequencyReference & operator= ( const FrequencyReference & other );
	~FrequencyReference();

	//	BreakpointEnvelope access:
	const BreakpointEnvelope & envelope( void ) const { return *_env; }

//	Envelope interface:
	virtual FrequencyReference * clone( void ) const;
	/*	Return an exact copy of this FrequencyReference.
		(Prototype pattern)
	 */
	
	virtual double valueAt( double x ) const;	
	/*	Return the interpolated value of this FrequencyReference at 
		the specified time.							
	 */
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Morpher">
<hr><h2>Morpher</h2></a>
<p>
Class Morpher performs sound morphing and Partial parameter
envelope interpolation according to a trio of frequency, amplitude,
and bandwidth morphing functions, described by Envelopes.
Sound morphing is achieved by interpolating the time-varying 
frequencies, amplitudes, and bandwidths of corresponding partials 
obtained from reassigned bandwidth-enhanced analysis of the source 
and target sounds. Partial correspondences may be established by 
labeling, using instances of the Channelizer and Distiller classes.
<p>
The Morpher collects morphed Partials in a PartialList, that is
accessible to clients.
<p>
For more information about sound morphing using 
the Reassigned Bandwidth-Enhanced Additive Sound 
Model, refer to the Loris website: 
<a href="http://www.cerlsoundgroup.org/Loris/">www.cerlsoundgroup.org/Loris/</a>.
<p>
Morpher is a leaf class, do not subclass.
<p>
<h3>Member Functions</h3>
<h4>Construction</h4>
<p><tt><b>Morpher( const Envelope & f )
</b></tt>
<blockquote>
<br>
Construct a new Morpher using the same morphing envelope for 
frequency, amplitude, and bandwidth (noisiness).
</blockquote>	
<p><tt><b>Morpher( const Envelope & ff, const Envelope & af, const Envelope & bwf )
</b></tt>
<blockquote>
<br>
Construct a new Morpher using the specified morphing envelopes for
frequency, amplitude, and bandwidth (noisiness).
</blockquote>	

<p><tt><b>~Morpher( void )
</b></tt>
<blockquote>
<br>
Destroy this Morpher.
</blockquote>	

	
<h4>Morphed Parameter Computation</h4>

<p><tt><b> morphParameters( const Breakpoint & srcBkpt, const Breakpoint & tgtBkpt, 
					  double time, Breakpoint & retBkpt )
</b></tt>
<blockquote>[ returns void  ]
<br>
Morph Breakpoint to Breakpoint:
compute morphed parameter values at the specified time, using
the source and target Breakpoints (assumed to correspond exactly 
to the specified time). Return the morphed Parameters in the
specified return Breakpoint.
</blockquote>	

					  

<p><tt><b> morphParameters( const Breakpoint & srcBkpt, const Partial & tgtPartial, 
					  double time, Breakpoint & retBkpt )
</b></tt>
<blockquote>[ returns void  ]
<br>
Morph Breakpoint to Partial:
compute morphed parameter values at the specified time, using
the source Breakpoint (assumed to correspond exactly to the
specified time) and the target Partial (whose parameters are
examined at the specified time). Return the morphed Parameters 
in the specified return Breakpoint.
<p>
The target Partial may be a dummy Partial (no Breakpoints).
</blockquote>	

					  

<p><tt><b> morphParameters( const Partial & srcPartial, const Breakpoint & tgtBkpt, 
					  double time, Breakpoint & retBkpt )
</b></tt>
<blockquote>[ returns void  ]
<br>
Morph Partial to Breakpoint:
compute morphed parameter values at the specified time, using
the source Partial (whose parameters are examined at the specified 
time) and the target Breakpoint (assumed to correspond exactly to 
the specified time). Return the morphed Parameters in the
specified return Breakpoint.
<p>
The source Partial may be a dummy Partial (no Breakpoints).
</blockquote>	

					  

<p><tt><b> morphParameters( const Partial & srcPartial, const Partial & tgtPartial, 
					  double time, Breakpoint & retBkpt )
</b></tt>
<blockquote>[ returns void  ]
<br>
Morph Partial to Partial:
compute morphed parameter values at the specified time, using
the source  and target Partials, both of whose parameters are 
examined at the specified time. Return the morphed Parameters 
in the specified return Breakpoint.
<p>
Either (or neither) the source or target Partial may be a dummy 
Partial (no Breakpoints), but not both.
</blockquote>	



<h4>Partial morphing</h4>

<p><tt><b> morphPartial( const Partial & src, const Partial & tgt, int assignLabel )
</b></tt>
<blockquote>[ returns Partial &  ]
<br>
Morph a pair of Partials to yield a new morphed Partial. 
Dummy Partials (having no Breakpoints) don't contribute to the
morph, except to cause their opposite to fade out. 
Either (or neither) the source or target Partial may be a dummy 
Partial (no Breakpoints), but not both. The morphed
Partial has Breakpoints at times corresponding to every Breakpoint 
in both source Partials. The morphed Partial is appended
to the Morpher's PartialList, and a reference to it is returned.
The new morphed Partial is assigned the specified label.
</blockquote>	



<p><tt><b> morph( PartialList::const_iterator beginSrc, 
			PartialList::const_iterator endSrc,
			PartialList::const_iterator beginTgt, 
			PartialList::const_iterator endTgt )
</b></tt>
<blockquote>[ returns void  ]
<br>
Morph two sounds (collections of Partials labeled to indicate
correspondences) into a single labeled collection of Partials.
Unlabeled Partials (having label 0) are crossfaded. The morphed
and crossfaded Partials are stored in the Morpher's PartialList.
<p>
The Partials in the first range are treated as components of the 
source sound, corresponding to a morph function value of 0, and  
those in the second are treated as components of the target sound, 
corresponding to a morph function value of 1.
</blockquote>	



<p><tt><b> crossfade( PartialList::const_iterator beginSrc, 
				PartialList::const_iterator endSrc,
				PartialList::const_iterator beginTgt, 
				PartialList::const_iterator endTgt )
</b></tt>
<blockquote>[ returns void  ]
<br>
Crossfade Partials with no correspondences.
<p>
Unlabeled Partials (having label 0) are considered to 
have no correspondences, so they are just faded out, and not 
actually morphed. This is the same as morphing each with an 
empty dummy Partial (having no Breakpoints). 
<p>
The Partials in the first range are treated as components of the 
source sound, corresponding to a morph function value of 0, and  
those in the second are treated as components of the target sound, 
corresponding to a morph function value of 1.
<p>
The crossfaded Partials are stored in the Morpher's PartialList.
</blockquote>	


<h4>Morphing Function Access/Mutation</h4>

<p><tt><b> setFrequencyFunction( const Envelope & f )
</b></tt>
<blockquote>[ returns void  ]
<br>
Assign a new frequency morphing envelope to this Morpher.
</blockquote>	

<p><tt><b> setAmplitudeFunction( const Envelope & f )
</b></tt>
<blockquote>[ returns void  ]
<br>
Assign a new amplitude morphing envelope to this Morpher.
</blockquote>	

<p><tt><b> setBandwidthFunction( const Envelope & f )
</b></tt>
<blockquote>[ returns void  ]
<br>
Assign a new bandwidth morphing envelope to this Morpher.
</blockquote>	


<p><tt><b> frequencyFunction( void ) const
</b></tt>
<blockquote>[ returns const Envelope &  ]
<br>
Return a reference to this Morpher's frequency morphing envelope.
</blockquote>	

<p><tt><b> amplitudeFunction( void ) const
</b></tt>
<blockquote>[ returns const Envelope &  ]
<br>
Return a reference to this Morpher's amplitude morphing envelope.
</blockquote>	

<p><tt><b> bandwidthFunction( void ) const
</b></tt>
<blockquote>[ returns const Envelope &  ]
<br>
Return a reference to this Morpher's bandwidth morphing envelope.
</blockquote>	

	
<h4>PartialList access</h4>

<p><tt><b> partials( void )
</b></tt>
<blockquote>[ returns PartialList &  ]
<br>
Return a reference to this Morpher's list of morphed Partials.
</blockquote>	


<p><tt><b> partials( void ) const
</b></tt>
<blockquote>[ returns const PartialList &  ]
<br>
Return a const reference to this Morpher's list of morphed Partials.
</blockquote>	
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Notifier">
<hr><h2>Notifier</h2></a>
<p>
Fully-insulating class encapsulating manipulations involving 
linear interpolation of Partial parameter envelopes. The implementation
is entirely defined in the Morpher_imp class, in Morpher.C.

The Morpher object performs sound morphing (cite Lip's papers, and the book)
by interpolating Partial parmeter envelopes of corresponding Partials in
a pair of source sounds. The correspondences are established by labeling.
The Morpher object collects morphed Partials in a list<Partial>, that can
be accessed by clients.

The Morpher interface is fully insulating, the implementation is 
defined entirely inthe Morpher_imp class in Morpher.C.
Morpher is a leaf class, do not subclass.
<p>
<pre>
std::ostream & getNotifierStream(void);
std::ostream & getDebuggerStream(void);

//	declare streams:
static std::ostream & notifier = getNotifierStream();
static std::ostream & debugger = getDebuggerStream();

These are declared extern "C" and can be called from C:
typedef void(*NotificationHandler)(const char * s);
NotificationHandler setNotifierHandler( NotificationHandler fn );
NotificationHandler setDebuggerHandler( NotificationHandler fn );
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Oscillator">
<hr><h2>Oscillator</h2></a>
<p>
Oscillator represents a single bandwidth-enhanced sinusoidal oscillator
used for synthesizing sounds from Reassigned Bandwidth-Enhanced analysis
data. Oscillator encapsulates the oscillator state, including the instan-
taneous radian frequency, amplitude, bandwidth, and phase, and a filter
object used to generate the bandlimited stochastic modulator.

Loris::Synthesizer uses an instance of Loris::Oscillator to synthesize
bandwidth-enhanced partials obtained from Reassigned Bandwidth-Enhanced
analysis data.
<p>
<pre>
//	construction (with initial state):
	Oscillator( double radf, double a, double bw, double ph );
	Oscillator( void );
	Oscillator( const Oscillator & other );
	~Oscillator( void );
		
	Oscillator & operator= ( const Oscillator & other );

//	state access:
	double radianFreq( void ) const { return _frequency; }
	double amplitude( void ) const { return _amplitude; }
	double bandwidth( void ) const { return _bandwidth; }
	double phase( void ) const { return _phase; }

//	state mutation:	
	void setRadianFreq( double x ) { _frequency = x; }
	void setAmplitude( double x ) { _amplitude = x; }
	void setBandwidth( double x ) { _bandwidth = x; }
	void setPhase( double x ) { _phase = x; }

//	sample generation:	
//	Accumulate bandwidth-enhanced sinusoidal samples modulating the 
//	oscillator state from its current values of radian frequency,
//	amplitude, and bandwidth to the specified target values, starting
//	at beginIdx and ending at (before) endIdx (no sample is accumulated
//	at endIdx). The indices are positions in the specified buffer.
//
//	The caller must insure that the indices are valid. Target frequency
//	and bandwidth are checked to prevent aliasing and bogus bandwidth
//	enhancement.
	void generateSamples( double * begin, double * end,
					  double targetFreq, double targetAmp, double targetBw );
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Partial">
<hr><h2>Partial</h2></a>
<p>
Definition of class of objects representing reassigned bandwidth-enhanced 
model components in Loris. Partials are described by the Partial parameter 
(frequency, amplitude, bandwidth) envelope and a 4-byte label. 

Loris Partials represent reassigned bandwidth-enhanced model components.
A Partial consists of a chain of Breakpoints describing the time-varying
frequency, amplitude, and bandwidth (noisiness) of the component.

Leaf class, do not subclass.
<p>
<pre>
//	construction:
	Partial( void );
	Partial( const Partial & other );
	~Partial( void );
	
//	access/query:
	int label( void ) const { return _label; }
	double initialPhase( void ) const;
	double startTime( void ) const;
	double endTime( void ) const;
	double duration( void ) const;
	long numBreakpoints( void ) const { return _bpmap.size(); }
	
//	mutation:
	void setLabel( int l ) { _label = l; }
	
//	comparison:
	bool operator== ( const Partial & rhs ) const;
	
//	iterator generation:
	typedef PartialIterator iterator;
	typedef PartialConstIterator const_iterator;
	iterator begin( void );
	iterator end( void );
	const_iterator begin( void ) const;
	const_iterator end( void ) const;
	
//	Breakpoint insertion:
//	Make a copy of bp and insert it at time (seconds),
//	return an iterator refering to the inserted Breakpoint.
	iterator insert( double time, const Breakpoint & bp );

//	Return the insertion position for a Breakpoint at
//	the specified time (that is, the position of the first
//	Breakpoint at a time later than the specified time).
	iterator findAfter( double time );
	const_iterator findAfter( double time ) const;
	
//	Return the insertion position for the Breakpoint nearest
//	the specified time.
	iterator findNearest( double time );
	const_iterator findNearest( double time ) const;
	
//	Breakpoint removal:
//	Erase the Breakpoint at the position of the 
//	given iterator (invalidating the iterator).
	void erase( iterator & pos );
	
//	partial envelope interpolation/extrapolation:
//	Return the interpolated value of a partial parameter at
//	the specified time. At times beyond the ends of the
//	Partial, frequency and bandwidth hold their boundary values,
//	amplitude is zero, and phase is computed from frequency.
//	There is of sensible definition for any of these for Partials
//	having no Breakpoints, so they except (InvalidPartial) under 
//	that condition.
//
	double frequencyAt( double time ) const;
	double amplitudeAt( double time ) const;
	double bandwidthAt( double time ) const;
	double phaseAt( double time ) const;
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="PartialConstIterator">
<hr><h2>PartialConstIterator</h2></a>
<p>
Const iterator for the Loris::Partial Breakpoint map. Wraps
the const iterator for std::map< double, Breakpoint >.
<p>
<pre>
//	construction:
//	(allow compiler to generate copy, assignment, and destruction):
	PartialConstIterator( void ) {}
	PartialConstIterator( const PartialIterator & other ) : _iter( other._iter ) {}
	
//	pre-increment/decrement:
	PartialConstIterator& operator ++ () { ++_iter; return *this; }
	PartialConstIterator& operator -- () { --_iter; return *this; }

//	post-increment/decrement:
	PartialConstIterator operator ++ ( int ) { return PartialConstIterator( _iter++ ); } 
	PartialConstIterator operator -- ( int ) { return PartialConstIterator( _iter-- ); } 
	
//	time and Breakpoint access:
	const Breakpoint & breakpoint( void ) const { return _iter->second; }	
	double time( void ) const { return _iter->first; }	

//	dereference (for treating Partial like a 
//	STL collection of Breakpoints):
	const Breakpoint & operator * ( void ) const { return _iter->second; }
	const Breakpoint * operator -> ( void ) const { return & _iter->second; }
	
//	comparison:
	friend bool operator == ( const PartialConstIterator & lhs, const PartialConstIterator & rhs )
		{ return lhs._iter == rhs._iter; }
	friend bool operator != ( const PartialConstIterator & lhs, const PartialConstIterator & rhs )
		{ return lhs._iter != rhs._iter; }
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="PartialIterator">
<hr><h2>PartialIterator</h2></a>
<p>
This will be called PartialIterator when the other thing called 
PartialIterator is renamed and reimplemented as PartialView or
EnvelopeView.

This is pretty much just a wrapper for the nasty-looking map<>
iterators.

Non-const iterator for the Loris::Partial Breakpoint map. Wraps
the non-const iterator for std::map< double, Breakpoint >.
<p>
<pre>
//	construction:
//	(allow compiler to generate copy, assignment, and destruction):
	PartialIterator( void ) {}
	
//	pre-increment/decrement:
	PartialIterator& operator ++ () { ++_iter; return *this; }
	PartialIterator& operator -- () { --_iter; return *this; }

//	post-increment/decrement:
	PartialIterator operator ++ ( int ) { return PartialIterator( _iter++ ); } 
	PartialIterator operator -- ( int ) { return PartialIterator( _iter-- ); } 
	
//	time and Breakpoint access:
	const Breakpoint & breakpoint( void ) const { return _iter->second; }
	Breakpoint & breakpoint( void ) { return _iter->second; }
	double time( void ) const { return _iter->first; }	
	
//	dereference (for treating Partial like a 
//	STL collection of Breakpoints):
	const Breakpoint & operator * ( void ) const { return _iter->second; }
	Breakpoint & operator * ( void ) { return _iter->second; }
	const Breakpoint * operator -> ( void ) const { return & _iter->second; }
	Breakpoint * operator -> ( void ) { return & _iter->second; }
	
//	comparison:
	friend bool operator == ( const PartialIterator & lhs, const PartialIterator & rhs )
		{ return lhs._iter == rhs._iter; }
	friend bool operator != ( const PartialIterator & lhs, const PartialIterator & rhs )
		{ return lhs._iter != rhs._iter; }
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="PartialList">
<hr><h2>PartialList</h2></a>
<p>
Typedefs for std lists of Partials.
<p>
<pre>
typedef std::list< Loris::Partial > PartialList;
typedef std::list< Loris::Partial >::iterator PartialListIterator;
typedef std::list< Loris::Partial >::const_iterator PartialListConstIterator;
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="PartialUtils">
<hr><h2>PartialUtils</h2></a>
<p>
A group of Partial utility function objects for use with STL 
searching and sorting algorithms. PartialUtils is a namespace
within the Loris namespace, unless compiled with NO_NESTED_NAMESPACE,
in which case it is a class.

Lakos suggests protecting utility functions like this in a class 
definition, but I think a namespace is better, since that is really
what is being constructed.
<p>
<pre>
//	predicates:
	struct label_equals : 
		public std::binary_function< const Partial, int, bool >
	{
		bool operator()( const Partial & p, int label ) const 
			{ return p.label() == label; }
	};
	
//	comparitors:
	struct label_less : 
		public std::binary_function< const Partial, const Partial, bool >
	{
		bool operator()( const Partial & lhs, const Partial & rhs ) const 
			{ return lhs.label() < rhs.label(); }
	};
	
	struct duration_greater : 
		public std::binary_function< const Partial, const Partial, bool >
	{
		bool operator()( const Partial & lhs, const Partial & rhs ) const 
			{ return lhs.duration() > rhs.duration(); }
	};
	
//	functions on ranges of Partials:
	template <typename Iterator>
#if defined( NO_NESTED_NAMESPACE )
	static
#endif
	inline 
	pair<double,double>
	timeSpan( Iterator begin, Iterator end ) 
	{
		double tmin = 0., tmax = 0.;
		if ( begin != end )
		{
			Iterator it = begin;
			tmin = it->startTime();
			tmax = it->endTime();
			while( it != end )
			{
				tmin = std::min( tmin, it->startTime() );
				tmax = std::max( tmax, it->endTime() );
				++it;
			}
		}
		return std::make_pair(tmin, tmax);
	}
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="SdifFile">
<hr><h2>SdifFile</h2></a>
<p>
Definition of class SdifFile, which reads and writes SDIF files.
<p>
<pre>
//	construction (import):
//	(let compiler generate destructor)
	SdifFile( const std::string & infilename );
		
//	PartialList access:
	PartialList & partials( void ) { return _partials; }
	const PartialList & partials( void ) const { return _partials; }

//	export:
//	enhanced chooses between 4-column 1TRC (sine only) or 6-column RABP (reassigned and enhanced)
	static void Export( const std::string & filename, 
						const PartialList & plist, const bool enhanced = true);
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Sieve">
<hr><h2>Sieve</h2></a>
<p>
Sift labeled Partials: 
If any two partials with same label overlap in time,
keep only the longer of the two partials.
Set the label of the shorter duration partial to zero.
<p>
<pre>
//	construction:	
	explicit Sieve( double minGapTime = 0.0 );
	~Sieve( void );
	
//	sift:
	void sift( PartialList & sift_list );
	void sift( PartialList & sift_list, 
			   PartialList::iterator sieve_begin, 
			   PartialList::iterator sieve_end  );
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="SpcFile">
<hr><h2>SpcFile</h2></a>
<p>
Implementation of class SpcFile, which reads and writes SPC files.
<p>
<pre>
//	construction:
//	(let compiler generate destructor)
	SpcFile( const char *infilename );
		
//	PartialList access:
	PartialList & partials( void ) { return _partialsList; }
	const PartialList & partials( void ) const { return _partialsList; }

//	export:
//
//  the optional enhanced parameter;s default value is true (for bandwidth-enhanced spc files); it
//  can be specified false for pure-sines spc files.
//
//  it is normally left at its default 
//	the optional endApproachTime parameter is in seconds; its default value is zero (and has no effect).
//  a nonzero endApproachTime indicates that the plist does not include a release, but rather ends in a 
//  static spectrum corresponding to the final breakpoint values of the partials.  the endApproachTime
//  specifies how long before the end of the sound the amplitude, frequency, and bandwidth values are
//  to be modified to make a gradual transition to the static spectrum.
 	static void Export( const std::string & filename, const PartialList & plist, double midiPitch, 
				int enhanced = true, double endApproachTime = 0. );
	static void Export( std::ostream & file, const PartialList & plist, double midiPitch, 
				int enhanced = true, double endApproachTime = 0. );
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	

<a name="Synthesizer">
<hr><h2>Synthesizer</h2></a>
<p>
Definition of class of synthesizers of (reassigned) bandwidth-enhanced
partials. Synthesizer accumulates samples for one partial at a time
at a specified sample rate into a specified sample buffer.

The Synthesizer does not own its sample buffer, the client 
is responsible for its construction and destruction. Many 
Synthesizers may share a buffer. (But this class is not thread-safe.)
<p>
<pre>
//	construction:
	Synthesizer( double srate, double * bufStart, double * bufEnd );
	Synthesizer( const Synthesizer & other );
	~Synthesizer(void);
	
	Synthesizer & operator= ( const Synthesizer & other );
	
//	synthesis:
//
//	Synthesize a bandwidth-enhanced sinusoidal Partial with the specified 
//	timeShift (in seconds). Zero-amplitude Breakpoints are inserted
//	1 millisecond (Partial::FadeTime()) from either end of the Partial to reduce 
//	turn-on and turn-off artifacts. The client is responsible or insuring
//	that the buffer is long enough to hold all samples from the time-shifted
//	and padded Partials. Synthesizer will not generate samples outside the
//	buffer, but neither will any attempt be made to eliminate clicks at the
//	buffer boundaries.  
	void synthesize( const Partial & p, double timeShift = 0. ) const;	
	
//	function-call operator, for use as a functor:
	void operator() ( const Partial & p, double timeShift = 0. ) const
		{ synthesize( p, timeShift ) ; }

#if !defined(NO_TEMPLATE_MEMBERS)
//	Partial range operations:
	template<typename Iter>
	void synthesize( Iter begin_partials, Iter end_partials, double timeShift = 0. ) const
		{ while ( begin_partials != end_partials ) synthesize( *(begin_partials++), timeShift ); }

	template<typename Iter>
	void operator() ( Iter begin_partials, Iter end_partials, double timeShift = 0. ) const
		{ synthesize( begin_partials, end_partials, timeShift ); }
#endif
	
//	access:
	double sampleRate( void ) const { return _sampleRate; }
	
	double * samples( void ) { return _sampleBuffer; }
	const double * samples( void ) const { return _sampleBuffer; }
	
	long numSamples( void ) const { return _sampleBufferSize; }
</pre>
				
<p><a href="#contents"><small>Contents</small></a>	





<hr align="Center" size="3">    
<table cellspacing="0" cellpadding="1" width="100%">
  <tbody>
	<tr>
	  <td valign="Top">Last updated on 20 May 2002
	  </td>
	  <td align="Right" valign="Top"><a href="http://www.cerlsoundgroup.org/Loris/">www.cerlsoundgroup.org/Loris/</a>
	  </td>
	</tr>       
  </tbody>    

</body>
</html>
