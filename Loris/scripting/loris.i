
/*
 * This is the Loris C++ Class Library, implementing analysis, 
 * manipulation, and synthesis of digitized sounds using the Reassigned 
 * Bandwidth-Enhanced Additive Sound Model.
 *
 * Loris is Copyright (c) 1999-2000 by Kelly Fitz and Lippold Haken
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY, without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 *	loris.i
 *
 *	SWIG interface file supporting the Loris procedural inteface
 *	declared in loris.h. The non-object functions and utility functions
 *	are described in this file, object representations are described 
 *	in their own interface (.i) files.
 *
 *
 * Kelly Fitz, 8 Nov 2000
 * loris@cerlsoundgroup.org
 *
 * http://www.cerlsoundgroup.org/Loris/
 *
 */

#if defined (SWIGPYTHON)
	%title "Python module: loris", noinfo
#else
	%title "Loris scripting interface", noinfo
#endif

%section "Version"

%module loris 

//#if defined (SWIGPYTHON)
//	const char __version__[] =  "Loris 1.0beta2 ";
//#else
	//const char version[] =  "Loris 1.0beta3 ";
	%constant( char * ) version = "Loris 1.0beta3";
//#endif

%{
#define LORIS_OPAQUE_POINTERS 0
#include "loris.h"

#include <string>
#include <vector>

//	convert a string into a vector of doubles,
//	ignore any extraneous characters:
static std::vector<double> strtovec( const std::string & s )
{
    std::vector<double> v;
    std::string::size_type beg, end;
    //const string delims(" \t,[](){}");
    const std::string numparts("1234567890+-.");
    beg = s.find_first_of( numparts );
    while ( beg != std::string::npos )
    {
        end = s.find_first_not_of( numparts, beg );
        if ( end == std::string::npos )
            end = s.length();

        double x = atof( s.c_str() + beg );
        v.push_back(x);

        beg = s.find_first_of( numparts, end );
    }
    return v;
}

//	notification function for Loris exceptions
//	and notifications, installed in initialization
//	block below:
static void printf_notifier( const char * s )
{
	printf("*\t%s\n", s);
}

//	Exceptions absolutely cannot be thrown out of a shared
//	library on the Macintosh, so instead of rethrowing, 
//	store the error string from internal Loris exceptions
//	and catch it in the SWIG exception handler below:
//
//	Loris is no longer a shared library on the Mac, since
//	those are too fragile. Exceptions caught in the procedural
//	interface are still handled with this mechanism, but 
//	when the procedural interface is not used, then bona
//	fide C++ exceptions may make it out to the wrapper code,
//	so Loris::Exceptions and std::exceptions still need to be
//	handled below.
//
static std::string LorisErrorString;
static void throw_string( const char * s )
{
	LorisErrorString = s;
}
%}

//	Initialization:
//
//	Install a notification function using a
//	in a SWIG initialization block.
%init %{
	setNotifier( printf_notifier );
	setExceptionHandler( throw_string );
%}

//	The exception handler specified above stores
//	exceptions reported in Loris in LorisErrorString 
//	This handler will notices those strings, and 
//	reports them as RuntimeErrors.
%include exception.i
%except {
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		$function
		
		//	catch exceptions in the procedural interface, 
		//	converted to strings by the exception handler 
		//	in the Loris procedural interface:
		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( Loris::Exception & ex ) 
	{
		//	catch Loris::Exceptions:
		std::string s("Loris exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::exception & ex ) 
	{
		//	catch std::exceptions:
		//	(these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions.)
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std::strings:
		std::string s("Exception thrown in scripting interface wrapper code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	
}

//	grab the standard typemaps:
%include typemaps.i

%section "Loris class interfaces"

//	include the PartialList class interface:
%include lorisPartialList.i

//	include the Analyzer class interface:
%include lorisAnalyzer.i

//	include the BreakpointEnvelope class interface:
%include lorisBpEnvelope.i

//	include the ExportSpc class interface:
%include lorisExportSpc.i

//	include the SampleVector class interface:
%include lorisSampleVector.i

//	include the AiffFile class interface:
%include lorisAiffFile.i

/* ---------------------------------------------------------------- */
/*		non-object-based procedures
/*
 */
%section "Non-object-based procedures", sort
%text %{
	Operations in Loris that need not be accessed though object
	interfaces are represented as simple functions.
%}

%{
	void channelize_( PartialListHandle * partials, 
					 BreakpointEnvelope * refFreqEnvelope, int refLabel )
	{
		channelize( *partials, refFreqEnvelope, refLabel );
	}
%}
				 
%name(channelize) void channelize_( PartialListHandle * partials, 
				 BreakpointEnvelope * refFreqEnvelope, int refLabel );
/*	Label Partials in a PartialList with the integer nearest to
	the amplitude-weighted average ratio of their frequency envelope
	to a reference frequency envelope. The frequency spectrum is 
	partitioned into non-overlapping channels whose time-varying 
	center frequencies track the reference frequency envelope. 
	The reference label indicates which channel's center frequency
	is exactly equal to the reference envelope frequency, and other
	channels' center frequencies are multiples of the reference 
	envelope frequency divided by the reference label. Each Partial 
	in the PartialList is labeled with the number of the channel
	that best fits its frequency envelope. The quality of the fit
	is evaluated at the breakpoints in the Partial envelope and
	weighted by the amplitude at each breakpoint, so that high-
	amplitude breakpoints contribute more to the channel decision.
	Partials are labeled, but otherwise unmodified. In particular, 
	their frequencies are not modified in any way.
 */

//	dilate() needs to be wrapped by a function that
//	accepts the time points as strings until a language-
//	neutral method can be found for passing a sequence
//	of numbers. This wrapper uses the strtovec() converter
//	defined above to convert two strings into vectors
//	of time points:
%{
void dilate_str( PartialListHandle * partials, 
			 	 char * initial, char * target )
{
	std::vector<double> ivec = strtovec( initial );
	std::vector<double> tvec = strtovec( target );
	
	char s[256];
	sprintf(s, "%d initial points, %d target points",
				(int)ivec.size(), (int)tvec.size() );
	printf_notifier( s );
		
	if ( ivec.size() != tvec.size() )
	{
		std::string s( "Invalid arguments to dilate(): there must be as many target points as initial points" );
		throw s;
	}
			
	dilate( *partials, ivec.begin(), tvec.begin(), ivec.size() );
}
%}
%name(dilate) void dilate_str( PartialListHandle * partials, 
			 				   char * initial_times, char * target_times );
/*	Dilate Partials in a PartialList according to the given 
	initial and target time points. Partial envelopes are 
	stretched and compressed so that temporal features at
	the initial time points are aligned with the final time
	points. Time points are sorted, so Partial envelopes are 
	are only stretched and compressed, but breakpoints are not
	reordered. Duplicate time points are allowed. There must be
	the same number of initial and target time points.
	
	The time points are passed as strings; convert any native
	collection to a string representation, numerical elements
	will be extracted, other characters will be ignored.
 */

%{
	void distill_( PartialListHandle * partials )
	{
		distill( *partials );
	}
%}

%name(distill) void distill_( PartialListHandle * partials );
/*	Distill labeled (channelized)  Partials in a PartialList into a 
	PartialList containing a single (labeled) Partial per label. 
	The distilled PartialList will contain as many Partials as
	there were non-zero labels in the original PartialList. Unlabeled 
	(label 0) Partials are eliminated.
 */

void exportAiff( const char * path, const SampleVector * vec, 
				 double samplerate, int nchannels, int bitsPerSamp );
/*	Export audio samples stored in a SampleVector to an AIFF file
	having the specified number of channels and sample rate at the 
	given file path (or name). The floating point samples in the 
	SampleVector are clamped to the range (-1.,1.) and converted 
	to integers having bitsPerSamp bits.
 */
				 
//	wrapper for exportSdif():
%{
	void exportSdif_( const char * path, PartialListHandle * partials, double hop )
	{
		exportSdif( path, *partials, hop );
	}
%}
%name( exportSdif ) void exportSdif_( const char * path, PartialListHandle * partials, double hop = 0. );
/*	Export Partials in a PartialList to a SDIF file at the specified
	file path (or name). SDIF data is written in the 1TRC format.  
	For more information about SDIF, see the SDIF website at:
		www.ircam.fr/equipes/analyse-synthese/sdif/  
		
	The hop parameter is currently used to specify a time-domain 
	resampling of the Partial envelopes. This parameter is 
	deprecated, and will be removed in future versions, which 
	will have explicit resampling functionality. If hop is 0., 
	Partial envelopes will not be resampled, and all Partial 
	envelope data will be stored.
	
	If unspecified, hop defaults to 0.
 */

//void importAiff( const char * path, SampleVector * vec, 
//				 double * samplerate, int * nchannels );
//
//	It turns out that while SWIG can return a tuple containing
//	the SampleVector pointer, the sample rate, and the number
//	of channels, and it can return an instance of a SampleVector
//	class, it cannot do both at once. That is, it doesn't generate
//	code in the scripting language that converts the first element
//	of the tuple into a class instance.
//
//	That's why there are two functions here, instead of one.
//	
//	Also, this combination of %new and %inline causes the %new
//	to be overlooked, which causes the returned reference to leak.
//%name( importAiff ) %new %inline 
%{
	SampleVector * importAiff_( const char * path )
	{
		double samplerate;
		int nchannels;
		SampleVector * vec = new SampleVector();
		importAiff( path, vec, &samplerate, &nchannels );
		return vec;
	}
%}
%name( importAiff ) %new SampleVector * importAiff_( const char * path );
/*	Import audio samples stored in an AIFF file at the given file
	path (or name). The samples are converted to floating point 
	values on the range (-1.,1.) and returned in a SampleVector, 
	which is sized to (exactly) accomodate all the samples 
	in the file. Use infoAiff( path ) to get the sample rate
	and the number of channels.
 */

//	use a typemap to get the samplerate and number of
//	channels out of infoAiff():
%apply double * OUTPUT { double * samplerate }
%apply int * OUTPUT { int * nchannels }

%inline 
%{
	unsigned long infoAiff( const char * path, double * samplerate, int * nchannels )
	{		
		char s[256];
		sprintf(s, "getting info for %s", path );
		printf_notifier( s );
		
		SampleVector * vec = new SampleVector();
		importAiff( path, vec, samplerate, nchannels );
		return vec->size() / *nchannels;
	}
	/*	Return the number of sample frames, sample rate, and number 
		of channels of audio samples stored in an AIFF file at the 
		given file path (or name). The samples themselves are obtained 
		using importAiff( path ). 
	 */
%}

//	wrapper for importSdif() to return a PartialList:
%{
	PartialListHandle * importSdif_( const char * path )
	{
		PartialListHandle * partials = new PartialListHandle();
		importSdif( path, *partials );
		return partials;
	}
%}
%name( importSdif ) %new PartialListHandle * importSdif_( const char * path );
/*	Import Partials from an SDIF file at the given file path (or 
	name), and return them in a PartialList.
	For more information about SDIF, see the SDIF website at:
		www.ircam.fr/equipes/analyse-synthese/sdif/  
 */	

//	wrapper for morph() to return a PartialList:
%{
	PartialListHandle * morph_( const PartialListHandle * src0, const PartialListHandle * src1, 
						  const BreakpointEnvelope * ffreq, 
						  const BreakpointEnvelope * famp, 
						  const BreakpointEnvelope * fbw )
	{
		
		PartialListHandle * partials = new PartialListHandle();
		morph( *src0, *src1, ffreq, famp, fbw, *partials );
		return partials;
	}
%}
				
%name( morph ) %new PartialListHandle *  
	morph_( const PartialListHandle * src0, const PartialListHandle * src1, 
			const BreakpointEnvelope * ffreq, 
			const BreakpointEnvelope * famp, 
			const BreakpointEnvelope * fbw );
/*	Morph labeled Partials in two PartialLists according to the
	given frequency, amplitude, and bandwidth (noisiness) morphing
	envelopes, and return the morphed Partials in a PartialList. 
	Loris morphs Partials by interpolating frequency, amplitude, 
	and bandwidth envelopes of corresponding Partials in the
	source PartialLists. For more information about the Loris
	morphing algorithm, see the Loris website: 
	www.cerlsoundgroup.org/Loris/
 */

//	wrapper for synthesize to return a SampleVector:
%{
	SampleVector * synthesize_( const PartialListHandle * partials, double srate )
	{
		SampleVector * samples = new SampleVector();
		synthesize( *partials, samples, srate );
		return samples;
	}
%}
%name( synthesize ) %new SampleVector *
	synthesize_( const PartialListHandle * partials, double srate );
/*	Synthesize Partials in a PartialList at the given sample
	rate, and return the (floating point) samples in a SampleVector.
	The SampleVector is sized to hold as many samples as are needed 
	for the complete synthesis of all the Partials in the PartialList. 
 */

/* ---------------------------------------------------------------- */
/*		utility functions
/*
 */
%section "Utility functions", sort
%text %{
	These procedures are generally useful but are not yet  
	represented by classes in the Loris core.
%}

%{
	void copyByLabel_( const PartialListHandle * src, long label, PartialListHandle * dst )
	{
		copyByLabel( *src, label, *dst );
	}
%} 
%name (copyByLabel) 
void copyByLabel_( const PartialListHandle * src, long label, PartialListHandle * dst );
/*	Append copies of Partials in the source PartialList having the
	specified label to the destination PartialList. The source list
	is unmodified.
 */
 
%{
	BreakpointEnvelope *
	createFreqReference_( PartialListHandle * partials, int numSamples,
					 double minFreq, double maxFreq )
	{
		return createFreqReference( *partials, numSamples, minFreq, maxFreq );
	}
%}

%name(createFreqReference) %new BreakpointEnvelope * 
createFreqReference_( PartialListHandle * partials, int numSamples,
					 double minFreq, double maxFreq );
/*	Return a newly-constructed BreakpointEnvelope comprising the
	specified number of samples of the frequency envelope of the
	longest Partial in a PartialList. Only Partials whose frequency
	at the Partial's loudest (highest amplitude) breakpoint is
	within the given frequency range are considered. 
	
	For very simple sounds, this frequency reference may be a 
	good first approximation to a reference envelope for
	channelization (see channelize()).
 */
 
%{
	void scaleAmp_( PartialListHandle * partials, BreakpointEnvelope * ampEnv )
	{
		scaleAmp( *partials, ampEnv );
	}
%}

%name(scaleAmp) void scaleAmp_( PartialListHandle * partials, BreakpointEnvelope * ampEnv );
/*	Scale the amplitude of the Partials in a PartialList according 
	to an envelope representing a time-varying amplitude scale value.
 */
				 
%{
	void scaleNoiseRatio_( PartialListHandle * partials, BreakpointEnvelope * ampEnv )
	{
		scaleNoiseRatio( *partials, ampEnv );
	}
%}

%name(scaleNoiseRatio) void scaleNoiseRatio_( PartialListHandle * partials, BreakpointEnvelope * noiseEnv );
/*	Scale the relative noise content of the Partials in a PartialList 
	according to an envelope representing a (time-varying) noise energy 
	scale value.
 */

%{
	void shiftPitch_( PartialListHandle * partials, BreakpointEnvelope * ampEnv )
	{
		shiftPitch( *partials, ampEnv );
	}
%}

%name(shiftPitch) void shiftPitch_( PartialListHandle * partials, BreakpointEnvelope * pitchEnv );
/*	Shift the pitch of all Partials in a PartialList according to 
	the given pitch envelope. The pitch envelope is assumed to have 
	units of cents (1/100 of a halfstep).
 */
 
 
/*
	EXPERIMENTAL JUNK:
 */

%init %{
	printf_notifier( "loris module includes new experimental junk!\n\n" );
%}

%{
#include "Sieve.h"
%}
	
%inline 
%{
	void sift( PartialListHandle * partials )
	{		
		char s[256];
		sprintf(s, "sifting %d Partials", (*partials)->size() );
		printf_notifier( s );
		
		Loris::Sieve sieve( 0.001 );
		sieve.sift( *partials );
	}
	/*	Lippold's wacky experimental sifting thingie: 
		If any two partials with same label overlap in time,
		keep only the longer of the two partials.
		Set the label of the shorter duration partial to zero.
	 */
%}


