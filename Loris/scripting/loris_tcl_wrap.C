/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3u-20010615-1424 (Alpha 5)
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#       endif
#endif
#else
#       define SWIGEXPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct swig_type_info {
  char  *name;                 
  void *(*converter)(void *);
  char  *str;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE
SWIGEXPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGEXPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGEXPORT(void *) SWIG_TypeCast(swig_type_info *, void *);
#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  while (s) {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  }
  return 0;
}

/* Cast a pointer (needed for C++ inheritance */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(void *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

#endif

#ifdef __cplusplus
}
#endif



/*
 * $Header$
 * 
 * swigtcl8.swg
 */

#include <tcl.h>
#include <stdlib.h>
#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SWIG_NOINCLUDE
SWIGEXPORT(int) SWIG_ConvertPtrFromString(Tcl_Interp *, char *, void **, swig_type_info *);
SWIGEXPORT(int) SWIG_ConvertPtr(Tcl_Interp *, Tcl_Obj *, void **, swig_type_info *);
SWIGEXPORT(void) SWIG_MakePtr(char *, void *, swig_type_info *);
SWIGEXPORT(Tcl_Obj *) SWIG_NewPointerObj(void *, swig_type_info *);
SWIGEXPORT(int) SWIG_GetArgs(Tcl_Interp *, int, Tcl_Obj *CONST [], const char *, ...);
SWIGEXPORT(char *) SWIG_PointerTypeFromString(char *c);
#else

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtrFromString(Tcl_Interp *interp, char *c, void **ptr, swig_type_info *ty)
{
  unsigned long p;
  register int d;
  swig_type_info *tc;
  p = 0;
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) return TCL_OK;
    Tcl_SetResult(interp,"Type error. Expected a pointer", TCL_STATIC);
    return TCL_ERROR;
  }
  c++;
  /* Extract hex value from pointer */
  while ((d = *c)) {
    if ((d >= '0') && (d <= '9'))
      p = (p << 4) + (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      p = (p << 4) + (d - ('a'-10));
    else
      break; 
    c++;
  }
  *ptr = (void *) p;
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) {
      Tcl_SetResult(interp,"Type error. Expected ", TCL_STATIC);
      Tcl_AppendElement(interp, ty->name);
      return TCL_ERROR;
    }
    *ptr = SWIG_TypeCast(tc,(void *)p);
  }
  return TCL_OK;
}


/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtr(Tcl_Interp *interp, Tcl_Obj *oc, void **ptr, swig_type_info *ty)
{
  return SWIG_ConvertPtrFromString(interp, Tcl_GetStringFromObj(oc,NULL), ptr, ty);
}


/* Convert a pointer value */
SWIGRUNTIME(char *)
SWIG_PointerTypeFromString(char *c) {
  char d;
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    return 0;
  }
  c++;
  /* Extract hex value from pointer */
  while (d = *c) {
    if (!(((d >= '0') && (d <= '9')) || ((d >= 'a') && (d <= 'f')))) break;
    c++;
  }
  return c;
}

/* Take a pointer and convert it to a string */
SWIGRUNTIME(void) 
SWIG_MakePtr(char *c, void *ptr, swig_type_info *ty) {
  static char hex[17] = "0123456789abcdef";
  unsigned long p, s;
  char result[24], *r; 
  r = result;
  p = (unsigned long) ptr;
  if (p > 0) {
    while (p > 0) {
      s = p & 0xf;
      *(r++) = hex[s];
      p = p >> 4;
    }
    *r = '_';
    while (r >= result)
      *(c++) = *(r--);
    strcpy (c, ty->name);
  } else {
    strcpy (c, "NULL");
  }
}

/* Create a new pointer object */
SWIGRUNTIME(Tcl_Obj *)
SWIG_NewPointerObj(void *ptr, swig_type_info *type) {
  char result[256];
  Tcl_Obj *robj;
  SWIG_MakePtr(result,ptr,type);
  robj = Tcl_NewStringObj(result,-1);
  return robj;
}

/* Get arguments */
SWIGRUNTIME(int)
SWIG_GetArgs(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], const char *fmt, ...)
{
  int        argno = 0, opt = 0, tempi;
  int        us = 0;
  double     tempd;
  const char *c;
  va_list    ap;
  void      *vptr;
  swig_type_info *ty;

  va_start(ap,fmt);
  for (c = fmt; (*c && (*c != ':')); c++,argno++) {
    if (*c == '|') {
      opt = 1;
      c++;
    }
    if (argno >= (objc-1)) {
      if (!opt) {
	Tcl_SetResult(interp,"Wrong # args. ", TCL_STATIC);
	goto argerror;
      } else {
	va_end(ap);
	return TCL_OK;
      }
    }
    vptr = va_arg(ap,void *);
    if (vptr) {
      us = 0;
      if (*c == 'u') {
	us = 1;
	c++;
      }
      switch(*c) {
      case 'i':
      case 'l':
      case 'h':
      case 'b':
	if (Tcl_GetIntFromObj(interp,objv[argno+1],&tempi) != TCL_OK) goto argerror;
	if (*c == 'i') *((int *)vptr) = tempi;
	else if (*c == 'l') *((long *)vptr) = tempi;
	else if (*c == 'h') *((short*)vptr) = tempi;
	else if (*c == 'b') *((unsigned char *)vptr) = tempi;
	break;
      case 'f':
      case 'd':
	if (Tcl_GetDoubleFromObj(interp,objv[argno+1],&tempd) != TCL_OK) goto argerror;
	if (*c == 'f') *((float *) vptr) = tempd;
	else if (*c == 'd') *((double*) vptr) = tempd;
	break;
      case 's':
	if (*(c+1) == '#') {
	  int *vlptr = (int *) va_arg(ap, void *);
	  *((char **) vptr) = Tcl_GetStringFromObj(objv[argno+1], vlptr);
	  c++;
	} else {
	  *((char **)vptr) = Tcl_GetStringFromObj(objv[argno+1],NULL);
	}
	break;
      case 'c':
	*((char *)vptr) = *(Tcl_GetStringFromObj(objv[argno+1],NULL));
	break;
      case 'p':
	ty = (swig_type_info *) va_arg(ap, void *);
	if (SWIG_ConvertPtr(interp, objv[argno+1], (void **) vptr, ty) == TCL_ERROR) goto argerror;
	break;
      case 'o':
	*((Tcl_Obj **)vptr) = objv[argno+1];
	break;
      default:
	break;
      }
    }
  }
  if ((objc-1) > argno) {
    Tcl_SetResult(interp,"Wrong # args.", TCL_STATIC);
    goto argerror;
  }
  va_end(ap);
  return TCL_OK;
  
 argerror:
  {
    char temp[32];
    sprintf(temp,"%d", argno);
    Tcl_AppendResult(interp,strchr(fmt,':'), " argument ", temp, NULL);
    va_end(ap);
    return TCL_ERROR;
  }
}

#endif

/* Structure for command table */
typedef struct {
  const char *name;
  int       (*wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
  ClientData  clientdata;
} swig_command_info;

/* Structure for variable linking table */
typedef struct {
  const char *name;
  void *addr;
  char * (*get)(ClientData, Tcl_Interp *, char *, char *, int);
  char * (*set)(ClientData, Tcl_Interp *, char *, char *, int);
} swig_var_info;


#ifdef __cplusplus
}
#endif


/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_Partial swig_types[0] 
#define  SWIGTYPE_p_PartialList swig_types[1] 
#define  SWIGTYPE_p_SampleVector swig_types[2] 
#define  SWIGTYPE_p_AiffFile swig_types[3] 
#define  SWIGTYPE_p_Analyzer swig_types[4] 
#define  SWIGTYPE_p_PartialListIterator swig_types[5] 
#define  SWIGTYPE_p_PartialIterator swig_types[6] 
#define  SWIGTYPE_p_Breakpoint swig_types[7] 
#define  SWIGTYPE_p_BreakpointEnvelope swig_types[8] 
static swig_type_info *swig_types[10];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Loris_Init
#define SWIG_name    "loris"
#define SWIG_prefix  ""
#define SWIG_namespace ""

#ifdef __cplusplus
extern "C" {
#endif
#ifdef MAC_TCL
#pragma export on
#endif
SWIGEXPORT(int) Loris_Init(Tcl_Interp *);
#ifdef MAC_TCL
#pragma export off
#endif
#ifdef __cplusplus
}
#endif

	#include<Notifier.h>
	#include<Exception.h>
	#include <string>
	
	//	notification function for Loris debugging
	//	and notifications, installed in initialization
	//	block below:
	static void printf_notifier( const char * s )
	{
		printf("*\t%s\n", s);
	}	
	
	//	class NullPointer
	//
	//	Define a Loris::Exception subclass for catching NULL pointers.
	//	This is copied from lorisException_pi.h. It could be in Loris,
	//	but probably was never needed because Loris doesn't make much 
	//	use of pointers.
	//
	class NullPointer : public Loris::Exception
	{
	public: 
		NullPointer( const std::string & str, const std::string & where = "" ) : 
			Exception( std::string("NULL pointer exception -- ").append( str ), where ) {}
	};	//	end of class NullPointer
	
	//	define a macro for testing and throwing:
	#define ThrowIfNull(ptr) if ((ptr)==NULL) Throw( NullPointer, #ptr );	

#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99

#define SWIG_exception(a,b)   { Tcl_SetResult(interp,b,TCL_VOLATILE); return TCL_ERROR; }

#include<Partial.h>
#include<Notifier.h>
#include <list>

using Loris::debugger;
using Loris::Partial;
using Loris::Breakpoint;

//	define the names of the classes that are 
//	wrapped by this interface file:
//	(additionally Partial and Breakpoint)
typedef std::list< Loris::Partial > PartialList;
typedef std::list< Loris::Partial >::iterator PartialListIterator;
typedef Loris::Partial::iterator PartialIterator;


#include<Analyzer.h>
#include<Partial.h>

using Loris::Analyzer;

#include<BreakpointEnvelope.h>
using Loris::BreakpointEnvelope;

BreakpointEnvelope * BreakpointEnvelopeWithValue_( double initialValue )
{
	return new BreakpointEnvelope( initialValue );
}

#include <stdexcept>
#include <vector>
typedef std::vector< double > SampleVector;

#include<AiffFile.h>
using Loris::AiffFile;

	#include<Channelizer.h>

	void channelize( PartialList * partials, 
					 BreakpointEnvelope * refFreqEnvelope, int refLabel )
	{
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((BreakpointEnvelope *) refFreqEnvelope);
	
		if ( refLabel <= 0 )
			Throw( Loris::InvalidArgument, "Channelization reference label must be positive." );
		
		Loris::notifier << "channelizing " << partials->size() << " Partials" << Loris::endl;
	
		Loris::Channelizer chan( *refFreqEnvelope, refLabel );
		chan.channelize( partials->begin(), partials->end() );		
	
	}
	/*	Label Partials in a PartialList with the integer nearest to
		the amplitude-weighted average ratio of their frequency envelope
		to a reference frequency envelope. The frequency spectrum is 
		partitioned into non-overlapping channels whose time-varying 
		center frequencies track the reference frequency envelope. 
		The reference label indicates which channel's center frequency
		is exactly equal to the reference envelope frequency, and other
		channels' center frequencies are multiples of the reference 
		envelope frequency divided by the reference label. Each Partial 
		in the PartialList is labeled with the number of the channel
		that best fits its frequency envelope. The quality of the fit
		is evaluated at the breakpoints in the Partial envelope and
		weighted by the amplitude at each breakpoint, so that high-
		amplitude breakpoints contribute more to the channel decision.
		Partials are labeled, but otherwise unmodified. In particular, 
		their frequencies are not modified in any way.
	 */

	#include<Dilator.h>
	#include <string>
	#include <vector>
	
	//	Helper function for dilate: 
	//
	//	convert a string into a vector of doubles,
	//	ignore any extraneous characters:
	static std::vector<double> strtovec( const std::string & s )
	{
		std::vector<double> v;
		std::string::size_type beg, end;
		const std::string numparts("1234567890+-.");
		beg = s.find_first_of( numparts );
		while ( beg != std::string::npos )
		{
			end = s.find_first_not_of( numparts, beg );
			if ( end == std::string::npos )
				end = s.length();
	
			double x = atof( s.c_str() + beg );
			v.push_back(x);
	
			beg = s.find_first_of( numparts, end );
		}
		return v;
	}

	void dilate( PartialList * partials, 
				 char * initial_times, char * target_times )
	{
		std::vector<double> ivec = strtovec( initial_times );
		std::vector<double> tvec = strtovec( target_times );
		
		Loris::debugger << ivec.size() << " initial points, " 
						<< tvec.size() << " target points" << Loris::endl;
			
		if ( ivec.size() != tvec.size() )
			Throw( Loris::InvalidArgument, "Invalid arguments to dilate(): there must be as many target points as initial points" );
				
		double * initial = ivec.begin();
		double * target = tvec.begin();
		int npts = ivec.size();
	
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((double *) initial);
		ThrowIfNull((double *) target);
	
		Loris::notifier << "dilating " << partials->size() << " Partials" << Loris::endl;
		Loris::Dilator dil( initial, target, npts );
		dil.dilate( partials->begin(), partials->end() );
	}
	/*	Dilate Partials in a PartialList according to the given 
		initial and target time points. Partial envelopes are 
		stretched and compressed so that temporal features at
		the initial time points are aligned with the final time
		points. Time points are sorted, so Partial envelopes are 
		are only stretched and compressed, but breakpoints are not
		reordered. Duplicate time points are allowed. There must be
		the same number of initial and target time points.
		
		The time points are passed as strings; convert any native
		collection to a string representation, numerical elements
		will be extracted, other characters will be ignored.
	 */

	#include<Distiller.h>

void distill( PartialList * partials )
	{
		ThrowIfNull((PartialList *) partials);
	
		Loris::notifier << "distilling " << partials->size() << " Partials" << Loris::endl;
		Loris::Distiller still;
		still.distill( *partials );
		
	}
	/*	Distill labeled (channelized)  Partials in a PartialList into a 
		PartialList containing a single (labeled) Partial per label. 
		The distilled PartialList will contain as many Partials as
		there were non-zero labels in the original PartialList. Unlabeled 
		(label 0) Partials are eliminated.
	 */

	#include<AiffFile.h>

	void exportAiff( const char * path,
					 SampleVector * samples,
					 double samplerate, int nchannels, int bitsPerSamp )
	{		
		Loris::AiffFile::Export( path, samplerate, nchannels, bitsPerSamp, 
								 samples->begin(), samples->end() );
	}
	/*	Export audio samples stored in a SampleVector to an AIFF file
		having the specified number of channels and sample rate at the 
		given file path (or name). The floating point samples in the 
		SampleVector are clamped to the range (-1.,1.) and converted 
		to integers having bitsPerSamp bits.
	 */
				 

	//	stupid name for sdif file header, name collision
	#include<SdifFile.h>

	void exportSdif( const char * path, PartialList * partials )
	{
		ThrowIfNull((PartialList *) partials);

		if ( partials->size() == 0 ) 
			Throw( Loris::InvalidObject, "No Partials in PartialList to export to sdif file." );
	
		Loris::notifier << "exporting sdif partial data to " << path << Loris::endl;		
		Loris::SdifFile::Export( path, *partials );
		
	}
	/*	Export Partials in a PartialList to a SDIF file at the specified
		file path (or name). SDIF data is written in the 1TRC format.  
		For more information about SDIF, see the SDIF website at:
			www.ircam.fr/equipes/analyse-synthese/sdif/  
	 */

	#include<SpcFile.h>

	void exportSpc( const char * path, PartialList * partials, double midiPitch, 
					int enhanced = true, double endApproachTime = 0. )
	{
		ThrowIfNull((PartialList *) partials);

		if ( partials->size() == 0 )
			Throw( Loris::InvalidObject, "No Partials in PartialList to export to Spc file." );

		Loris::notifier << "exporting Spc partial data to " << path << Loris::endl;
		Loris::SpcFile::Export( path, *partials, midiPitch, enhanced, endApproachTime );
	}
	/*	Export Partials in a PartialList to a Spc file at the specified file
		path (or name). The fractional MIDI pitch must be specified. The optional
		enhanced parameter defaults to true (for bandwidth-enhanced spc files), 
		but an be specified false for pure-sines spc files. The optional 
		endApproachTime parameter is in seconds; its default value is zero (and 
		has no effect). A nonzero endApproachTime indicates that the plist does 
		not include a release, but rather ends in a static spectrum corresponding 
		to the final breakpoint values of the partials. The endApproachTime
		specifies how long before the end of the sound the amplitude, frequency, 
		and bandwidth values are to be modified to make a gradual transition to 
		the static spectrum.
	 */

	#include<SdifFile.h>
	PartialList * importSdif( const char * path )
	{
		Loris::notifier << "importing Partials from " << path << Loris::endl;
		Loris::SdifFile imp( path );

		PartialList * partials = new PartialList();
		//	splice() can't throw, can it???
		partials->splice( partials->end(), imp.partials() );

		return partials;
	}

	#include<SpcFile.h>
	PartialList * importSpc( const char * path )
	{
		Loris::notifier << "importing Partials from " << path << Loris::endl;
		Loris::SpcFile imp( path );

		PartialList * partials = new PartialList();
		//	splice() can't throw, can it???
		partials->splice( partials->end(), imp.partials() );

		return partials;
	}

	#include<Morpher.h>
	PartialList * morph( const PartialList * src0, const PartialList * src1, 
						 const BreakpointEnvelope * ffreq, 
						 const BreakpointEnvelope * famp, 
						 const BreakpointEnvelope * fbw )
	{
		ThrowIfNull((PartialList *) src0);
		ThrowIfNull((PartialList *) src1);
		ThrowIfNull((BreakpointEnvelope *) ffreq);
		ThrowIfNull((BreakpointEnvelope *) famp);
		ThrowIfNull((BreakpointEnvelope *) fbw);

		Loris::notifier << "morphing " << src0->size() << " Partials with "
						<< src1->size() << " Partials" << Loris::endl;
					
		//	make a Morpher object and do it:
		Loris::Morpher m( *ffreq, *famp, *fbw );
		m.morph( src0->begin(), src0->end(), src1->begin(), src1->end() );
				
		//	splice the morphed Partials into a new PartialList:
		PartialList * dst = new PartialList();
		//	splice() can't throw, can it???
		dst->splice( dst->end(), m.partials() );
		return dst;
	}

	#include<Synthesizer.h>
	SampleVector * synthesize( const PartialList * partials, double srate )
	{
		ThrowIfNull((PartialList *) partials);

		Loris::notifier << "synthesizing " << partials->size() 
						<< " Partials at " << srate << " Hz" << Loris::endl;

		//	compute the duration:
		debugger << "computing duration..." << Loris::endl;
		double maxtime = 0.;
		PartialList::const_iterator it;
		for ( it = partials->begin(); it != partials->end(); ++it ) 
		{
			maxtime = std::max( maxtime, it->endTime() );
		}
		debugger << maxtime << " seconds" << Loris::endl;
		
		//	allocate a SampleVector to accomodate the fade-out at 
		//	the end of the latest Partial:
		const long nsamps = long( srate * ( maxtime + Partial::FadeTime() ) );	
		SampleVector * samples = new SampleVector( nsamps, 0. );
		
		//	synthesize:
		try
		{
			Loris::Synthesizer synth( srate, samples->begin(), samples->end() );
			for ( it = partials->begin(); it != partials->end(); ++it ) 
			{
				synth.synthesize( *it );
			}
		}
		catch(...)
		{
			delete samples;
			throw;
		}
		
		return samples;
	}

	#include<Sieve.h>

	void sift( PartialList * partials )
	{		
		
		ThrowIfNull((PartialList *) partials);

		Loris::notifier << "sifting " << partials->size() << " Partials" << Loris::endl;
		
		Loris::Sieve sieve( 0.0001 );
		sieve.sift( *partials );
	}
	/*	Lippold's wacky experimental sifting thingie: 
		If any two partials with same label overlap in time,
		keep only the longer of the two partials.
		Set the label of the shorter duration partial to zero.
		
		This used to be "experimental," and is now just 
		"transitional."
	 */

	#include <memory> 	//	 for auto_ptr
	
	BreakpointEnvelope * 
	createFreqReference( PartialList * partials, int numSamples,
						 double minFreq, double maxFreq )
	{
		ThrowIfNull((PartialList *) partials);
		
		if ( numSamples <= 0 )
			Throw( Loris::InvalidArgument, "number of samples in frequency reference must be positive." );
		
		if ( maxFreq < minFreq )
			std::swap( minFreq, maxFreq );
			
		//	find the longest Partial in the given frequency range:
		PartialList::iterator longest = partials->end();
		for ( PartialList::iterator it = partials->begin(); 
			  it != partials->end(); 
			  ++it ) 
		{
			//	evaluate the Partial's frequency at its loudest
			//	(highest sinusoidal amplitude) Breakpoint:
			Partial::const_iterator partialIter = it->begin();
			double maxAmp = 
				partialIter.breakpoint().amplitude() * std::sqrt( 1. - partialIter.breakpoint().bandwidth() );
			double time = partialIter.time();
			
			for ( ++partialIter; partialIter != it->end(); ++partialIter ) 
			{
				double a = partialIter.breakpoint().amplitude() * 
							std::sqrt( 1. - partialIter.breakpoint().bandwidth() );
				if ( a > maxAmp ) 
				{
					maxAmp = a;
					time = partialIter.time();
				}
			}			
			double compareFreq = it->frequencyAt( time );
			
			
			if ( compareFreq < minFreq || compareFreq > maxFreq )
				continue;
				
			if ( longest == partials->end() || it->duration() > longest->duration() ) 
			{
				longest = it;
			}
		}	
		
		if ( longest == partials->end() ) 
		{
			Throw( Loris::InvalidArgument, "no partials found in the specified frequency range" );
		}
	
		//	use auto_ptr to manage memory in case 
		//	an exception is generated (hard to imagine):
		std::auto_ptr< BreakpointEnvelope > env_ptr( new BreakpointEnvelope() );

		//	find n samples, ignoring the end points:
		double dt = longest->duration() / (numSamples + 1.);
		for ( int i = 0; i < numSamples; ++i ) 
		{
			double t = longest->startTime() + ((i+1) * dt);
			double f = longest->frequencyAt(t);
			env_ptr->insertBreakpoint( t, f );
		}
		
		return env_ptr.release();
	}

	#include <cmath>

	void scaleAmp( PartialList * partials, BreakpointEnvelope * ampEnv )
	{
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((BreakpointEnvelope *) ampEnv);

		Loris::notifier << "scaling amplitude of " << partials->size() << " Partials" << Loris::endl;

		PartialList::iterator listPos;
		for ( listPos = partials->begin(); listPos != partials->end(); ++listPos ) 
		{
			PartialIterator envPos;
			for ( envPos = listPos->begin(); envPos != listPos->end(); ++envPos ) 
			{		
				envPos.breakpoint().setAmplitude( envPos.breakpoint().amplitude() * ampEnv->valueAt(envPos.time()) );
			}
		}	
	}
	/*	Scale the amplitude of the Partials in a PartialList according 
		to an envelope representing a time-varying amplitude scale value.
	 */

	void scaleNoiseRatio( PartialList * partials, BreakpointEnvelope * noiseEnv )
	{
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((BreakpointEnvelope *) noiseEnv);

		Loris::notifier << "scaling noise ratio of " << partials->size() << " Partials" << Loris::endl;

		PartialList::iterator listPos;
		for ( listPos = partials->begin(); listPos != partials->end(); ++listPos ) 
		{
			PartialIterator envPos;
			for ( envPos = listPos->begin(); envPos != listPos->end(); ++envPos ) 
			{		
				//	compute new bandwidth value:
				double bw = envPos.breakpoint().bandwidth();
				if ( bw < 1. ) 
				{
					double ratio = bw  / (1. - bw);
					ratio *= noiseEnv->valueAt(envPos.time());
					bw = ratio / (1. + ratio);
				}
				else 
				{
					bw = 1.;
				}
				
				envPos.breakpoint().setBandwidth( bw );
			}
		}	
	}
	/*	Scale the relative noise content of the Partials in a PartialList 
		according to an envelope representing a (time-varying) noise energy 
		scale value.
	 */

	void shiftPitch( PartialList * partials, BreakpointEnvelope * pitchEnv )
	{
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((BreakpointEnvelope *) pitchEnv);

		Loris::notifier << "shifting pitch of " << partials->size() << " Partials" << Loris::endl;
		
		PartialList::iterator listPos;
		for ( listPos = partials->begin(); listPos != partials->end(); ++listPos ) 
		{
			PartialIterator envPos;
			for ( envPos = listPos->begin(); envPos != listPos->end(); ++envPos ) 
			{		
				//	compute frequency scale:
				double scale = 
					std::pow(2., (0.01 * pitchEnv->valueAt(envPos.time())) /12.);				
				envPos.breakpoint().setFrequency( envPos.breakpoint().frequency() * scale );
			}
		}	
	}
	/*	Shift the pitch of all Partials in a PartialList according to 
		the given pitch envelope. The pitch envelope is assumed to have 
		units of cents (1/100 of a halfstep).
	 */
/* object.swg
 *
 * Tcl8.x - Object oriented runtime functions
 */

typedef int (*swig_wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);

typedef struct swig_method { 
  const char     *name;
  swig_wrapper   method;
} swig_method;

typedef struct swig_attribute {
  const char     *name;
  swig_wrapper   getmethod;
  swig_wrapper   setmethod;
} swig_attribute;
  
typedef struct swig_class {
  const char        *name;
  swig_type_info  **type;
  swig_wrapper      constructor;
  void             (*destructor)(void *);
  swig_method      *methods;
  swig_attribute   *attributes;
} swig_class;

typedef struct swig_instance {
  Tcl_Obj       *thisptr;
  void          *thisvalue;
  swig_class   *classptr;
  int            destroy;
} swig_instance;

static void SwigObjectDelete(ClientData clientData) {
  swig_instance *si = (swig_instance *) clientData;
  if (si->destroy) {
    if (si->classptr->destructor) {
      (si->classptr->destructor)(si->thisvalue);
    }
  }
  Tcl_DecrRefCount(si->thisptr);
  free(si);
}

/* Function to invoke object methods given an instance */
static int
SwigMethodCmd(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST _objv[])
{
  char *method, *attrname;
  swig_instance  *inst = (swig_instance *) clientData;
  swig_method    *meth;
  swig_attribute *attr;
  Tcl_Obj         *oldarg;
  Tcl_Obj         **objv;
  int              rcode;

  objv = (Tcl_Obj **) _objv;
  if (objc < 2) {
    Tcl_SetResult(interp,"wrong # args.", TCL_STATIC);
    return TCL_ERROR;
  }
  meth = inst->classptr->methods;
  method = Tcl_GetStringFromObj(objv[1],NULL);

  /* Check for methods */
  while (meth && meth->name) {
    if (strcmp(meth->name,method) == 0) {
      oldarg = objv[1];
      objv[1] = inst->thisptr;
      Tcl_IncrRefCount(inst->thisptr);
      rcode = (*meth->method)(clientData,interp,objc,objv);
      objv[1] = oldarg;
      Tcl_DecrRefCount(inst->thisptr);
      return rcode;
    }
    meth++;
  }
  /* Check class methods for a match */
  if (strcmp(method,"cget") == 0) {
    if (objc < 3) {
      Tcl_SetResult(interp,"wrong # args.", TCL_STATIC);
      return TCL_ERROR;
    }
    attrname = Tcl_GetStringFromObj(objv[2],NULL);
    attr = inst->classptr->attributes;
    while (attr && attr->name) {
      if ((strcmp(attr->name, attrname) == 0) && (attr->getmethod)) {
	oldarg = objv[1];
	objv[1] = inst->thisptr;
	Tcl_IncrRefCount(inst->thisptr);
	rcode = (*attr->getmethod)(clientData,interp,2, objv);
	objv[1] = oldarg;
	Tcl_DecrRefCount(inst->thisptr);
	return rcode;
      }
      attr++;
    }
    if (strcmp(attrname, "-this") == 0) {
      Tcl_SetObjResult(interp, Tcl_DuplicateObj(inst->thisptr));
      return TCL_OK;
    }
    Tcl_SetResult(interp,"Invalid attribute.", TCL_STATIC);
    return TCL_ERROR;
  } else if (strcmp(method, "configure") == 0) {
    int i;
    if (objc < 4) {
      Tcl_SetResult(interp,"wrong # args.", TCL_STATIC);
      return TCL_ERROR;
    }
    i = 2;
    while (i < objc) {
      attrname = Tcl_GetStringFromObj(objv[i],NULL);
      attr = inst->classptr->attributes;
      while (attr && attr->name) {
	if ((strcmp(attr->name, attrname) == 0) && (attr->setmethod)) {
	  oldarg = objv[i];
	  objv[i] = inst->thisptr;
	  Tcl_IncrRefCount(inst->thisptr);
	  rcode = (*attr->setmethod)(clientData,interp,3, &objv[i-1]);
	  objv[i] = oldarg;
	  Tcl_DecrRefCount(inst->thisptr);
	  if (rcode != TCL_OK) return rcode;
	  i+=2;
	  break;
	}
	attr++;
      }
      if (inst->classptr->attributes && !(attr->name)) {
	Tcl_SetResult(interp,"Invalid attribute name.", TCL_STATIC);
	return TCL_ERROR;
      }
    }
    return TCL_OK;
  } else {
    Tcl_SetResult(interp,"Invalid method. Must be one of: configure cget ", TCL_STATIC);
    meth = inst->classptr->methods;
    while (meth && meth->name) {
      Tcl_AppendElement(interp, meth->name);
      meth++;
    }
    return TCL_ERROR;
  }

  
}

/* Function to create objects */
static int 
SwigObjectCmd(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
    Tcl_Obj          *newObj = 0;
    void             *thisvalue = 0;
    swig_instance   *newinst = 0;
    swig_class      *classptr = (swig_class *) clientData;
    swig_wrapper     cons = 0;
    char             *name = 0;
    int               firstarg = 0;
    int               thisarg = 0;
    int               destroy = 1; 
    Tcl_CmdInfo       ci;

    if (!classptr) {
      Tcl_SetResult(interp,"swig: internal runtime error. No class object defined.", TCL_STATIC);
      return TCL_ERROR;
    }
    cons = classptr->constructor;
    if (objc > 1) {
      char *s = Tcl_GetStringFromObj(objv[1],NULL);
      if (strcmp(s,"-this") == 0) {
	thisarg = 2;
	cons = 0;
      } else if (strcmp(s,"-args") == 0) {
	firstarg = 1;
      } else if (objc == 2) {
	firstarg = 1;
	name = s;
      } else if (objc >= 3) {
	char *s1;
	name = s;
	s1 = Tcl_GetStringFromObj(objv[2],NULL);
	if (strcmp(s1,"-this") == 0) {
	  thisarg = 3;
	  cons = 0;
	} else {
	  firstarg = 1;
	}
      }
    }
    if (cons) {
      int result;
      result = (*cons)(0, interp, objc-firstarg, &objv[firstarg]);
      if (result != TCL_OK) {
	return result;
      }
      newObj = Tcl_DuplicateObj(Tcl_GetObjResult(interp));
      if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
    } else if (thisarg > 0) {
      if (thisarg < objc) {
	destroy = 0;
	newObj = Tcl_DuplicateObj(objv[thisarg]);
	if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
      } else {
	Tcl_SetResult(interp,"wrong # args.", TCL_STATIC);
	return TCL_ERROR;
      }
    } else {
      Tcl_SetResult(interp,"No constructor available.", TCL_STATIC);
      return TCL_ERROR;
    }
    if (!Tcl_GetCommandInfo(interp,name,&ci)) {
      if (SWIG_ConvertPtr(interp,newObj, (void **) &thisvalue, *(classptr->type)) == TCL_ERROR) {
	Tcl_DecrRefCount(newObj);
	return TCL_ERROR;
      }
      newinst = (swig_instance *) malloc(sizeof(swig_instance));
      newinst->thisptr = newObj;
      Tcl_IncrRefCount(newObj);
      newinst->thisvalue = thisvalue;
      newinst->classptr = classptr;
      newinst->destroy = destroy;
      Tcl_CreateObjCommand(interp,name, SwigMethodCmd, (ClientData) newinst, SwigObjectDelete);
      return TCL_OK;
    } else {
      Tcl_SetResult(interp,"Object name already exists!", TCL_STATIC);
      return TCL_ERROR;
    }
}

static int
_wrap_BreakpointEnvelopeWithValue(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    double arg0 ;
    BreakpointEnvelope *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"d:BreakpointEnvelopeWithValue initialValue ",&arg0) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelopeWithValue_(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_BreakpointEnvelope));
    return TCL_OK;
}

static int
_wrap_channelize(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    BreakpointEnvelope *arg1 ;
    int arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ppi:channelize partials refFreqEnvelope refLabel ",&arg0, SWIGTYPE_p_PartialList,&arg1, SWIGTYPE_p_BreakpointEnvelope,&arg2) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            channelize(arg0,arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_dilate(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    char *arg1 ;
    char *arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pss:dilate partials initial_times target_times ",&arg0, SWIGTYPE_p_PartialList,&arg1,&arg2) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            dilate(arg0,arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_distill(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:distill partials ",&arg0, SWIGTYPE_p_PartialList) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            distill(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_exportAiff(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg0 ;
    SampleVector *arg1 ;
    double arg2 ;
    int arg3 ;
    int arg4 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"spdii:exportAiff path samples samplerate nchannels bitsPerSamp ",&arg0,&arg1, SWIGTYPE_p_SampleVector,&arg2,&arg3,&arg4) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            exportAiff((char const *)arg0,arg1,arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_exportSdif(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg0 ;
    PartialList *arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"sp:exportSdif path partials ",&arg0,&arg1, SWIGTYPE_p_PartialList) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            exportSdif((char const *)arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_exportSpc(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg0 ;
    PartialList *arg1 ;
    double arg2 ;
    int arg3 = true ;
    double arg4 = 0. ;
    
    if (SWIG_GetArgs(interp, objc, objv,"spd|id:exportSpc path partials midiPitch ?enhanced? ?endApproachTime? ",&arg0,&arg1, SWIGTYPE_p_PartialList,&arg2,&arg3,&arg4) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            exportSpc((char const *)arg0,arg1,arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_importSdif(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg0 ;
    PartialList *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"s:importSdif path ",&arg0) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (PartialList *)importSdif((char const *)arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialList));
    return TCL_OK;
}

static int
_wrap_importSpc(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg0 ;
    PartialList *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"s:importSpc path ",&arg0) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (PartialList *)importSpc((char const *)arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialList));
    return TCL_OK;
}

static int
_wrap_morph(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    PartialList *arg1 ;
    BreakpointEnvelope *arg2 ;
    BreakpointEnvelope *arg3 ;
    BreakpointEnvelope *arg4 ;
    PartialList *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ppppp:morph src0 src1 ffreq famp fbw ",&arg0, SWIGTYPE_p_PartialList,&arg1, SWIGTYPE_p_PartialList,&arg2, SWIGTYPE_p_BreakpointEnvelope,&arg3, SWIGTYPE_p_BreakpointEnvelope,&arg4, SWIGTYPE_p_BreakpointEnvelope) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (PartialList *)morph((PartialList const *)arg0,(PartialList const *)arg1,(BreakpointEnvelope const *)arg2,(BreakpointEnvelope const *)arg3,(BreakpointEnvelope const *)arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialList));
    return TCL_OK;
}

static int
_wrap_synthesize(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    double arg1 ;
    SampleVector *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:synthesize partials srate ",&arg0, SWIGTYPE_p_PartialList,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (SampleVector *)synthesize((PartialList const *)arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_SampleVector));
    return TCL_OK;
}

static int
_wrap_sift(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:sift partials ",&arg0, SWIGTYPE_p_PartialList) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            sift(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_createFreqReference(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    int arg1 ;
    double arg2 ;
    double arg3 ;
    BreakpointEnvelope *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pidd:createFreqReference partials numSamples minFreq maxFreq ",&arg0, SWIGTYPE_p_PartialList,&arg1,&arg2,&arg3) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (BreakpointEnvelope *)createFreqReference(arg0,arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_BreakpointEnvelope));
    return TCL_OK;
}

static int
_wrap_scaleAmp(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    BreakpointEnvelope *arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:scaleAmp partials ampEnv ",&arg0, SWIGTYPE_p_PartialList,&arg1, SWIGTYPE_p_BreakpointEnvelope) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            scaleAmp(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_scaleNoiseRatio(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    BreakpointEnvelope *arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:scaleNoiseRatio partials noiseEnv ",&arg0, SWIGTYPE_p_PartialList,&arg1, SWIGTYPE_p_BreakpointEnvelope) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            scaleNoiseRatio(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_shiftPitch(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    BreakpointEnvelope *arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:shiftPitch partials pitchEnv ",&arg0, SWIGTYPE_p_PartialList,&arg1, SWIGTYPE_p_BreakpointEnvelope) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            shiftPitch(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

PartialList * PartialList_copy(PartialList *self) {
    {
        return new PartialList( *self );
    }
}


static int
_wrap_PartialList_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    PartialList *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:PartialList_copy self ",&arg0, SWIGTYPE_p_PartialList) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (PartialList *)PartialList_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialList));
    return TCL_OK;
}

PartialList * new_PartialList() {
    {
        debugger << "creating an empty list of Partials" << Loris::endl;
        return new PartialList();
    }
}


static int
_wrap_new_PartialList(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,":new_PartialList ") == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (PartialList *)new_PartialList();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialList));
    return TCL_OK;
}

void  delete_PartialList(PartialList *self) {
    {
        debugger << "destroying  a list of " << self->size() << " Partials" << Loris::endl;
        delete self;
    }
}


static int
_wrap_delete_PartialList(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:delete_PartialList self ",&arg0, SWIGTYPE_p_PartialList) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            delete_PartialList(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_PartialList_clear(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:PartialList_clear self ",&arg0, SWIGTYPE_p_PartialList) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->clear();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_PartialList_size(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    unsigned long result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:PartialList_size self ",&arg0, SWIGTYPE_p_PartialList) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (unsigned long )arg0->size();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_PartialList_begin(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    PartialListIterator *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:PartialList_begin self ",&arg0, SWIGTYPE_p_PartialList) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = new PartialListIterator (arg0->begin());
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialListIterator));
    return TCL_OK;
}

static int
_wrap_PartialList_end(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    PartialListIterator *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:PartialList_end self ",&arg0, SWIGTYPE_p_PartialList) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = new PartialListIterator (arg0->end());
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialListIterator));
    return TCL_OK;
}

static int
_wrap_PartialList_insert(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    PartialListIterator *arg1 ;
    Partial *arg2 ;
    PartialListIterator *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ppp:PartialList_insert self position partial ",&arg0, SWIGTYPE_p_PartialList,&arg1, SWIGTYPE_p_PartialListIterator,&arg2, SWIGTYPE_p_Partial) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = new PartialListIterator (arg0->insert(*arg1,(Partial const &)*arg2));
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialListIterator));
    return TCL_OK;
}

static int
_wrap_PartialList_erase(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    PartialListIterator *arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:PartialList_erase self position ",&arg0, SWIGTYPE_p_PartialList,&arg1, SWIGTYPE_p_PartialListIterator) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->erase(*arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_PartialList_splice(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg0 ;
    PartialListIterator *arg1 ;
    PartialList *arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ppp:PartialList_splice self position list ",&arg0, SWIGTYPE_p_PartialList,&arg1, SWIGTYPE_p_PartialListIterator,&arg2, SWIGTYPE_p_PartialList) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->splice(*arg1,*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static void swig_delete_PartialList(void *obj) {
    delete (PartialList *) obj;
}
static swig_method swig_PartialList_methods[] = {
    {"copy", _wrap_PartialList_copy}, 
    {"clear", _wrap_PartialList_clear}, 
    {"size", _wrap_PartialList_size}, 
    {"begin", _wrap_PartialList_begin}, 
    {"end", _wrap_PartialList_end}, 
    {"insert", _wrap_PartialList_insert}, 
    {"erase", _wrap_PartialList_erase}, 
    {"splice", _wrap_PartialList_splice}, 
    {0,0}
};
static swig_attribute swig_PartialList_attributes[] = {
    {0,0,0}
};
static swig_class _wrap_class_PartialList = { "PartialList", &SWIGTYPE_p_PartialList,_wrap_new_PartialList, swig_delete_PartialList, swig_PartialList_methods, swig_PartialList_attributes };
PartialListIterator * PartialListIterator_copy(PartialListIterator *self) {
    {
        return new PartialListIterator( *self );
    }
}


static int
_wrap_PartialListIterator_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialListIterator *arg0 ;
    PartialListIterator *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:PartialListIterator_copy self ",&arg0, SWIGTYPE_p_PartialListIterator) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialListIterator));
    return TCL_OK;
}

PartialListIterator * PartialListIterator_next(PartialListIterator *self) {
    {
        ++(*self);
        return self;
    }
}


static int
_wrap_PartialListIterator_next(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialListIterator *arg0 ;
    PartialListIterator *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:PartialListIterator_next self ",&arg0, SWIGTYPE_p_PartialListIterator) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_next(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialListIterator));
    return TCL_OK;
}

PartialListIterator * PartialListIterator_prev(PartialListIterator *self) {
    {
        --(*self);
        return self;
    }
}


static int
_wrap_PartialListIterator_prev(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialListIterator *arg0 ;
    PartialListIterator *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:PartialListIterator_prev self ",&arg0, SWIGTYPE_p_PartialListIterator) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_prev(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialListIterator));
    return TCL_OK;
}

Partial * PartialListIterator_partial(PartialListIterator *self) {
    {
        Partial & current = **self;
        return &current;
    }
}


static int
_wrap_PartialListIterator_partial(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialListIterator *arg0 ;
    Partial *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:PartialListIterator_partial self ",&arg0, SWIGTYPE_p_PartialListIterator) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (Partial *)PartialListIterator_partial(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_Partial));
    return TCL_OK;
}

int  PartialListIterator_equals(PartialListIterator *self,PartialListIterator *other) {
    {
        return *self == *other;
    }
}


static int
_wrap_PartialListIterator_equals(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialListIterator *arg0 ;
    PartialListIterator *arg1 ;
    int result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:PartialListIterator_equals self other ",&arg0, SWIGTYPE_p_PartialListIterator,&arg1, SWIGTYPE_p_PartialListIterator) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (int )PartialListIterator_equals(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

int  PartialListIterator_isInRange(PartialListIterator *self,PartialListIterator const *begin,PartialListIterator const *end) {
    {
        PartialListIterator it;
        for ( it = *begin; it != *end; ++it )
        {
            if ( it == *self )
            return true;
        }
        return false;
    }
}


static int
_wrap_PartialListIterator_isInRange(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialListIterator *arg0 ;
    PartialListIterator *arg1 ;
    PartialListIterator *arg2 ;
    int result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ppp:PartialListIterator_isInRange self begin end ",&arg0, SWIGTYPE_p_PartialListIterator,&arg1, SWIGTYPE_p_PartialListIterator,&arg2, SWIGTYPE_p_PartialListIterator) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (int )PartialListIterator_isInRange(arg0,(PartialListIterator const *)arg1,(PartialListIterator const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static swig_method swig_PartialListIterator_methods[] = {
    {"copy", _wrap_PartialListIterator_copy}, 
    {"next", _wrap_PartialListIterator_next}, 
    {"prev", _wrap_PartialListIterator_prev}, 
    {"partial", _wrap_PartialListIterator_partial}, 
    {"equals", _wrap_PartialListIterator_equals}, 
    {"isInRange", _wrap_PartialListIterator_isInRange}, 
    {0,0}
};
static swig_attribute swig_PartialListIterator_attributes[] = {
    {0,0,0}
};
static swig_class _wrap_class_PartialListIterator = { "PartialListIterator", &SWIGTYPE_p_PartialListIterator,0,0, swig_PartialListIterator_methods, swig_PartialListIterator_attributes };
static int
_wrap_new_Partial(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,":new_Partial ") == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (Partial *)new Partial();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_Partial));
    return TCL_OK;
}

static int
_wrap_delete_Partial(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:delete_Partial self ",&arg0, SWIGTYPE_p_Partial) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_Partial_label(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    int result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Partial_label self ",&arg0, SWIGTYPE_p_Partial) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (int )arg0->label();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_Partial_initialPhase(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Partial_initialPhase self ",&arg0, SWIGTYPE_p_Partial) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->initialPhase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Partial_startTime(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Partial_startTime self ",&arg0, SWIGTYPE_p_Partial) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->startTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Partial_endTime(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Partial_endTime self ",&arg0, SWIGTYPE_p_Partial) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->endTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Partial_duration(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Partial_duration self ",&arg0, SWIGTYPE_p_Partial) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->duration();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Partial_numBreakpoints(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    long result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Partial_numBreakpoints self ",&arg0, SWIGTYPE_p_Partial) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (long )arg0->numBreakpoints();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_Partial_setLabel(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    int arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pi:Partial_setLabel self l ",&arg0, SWIGTYPE_p_Partial,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->setLabel(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_Partial_begin(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    PartialIterator *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Partial_begin self ",&arg0, SWIGTYPE_p_Partial) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = new PartialIterator (arg0->begin());
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialIterator));
    return TCL_OK;
}

static int
_wrap_Partial_end(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    PartialIterator *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Partial_end self ",&arg0, SWIGTYPE_p_Partial) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = new PartialIterator (arg0->end());
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialIterator));
    return TCL_OK;
}

static int
_wrap_Partial_insert(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    double arg1 ;
    Breakpoint *arg2 ;
    PartialIterator *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pdp:Partial_insert self time bp ",&arg0, SWIGTYPE_p_Partial,&arg1,&arg2, SWIGTYPE_p_Breakpoint) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = new PartialIterator (arg0->insert(arg1,(Breakpoint const &)*arg2));
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialIterator));
    return TCL_OK;
}

static int
_wrap_Partial_findAfter(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    double arg1 ;
    PartialIterator *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Partial_findAfter self time ",&arg0, SWIGTYPE_p_Partial,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = new PartialIterator (arg0->findAfter(arg1));
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialIterator));
    return TCL_OK;
}

static int
_wrap_Partial_findNearest(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    double arg1 ;
    PartialIterator *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Partial_findNearest self time ",&arg0, SWIGTYPE_p_Partial,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = new PartialIterator (arg0->findNearest(arg1));
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialIterator));
    return TCL_OK;
}

static int
_wrap_Partial_erase(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    PartialIterator *arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:Partial_erase self pos ",&arg0, SWIGTYPE_p_Partial,&arg1, SWIGTYPE_p_PartialIterator) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->erase(*arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_Partial_frequencyAt(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    double arg1 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Partial_frequencyAt self time ",&arg0, SWIGTYPE_p_Partial,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->frequencyAt(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Partial_amplitudeAt(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    double arg1 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Partial_amplitudeAt self time ",&arg0, SWIGTYPE_p_Partial,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->amplitudeAt(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Partial_bandwidthAt(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    double arg1 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Partial_bandwidthAt self time ",&arg0, SWIGTYPE_p_Partial,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->bandwidthAt(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Partial_phaseAt(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    double arg1 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Partial_phaseAt self time ",&arg0, SWIGTYPE_p_Partial,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->phaseAt(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

Partial * Partial_copy(Partial *self) {
    {
        return new Partial( *self );
    }
}


static int
_wrap_Partial_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    Partial *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Partial_copy self ",&arg0, SWIGTYPE_p_Partial) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (Partial *)Partial_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_Partial));
    return TCL_OK;
}

int  Partial_equals(Partial *self,Partial *other) {
    {
        return *self == *other;
    }
}


static int
_wrap_Partial_equals(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg0 ;
    Partial *arg1 ;
    int result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:Partial_equals self other ",&arg0, SWIGTYPE_p_Partial,&arg1, SWIGTYPE_p_Partial) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (int )Partial_equals(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static void swig_delete_Partial(void *obj) {
    delete (Partial *) obj;
}
static swig_method swig_Partial_methods[] = {
    {"label", _wrap_Partial_label}, 
    {"initialPhase", _wrap_Partial_initialPhase}, 
    {"startTime", _wrap_Partial_startTime}, 
    {"endTime", _wrap_Partial_endTime}, 
    {"duration", _wrap_Partial_duration}, 
    {"numBreakpoints", _wrap_Partial_numBreakpoints}, 
    {"setLabel", _wrap_Partial_setLabel}, 
    {"begin", _wrap_Partial_begin}, 
    {"end", _wrap_Partial_end}, 
    {"insert", _wrap_Partial_insert}, 
    {"findAfter", _wrap_Partial_findAfter}, 
    {"findNearest", _wrap_Partial_findNearest}, 
    {"erase", _wrap_Partial_erase}, 
    {"frequencyAt", _wrap_Partial_frequencyAt}, 
    {"amplitudeAt", _wrap_Partial_amplitudeAt}, 
    {"bandwidthAt", _wrap_Partial_bandwidthAt}, 
    {"phaseAt", _wrap_Partial_phaseAt}, 
    {"copy", _wrap_Partial_copy}, 
    {"equals", _wrap_Partial_equals}, 
    {0,0}
};
static swig_attribute swig_Partial_attributes[] = {
    {0,0,0}
};
static swig_class _wrap_class_Partial = { "Partial", &SWIGTYPE_p_Partial,_wrap_new_Partial, swig_delete_Partial, swig_Partial_methods, swig_Partial_attributes };
static int
_wrap_PartialIterator_time(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:PartialIterator_time self ",&arg0, SWIGTYPE_p_PartialIterator) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->time();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

Breakpoint * PartialIterator_breakpoint(PartialIterator *self) {
    {
        return &(self->breakpoint());
    }
}


static int
_wrap_PartialIterator_breakpoint(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *arg0 ;
    Breakpoint *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:PartialIterator_breakpoint self ",&arg0, SWIGTYPE_p_PartialIterator) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (Breakpoint *)PartialIterator_breakpoint(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_Breakpoint));
    return TCL_OK;
}

PartialIterator * PartialIterator_copy(PartialIterator *self) {
    {
        return new PartialIterator( *self );
    }
}


static int
_wrap_PartialIterator_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *arg0 ;
    PartialIterator *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:PartialIterator_copy self ",&arg0, SWIGTYPE_p_PartialIterator) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialIterator));
    return TCL_OK;
}

PartialIterator * PartialIterator_next(PartialIterator *self) {
    {
        ++(*self);
        return self;
    }
}


static int
_wrap_PartialIterator_next(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *arg0 ;
    PartialIterator *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:PartialIterator_next self ",&arg0, SWIGTYPE_p_PartialIterator) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_next(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialIterator));
    return TCL_OK;
}

PartialIterator * PartialIterator_prev(PartialIterator *self) {
    {
        --(*self);
        return self;
    }
}


static int
_wrap_PartialIterator_prev(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *arg0 ;
    PartialIterator *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:PartialIterator_prev self ",&arg0, SWIGTYPE_p_PartialIterator) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_prev(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialIterator));
    return TCL_OK;
}

int  PartialIterator_equals(PartialIterator *self,PartialIterator *other) {
    {
        return *self == *other;
    }
}


static int
_wrap_PartialIterator_equals(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *arg0 ;
    PartialIterator *arg1 ;
    int result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:PartialIterator_equals self other ",&arg0, SWIGTYPE_p_PartialIterator,&arg1, SWIGTYPE_p_PartialIterator) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (int )PartialIterator_equals(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

int  PartialIterator_isInRange(PartialIterator *self,PartialIterator const *begin,PartialIterator const *end) {
    {
        PartialIterator it;
        for ( it = *begin; it != *end; ++it )
        {
            if ( it == *self )
            return true;
        }
        return false;
    }
}


static int
_wrap_PartialIterator_isInRange(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *arg0 ;
    PartialIterator *arg1 ;
    PartialIterator *arg2 ;
    int result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ppp:PartialIterator_isInRange self begin end ",&arg0, SWIGTYPE_p_PartialIterator,&arg1, SWIGTYPE_p_PartialIterator,&arg2, SWIGTYPE_p_PartialIterator) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (int )PartialIterator_isInRange(arg0,(PartialIterator const *)arg1,(PartialIterator const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static swig_method swig_PartialIterator_methods[] = {
    {"time", _wrap_PartialIterator_time}, 
    {"breakpoint", _wrap_PartialIterator_breakpoint}, 
    {"copy", _wrap_PartialIterator_copy}, 
    {"next", _wrap_PartialIterator_next}, 
    {"prev", _wrap_PartialIterator_prev}, 
    {"equals", _wrap_PartialIterator_equals}, 
    {"isInRange", _wrap_PartialIterator_isInRange}, 
    {0,0}
};
static swig_attribute swig_PartialIterator_attributes[] = {
    {0,0,0}
};
static swig_class _wrap_class_PartialIterator = { "PartialIterator", &SWIGTYPE_p_PartialIterator,0,0, swig_PartialIterator_methods, swig_PartialIterator_attributes };
static int
_wrap_new_Breakpoint(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    double arg0 ;
    double arg1 ;
    double arg2 ;
    double arg3 = 0. ;
    Breakpoint *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ddd|d:new_Breakpoint f a b ?p? ",&arg0,&arg1,&arg2,&arg3) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (Breakpoint *)new Breakpoint(arg0,arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_Breakpoint));
    return TCL_OK;
}

static int
_wrap_delete_Breakpoint(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:delete_Breakpoint self ",&arg0, SWIGTYPE_p_Breakpoint) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_Breakpoint_frequency(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Breakpoint_frequency self ",&arg0, SWIGTYPE_p_Breakpoint) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->frequency();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Breakpoint_amplitude(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Breakpoint_amplitude self ",&arg0, SWIGTYPE_p_Breakpoint) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->amplitude();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Breakpoint_bandwidth(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Breakpoint_bandwidth self ",&arg0, SWIGTYPE_p_Breakpoint) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->bandwidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Breakpoint_phase(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Breakpoint_phase self ",&arg0, SWIGTYPE_p_Breakpoint) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->phase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Breakpoint_setFrequency(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg0 ;
    double arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Breakpoint_setFrequency self x ",&arg0, SWIGTYPE_p_Breakpoint,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->setFrequency(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_Breakpoint_setAmplitude(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg0 ;
    double arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Breakpoint_setAmplitude self x ",&arg0, SWIGTYPE_p_Breakpoint,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->setAmplitude(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_Breakpoint_setBandwidth(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg0 ;
    double arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Breakpoint_setBandwidth self x ",&arg0, SWIGTYPE_p_Breakpoint,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->setBandwidth(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_Breakpoint_setPhase(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg0 ;
    double arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Breakpoint_setPhase self x ",&arg0, SWIGTYPE_p_Breakpoint,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->setPhase(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

Breakpoint * Breakpoint_copy(Breakpoint *self) {
    {
        return new Breakpoint( *self );
    }
}


static int
_wrap_Breakpoint_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg0 ;
    Breakpoint *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Breakpoint_copy self ",&arg0, SWIGTYPE_p_Breakpoint) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (Breakpoint *)Breakpoint_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_Breakpoint));
    return TCL_OK;
}

int  Breakpoint_equals(Breakpoint *self,Breakpoint *other) {
    {
        return *self == *other;
    }
}


static int
_wrap_Breakpoint_equals(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg0 ;
    Breakpoint *arg1 ;
    int result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:Breakpoint_equals self other ",&arg0, SWIGTYPE_p_Breakpoint,&arg1, SWIGTYPE_p_Breakpoint) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (int )Breakpoint_equals(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static void swig_delete_Breakpoint(void *obj) {
    delete (Breakpoint *) obj;
}
static swig_method swig_Breakpoint_methods[] = {
    {"frequency", _wrap_Breakpoint_frequency}, 
    {"amplitude", _wrap_Breakpoint_amplitude}, 
    {"bandwidth", _wrap_Breakpoint_bandwidth}, 
    {"phase", _wrap_Breakpoint_phase}, 
    {"setFrequency", _wrap_Breakpoint_setFrequency}, 
    {"setAmplitude", _wrap_Breakpoint_setAmplitude}, 
    {"setBandwidth", _wrap_Breakpoint_setBandwidth}, 
    {"setPhase", _wrap_Breakpoint_setPhase}, 
    {"copy", _wrap_Breakpoint_copy}, 
    {"equals", _wrap_Breakpoint_equals}, 
    {0,0}
};
static swig_attribute swig_Breakpoint_attributes[] = {
    {0,0,0}
};
static swig_class _wrap_class_Breakpoint = { "Breakpoint", &SWIGTYPE_p_Breakpoint,_wrap_new_Breakpoint, swig_delete_Breakpoint, swig_Breakpoint_methods, swig_Breakpoint_attributes };
static int
_wrap_new_Analyzer(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    double arg0 ;
    Analyzer *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"d:new_Analyzer resolutionHz ",&arg0) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (Analyzer *)new Analyzer(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_Analyzer));
    return TCL_OK;
}

static int
_wrap_delete_Analyzer(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:delete_Analyzer self ",&arg0, SWIGTYPE_p_Analyzer) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

Analyzer * Analyzer_copy(Analyzer *self) {
    {
        return new Analyzer( self->freqResolution() );
    }
}


static int
_wrap_Analyzer_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    Analyzer *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Analyzer_copy self ",&arg0, SWIGTYPE_p_Analyzer) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (Analyzer *)Analyzer_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_Analyzer));
    return TCL_OK;
}

PartialList * Analyzer_analyze(Analyzer *self,SampleVector const *vec,double srate) {
    {
        PartialList * partials = new PartialList();
        self->analyze( vec->begin(), vec->end(), srate );
        partials->splice( partials->end(), self->partials() );
        return partials;
    }
}


static int
_wrap_Analyzer_analyze(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    SampleVector *arg1 ;
    double arg2 ;
    PartialList *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ppd:Analyzer_analyze self vec srate ",&arg0, SWIGTYPE_p_Analyzer,&arg1, SWIGTYPE_p_SampleVector,&arg2) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (PartialList *)Analyzer_analyze(arg0,(SampleVector const *)arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_PartialList));
    return TCL_OK;
}

static int
_wrap_Analyzer_configure(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Analyzer_configure self resolutionHz ",&arg0, SWIGTYPE_p_Analyzer,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->configure(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_Analyzer_freqResolution(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Analyzer_freqResolution self ",&arg0, SWIGTYPE_p_Analyzer) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->freqResolution();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Analyzer_ampFloor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Analyzer_ampFloor self ",&arg0, SWIGTYPE_p_Analyzer) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->ampFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Analyzer_windowWidth(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Analyzer_windowWidth self ",&arg0, SWIGTYPE_p_Analyzer) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->windowWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Analyzer_freqFloor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Analyzer_freqFloor self ",&arg0, SWIGTYPE_p_Analyzer) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->freqFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Analyzer_hopTime(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Analyzer_hopTime self ",&arg0, SWIGTYPE_p_Analyzer) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->hopTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Analyzer_freqDrift(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Analyzer_freqDrift self ",&arg0, SWIGTYPE_p_Analyzer) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->freqDrift();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Analyzer_cropTime(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Analyzer_cropTime self ",&arg0, SWIGTYPE_p_Analyzer) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->cropTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Analyzer_bwRegionWidth(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Analyzer_bwRegionWidth self ",&arg0, SWIGTYPE_p_Analyzer) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->bwRegionWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_Analyzer_setFreqResolution(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Analyzer_setFreqResolution self x ",&arg0, SWIGTYPE_p_Analyzer,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->setFreqResolution(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_Analyzer_setAmpFloor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Analyzer_setAmpFloor self x ",&arg0, SWIGTYPE_p_Analyzer,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->setAmpFloor(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_Analyzer_setWindowWidth(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Analyzer_setWindowWidth self x ",&arg0, SWIGTYPE_p_Analyzer,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->setWindowWidth(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_Analyzer_setFreqFloor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Analyzer_setFreqFloor self x ",&arg0, SWIGTYPE_p_Analyzer,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->setFreqFloor(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_Analyzer_setFreqDrift(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Analyzer_setFreqDrift self x ",&arg0, SWIGTYPE_p_Analyzer,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->setFreqDrift(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_Analyzer_setHopTime(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Analyzer_setHopTime self x ",&arg0, SWIGTYPE_p_Analyzer,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->setHopTime(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_Analyzer_setCropTime(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Analyzer_setCropTime self x ",&arg0, SWIGTYPE_p_Analyzer,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->setCropTime(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_Analyzer_setBwRegionWidth(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg0 ;
    double arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:Analyzer_setBwRegionWidth self x ",&arg0, SWIGTYPE_p_Analyzer,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->setBwRegionWidth(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static void swig_delete_Analyzer(void *obj) {
    delete (Analyzer *) obj;
}
static swig_method swig_Analyzer_methods[] = {
    {"copy", _wrap_Analyzer_copy}, 
    {"analyze", _wrap_Analyzer_analyze}, 
    {"configure", _wrap_Analyzer_configure}, 
    {"freqResolution", _wrap_Analyzer_freqResolution}, 
    {"ampFloor", _wrap_Analyzer_ampFloor}, 
    {"windowWidth", _wrap_Analyzer_windowWidth}, 
    {"freqFloor", _wrap_Analyzer_freqFloor}, 
    {"hopTime", _wrap_Analyzer_hopTime}, 
    {"freqDrift", _wrap_Analyzer_freqDrift}, 
    {"cropTime", _wrap_Analyzer_cropTime}, 
    {"bwRegionWidth", _wrap_Analyzer_bwRegionWidth}, 
    {"setFreqResolution", _wrap_Analyzer_setFreqResolution}, 
    {"setAmpFloor", _wrap_Analyzer_setAmpFloor}, 
    {"setWindowWidth", _wrap_Analyzer_setWindowWidth}, 
    {"setFreqFloor", _wrap_Analyzer_setFreqFloor}, 
    {"setFreqDrift", _wrap_Analyzer_setFreqDrift}, 
    {"setHopTime", _wrap_Analyzer_setHopTime}, 
    {"setCropTime", _wrap_Analyzer_setCropTime}, 
    {"setBwRegionWidth", _wrap_Analyzer_setBwRegionWidth}, 
    {0,0}
};
static swig_attribute swig_Analyzer_attributes[] = {
    {0,0,0}
};
static swig_class _wrap_class_Analyzer = { "Analyzer", &SWIGTYPE_p_Analyzer,_wrap_new_Analyzer, swig_delete_Analyzer, swig_Analyzer_methods, swig_Analyzer_attributes };
static int
_wrap_new_BreakpointEnvelope(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    BreakpointEnvelope *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,":new_BreakpointEnvelope ") == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (BreakpointEnvelope *)new BreakpointEnvelope();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_BreakpointEnvelope));
    return TCL_OK;
}

static int
_wrap_delete_BreakpointEnvelope(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    BreakpointEnvelope *arg0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:delete_BreakpointEnvelope self ",&arg0, SWIGTYPE_p_BreakpointEnvelope) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

BreakpointEnvelope * BreakpointEnvelope_copy(BreakpointEnvelope *self) {
    {
        return new BreakpointEnvelope( *self );
    }
}


static int
_wrap_BreakpointEnvelope_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    BreakpointEnvelope *arg0 ;
    BreakpointEnvelope *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:BreakpointEnvelope_copy self ",&arg0, SWIGTYPE_p_BreakpointEnvelope) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelope_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_BreakpointEnvelope));
    return TCL_OK;
}

static int
_wrap_BreakpointEnvelope_valueAt(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    BreakpointEnvelope *arg0 ;
    double arg1 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pd:BreakpointEnvelope_valueAt self x ",&arg0, SWIGTYPE_p_BreakpointEnvelope,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->valueAt(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_BreakpointEnvelope_insertBreakpoint(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    BreakpointEnvelope *arg0 ;
    double arg1 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pdd:BreakpointEnvelope_insertBreakpoint self time value ",&arg0, SWIGTYPE_p_BreakpointEnvelope,&arg1,&arg2) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->insertBreakpoint(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static void swig_delete_BreakpointEnvelope(void *obj) {
    delete (BreakpointEnvelope *) obj;
}
static swig_method swig_BreakpointEnvelope_methods[] = {
    {"copy", _wrap_BreakpointEnvelope_copy}, 
    {"valueAt", _wrap_BreakpointEnvelope_valueAt}, 
    {"insertBreakpoint", _wrap_BreakpointEnvelope_insertBreakpoint}, 
    {0,0}
};
static swig_attribute swig_BreakpointEnvelope_attributes[] = {
    {0,0,0}
};
static swig_class _wrap_class_BreakpointEnvelope = { "BreakpointEnvelope", &SWIGTYPE_p_BreakpointEnvelope,_wrap_new_BreakpointEnvelope, swig_delete_BreakpointEnvelope, swig_BreakpointEnvelope_methods, swig_BreakpointEnvelope_attributes };
static int
_wrap_new_SampleVector(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    unsigned long arg0 = 0 ;
    SampleVector *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"|l:new_SampleVector ?size? ",&arg0) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (SampleVector *)new SampleVector(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_SampleVector));
    return TCL_OK;
}

static int
_wrap_delete_SampleVector(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    SampleVector *arg0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:delete_SampleVector self ",&arg0, SWIGTYPE_p_SampleVector) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_SampleVector_size(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    SampleVector *arg0 ;
    unsigned long result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:SampleVector_size self ",&arg0, SWIGTYPE_p_SampleVector) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (unsigned long )arg0->size();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_SampleVector_resize(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    SampleVector *arg0 ;
    unsigned long arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pl:SampleVector_resize self size ",&arg0, SWIGTYPE_p_SampleVector,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->resize(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_SampleVector_clear(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    SampleVector *arg0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:SampleVector_clear self ",&arg0, SWIGTYPE_p_SampleVector) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            arg0->clear();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

SampleVector * SampleVector_copy(SampleVector *self) {
    {
        return new SampleVector( *self );
    }
}


static int
_wrap_SampleVector_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    SampleVector *arg0 ;
    SampleVector *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:SampleVector_copy self ",&arg0, SWIGTYPE_p_SampleVector) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (SampleVector *)SampleVector_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_SampleVector));
    return TCL_OK;
}

double  SampleVector_getAt(SampleVector *self,unsigned long idx) {
    {
// return self->at(idx);	//	g++ doesn't implement at()?
		if ( idx >= self->size() )
			throw std::out_of_range("vector::at index out of range");
		return (*self)[idx];
	}
}


static int
_wrap_SampleVector_getAt(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    SampleVector *arg0 ;
    unsigned long arg1 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pl:SampleVector_getAt self idx ",&arg0, SWIGTYPE_p_SampleVector,&arg1) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )SampleVector_getAt(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

void  SampleVector_setAt(SampleVector *self,unsigned long idx,double x) {
    {
// self->at(idx) = x;	//	g++ doesn't implement at()?
		if ( idx >= self->size() )
			throw std::out_of_range("vector::at index out of range");
		(*self)[idx] = x;
	}
}


static int
_wrap_SampleVector_setAt(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    SampleVector *arg0 ;
    unsigned long arg1 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pld:SampleVector_setAt self idx x ",&arg0, SWIGTYPE_p_SampleVector,&arg1,&arg2) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            SampleVector_setAt(arg0,arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static void swig_delete_SampleVector(void *obj) {
    delete (SampleVector *) obj;
}
static swig_method swig_SampleVector_methods[] = {
    {"size", _wrap_SampleVector_size}, 
    {"resize", _wrap_SampleVector_resize}, 
    {"clear", _wrap_SampleVector_clear}, 
    {"copy", _wrap_SampleVector_copy}, 
    {"getAt", _wrap_SampleVector_getAt}, 
    {"setAt", _wrap_SampleVector_setAt}, 
    {0,0}
};
static swig_attribute swig_SampleVector_attributes[] = {
    {0,0,0}
};
static swig_class _wrap_class_SampleVector = { "SampleVector", &SWIGTYPE_p_SampleVector,_wrap_new_SampleVector, swig_delete_SampleVector, swig_SampleVector_methods, swig_SampleVector_attributes };
static int
_wrap_new_AiffFile(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg0 ;
    AiffFile *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"s:new_AiffFile filename ",&arg0) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (AiffFile *)new AiffFile((char const *)arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_AiffFile));
    return TCL_OK;
}

static int
_wrap_delete_AiffFile(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    AiffFile *arg0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:delete_AiffFile self ",&arg0, SWIGTYPE_p_AiffFile) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }return TCL_OK;
}

static int
_wrap_AiffFile_channels(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    AiffFile *arg0 ;
    int result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:AiffFile_channels self ",&arg0, SWIGTYPE_p_AiffFile) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (int )arg0->channels();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_AiffFile_sampleFrames(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    AiffFile *arg0 ;
    unsigned long result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:AiffFile_sampleFrames self ",&arg0, SWIGTYPE_p_AiffFile) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (unsigned long )arg0->sampleFrames();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_AiffFile_sampleRate(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    AiffFile *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:AiffFile_sampleRate self ",&arg0, SWIGTYPE_p_AiffFile) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (double )arg0->sampleRate();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}

static int
_wrap_AiffFile_sampleSize(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    AiffFile *arg0 ;
    int result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:AiffFile_sampleSize self ",&arg0, SWIGTYPE_p_AiffFile) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (int )arg0->sampleSize();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

SampleVector * AiffFile_samples(AiffFile *self) {
    {
        SampleVector * vec = new SampleVector( self->sampleFrames(), 0. );
        self->getSamples( vec->begin(), vec->end() );
        return vec;
    }
}


static int
_wrap_AiffFile_samples(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    AiffFile *arg0 ;
    SampleVector *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:AiffFile_samples self ",&arg0, SWIGTYPE_p_AiffFile) == TCL_ERROR) return TCL_ERROR;
    {
        try
        {
            result = (SampleVector *)AiffFile_samples(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_SampleVector));
    return TCL_OK;
}

static void swig_delete_AiffFile(void *obj) {
    delete (AiffFile *) obj;
}
static swig_method swig_AiffFile_methods[] = {
    {"channels", _wrap_AiffFile_channels}, 
    {"sampleFrames", _wrap_AiffFile_sampleFrames}, 
    {"sampleRate", _wrap_AiffFile_sampleRate}, 
    {"sampleSize", _wrap_AiffFile_sampleSize}, 
    {"samples", _wrap_AiffFile_samples}, 
    {0,0}
};
static swig_attribute swig_AiffFile_attributes[] = {
    {0,0,0}
};
static swig_class _wrap_class_AiffFile = { "AiffFile", &SWIGTYPE_p_AiffFile,_wrap_new_AiffFile, swig_delete_AiffFile, swig_AiffFile_methods, swig_AiffFile_attributes };

static swig_command_info swig_commands[] = {
    { SWIG_prefix "BreakpointEnvelopeWithValue", _wrap_BreakpointEnvelopeWithValue, NULL},
    { SWIG_prefix "channelize", _wrap_channelize, NULL},
    { SWIG_prefix "dilate", _wrap_dilate, NULL},
    { SWIG_prefix "distill", _wrap_distill, NULL},
    { SWIG_prefix "exportAiff", _wrap_exportAiff, NULL},
    { SWIG_prefix "exportSdif", _wrap_exportSdif, NULL},
    { SWIG_prefix "exportSpc", _wrap_exportSpc, NULL},
    { SWIG_prefix "importSdif", _wrap_importSdif, NULL},
    { SWIG_prefix "importSpc", _wrap_importSpc, NULL},
    { SWIG_prefix "morph", _wrap_morph, NULL},
    { SWIG_prefix "synthesize", _wrap_synthesize, NULL},
    { SWIG_prefix "sift", _wrap_sift, NULL},
    { SWIG_prefix "createFreqReference", _wrap_createFreqReference, NULL},
    { SWIG_prefix "scaleAmp", _wrap_scaleAmp, NULL},
    { SWIG_prefix "scaleNoiseRatio", _wrap_scaleNoiseRatio, NULL},
    { SWIG_prefix "shiftPitch", _wrap_shiftPitch, NULL},
    { SWIG_prefix "PartialList_copy", _wrap_PartialList_copy, NULL},
    { SWIG_prefix "new_PartialList", _wrap_new_PartialList, NULL},
    { SWIG_prefix "delete_PartialList", _wrap_delete_PartialList, NULL},
    { SWIG_prefix "PartialList_clear", _wrap_PartialList_clear, NULL},
    { SWIG_prefix "PartialList_size", _wrap_PartialList_size, NULL},
    { SWIG_prefix "PartialList_begin", _wrap_PartialList_begin, NULL},
    { SWIG_prefix "PartialList_end", _wrap_PartialList_end, NULL},
    { SWIG_prefix "PartialList_insert", _wrap_PartialList_insert, NULL},
    { SWIG_prefix "PartialList_erase", _wrap_PartialList_erase, NULL},
    { SWIG_prefix "PartialList_splice", _wrap_PartialList_splice, NULL},
    { SWIG_prefix "PartialList", SwigObjectCmd, &_wrap_class_PartialList},
    { SWIG_prefix "PartialListIterator_copy", _wrap_PartialListIterator_copy, NULL},
    { SWIG_prefix "PartialListIterator_next", _wrap_PartialListIterator_next, NULL},
    { SWIG_prefix "PartialListIterator_prev", _wrap_PartialListIterator_prev, NULL},
    { SWIG_prefix "PartialListIterator_partial", _wrap_PartialListIterator_partial, NULL},
    { SWIG_prefix "PartialListIterator_equals", _wrap_PartialListIterator_equals, NULL},
    { SWIG_prefix "PartialListIterator_isInRange", _wrap_PartialListIterator_isInRange, NULL},
    { SWIG_prefix "PartialListIterator", SwigObjectCmd, &_wrap_class_PartialListIterator},
    { SWIG_prefix "new_Partial", _wrap_new_Partial, NULL},
    { SWIG_prefix "delete_Partial", _wrap_delete_Partial, NULL},
    { SWIG_prefix "Partial_label", _wrap_Partial_label, NULL},
    { SWIG_prefix "Partial_initialPhase", _wrap_Partial_initialPhase, NULL},
    { SWIG_prefix "Partial_startTime", _wrap_Partial_startTime, NULL},
    { SWIG_prefix "Partial_endTime", _wrap_Partial_endTime, NULL},
    { SWIG_prefix "Partial_duration", _wrap_Partial_duration, NULL},
    { SWIG_prefix "Partial_numBreakpoints", _wrap_Partial_numBreakpoints, NULL},
    { SWIG_prefix "Partial_setLabel", _wrap_Partial_setLabel, NULL},
    { SWIG_prefix "Partial_begin", _wrap_Partial_begin, NULL},
    { SWIG_prefix "Partial_end", _wrap_Partial_end, NULL},
    { SWIG_prefix "Partial_insert", _wrap_Partial_insert, NULL},
    { SWIG_prefix "Partial_findAfter", _wrap_Partial_findAfter, NULL},
    { SWIG_prefix "Partial_findNearest", _wrap_Partial_findNearest, NULL},
    { SWIG_prefix "Partial_erase", _wrap_Partial_erase, NULL},
    { SWIG_prefix "Partial_frequencyAt", _wrap_Partial_frequencyAt, NULL},
    { SWIG_prefix "Partial_amplitudeAt", _wrap_Partial_amplitudeAt, NULL},
    { SWIG_prefix "Partial_bandwidthAt", _wrap_Partial_bandwidthAt, NULL},
    { SWIG_prefix "Partial_phaseAt", _wrap_Partial_phaseAt, NULL},
    { SWIG_prefix "Partial_copy", _wrap_Partial_copy, NULL},
    { SWIG_prefix "Partial_equals", _wrap_Partial_equals, NULL},
    { SWIG_prefix "Partial", SwigObjectCmd, &_wrap_class_Partial},
    { SWIG_prefix "PartialIterator_time", _wrap_PartialIterator_time, NULL},
    { SWIG_prefix "PartialIterator_breakpoint", _wrap_PartialIterator_breakpoint, NULL},
    { SWIG_prefix "PartialIterator_copy", _wrap_PartialIterator_copy, NULL},
    { SWIG_prefix "PartialIterator_next", _wrap_PartialIterator_next, NULL},
    { SWIG_prefix "PartialIterator_prev", _wrap_PartialIterator_prev, NULL},
    { SWIG_prefix "PartialIterator_equals", _wrap_PartialIterator_equals, NULL},
    { SWIG_prefix "PartialIterator_isInRange", _wrap_PartialIterator_isInRange, NULL},
    { SWIG_prefix "PartialIterator", SwigObjectCmd, &_wrap_class_PartialIterator},
    { SWIG_prefix "new_Breakpoint", _wrap_new_Breakpoint, NULL},
    { SWIG_prefix "delete_Breakpoint", _wrap_delete_Breakpoint, NULL},
    { SWIG_prefix "Breakpoint_frequency", _wrap_Breakpoint_frequency, NULL},
    { SWIG_prefix "Breakpoint_amplitude", _wrap_Breakpoint_amplitude, NULL},
    { SWIG_prefix "Breakpoint_bandwidth", _wrap_Breakpoint_bandwidth, NULL},
    { SWIG_prefix "Breakpoint_phase", _wrap_Breakpoint_phase, NULL},
    { SWIG_prefix "Breakpoint_setFrequency", _wrap_Breakpoint_setFrequency, NULL},
    { SWIG_prefix "Breakpoint_setAmplitude", _wrap_Breakpoint_setAmplitude, NULL},
    { SWIG_prefix "Breakpoint_setBandwidth", _wrap_Breakpoint_setBandwidth, NULL},
    { SWIG_prefix "Breakpoint_setPhase", _wrap_Breakpoint_setPhase, NULL},
    { SWIG_prefix "Breakpoint_copy", _wrap_Breakpoint_copy, NULL},
    { SWIG_prefix "Breakpoint_equals", _wrap_Breakpoint_equals, NULL},
    { SWIG_prefix "Breakpoint", SwigObjectCmd, &_wrap_class_Breakpoint},
    { SWIG_prefix "new_Analyzer", _wrap_new_Analyzer, NULL},
    { SWIG_prefix "delete_Analyzer", _wrap_delete_Analyzer, NULL},
    { SWIG_prefix "Analyzer_copy", _wrap_Analyzer_copy, NULL},
    { SWIG_prefix "Analyzer_analyze", _wrap_Analyzer_analyze, NULL},
    { SWIG_prefix "Analyzer_configure", _wrap_Analyzer_configure, NULL},
    { SWIG_prefix "Analyzer_freqResolution", _wrap_Analyzer_freqResolution, NULL},
    { SWIG_prefix "Analyzer_ampFloor", _wrap_Analyzer_ampFloor, NULL},
    { SWIG_prefix "Analyzer_windowWidth", _wrap_Analyzer_windowWidth, NULL},
    { SWIG_prefix "Analyzer_freqFloor", _wrap_Analyzer_freqFloor, NULL},
    { SWIG_prefix "Analyzer_hopTime", _wrap_Analyzer_hopTime, NULL},
    { SWIG_prefix "Analyzer_freqDrift", _wrap_Analyzer_freqDrift, NULL},
    { SWIG_prefix "Analyzer_cropTime", _wrap_Analyzer_cropTime, NULL},
    { SWIG_prefix "Analyzer_bwRegionWidth", _wrap_Analyzer_bwRegionWidth, NULL},
    { SWIG_prefix "Analyzer_setFreqResolution", _wrap_Analyzer_setFreqResolution, NULL},
    { SWIG_prefix "Analyzer_setAmpFloor", _wrap_Analyzer_setAmpFloor, NULL},
    { SWIG_prefix "Analyzer_setWindowWidth", _wrap_Analyzer_setWindowWidth, NULL},
    { SWIG_prefix "Analyzer_setFreqFloor", _wrap_Analyzer_setFreqFloor, NULL},
    { SWIG_prefix "Analyzer_setFreqDrift", _wrap_Analyzer_setFreqDrift, NULL},
    { SWIG_prefix "Analyzer_setHopTime", _wrap_Analyzer_setHopTime, NULL},
    { SWIG_prefix "Analyzer_setCropTime", _wrap_Analyzer_setCropTime, NULL},
    { SWIG_prefix "Analyzer_setBwRegionWidth", _wrap_Analyzer_setBwRegionWidth, NULL},
    { SWIG_prefix "Analyzer", SwigObjectCmd, &_wrap_class_Analyzer},
    { SWIG_prefix "new_BreakpointEnvelope", _wrap_new_BreakpointEnvelope, NULL},
    { SWIG_prefix "delete_BreakpointEnvelope", _wrap_delete_BreakpointEnvelope, NULL},
    { SWIG_prefix "BreakpointEnvelope_copy", _wrap_BreakpointEnvelope_copy, NULL},
    { SWIG_prefix "BreakpointEnvelope_valueAt", _wrap_BreakpointEnvelope_valueAt, NULL},
    { SWIG_prefix "BreakpointEnvelope_insertBreakpoint", _wrap_BreakpointEnvelope_insertBreakpoint, NULL},
    { SWIG_prefix "BreakpointEnvelope", SwigObjectCmd, &_wrap_class_BreakpointEnvelope},
    { SWIG_prefix "new_SampleVector", _wrap_new_SampleVector, NULL},
    { SWIG_prefix "delete_SampleVector", _wrap_delete_SampleVector, NULL},
    { SWIG_prefix "SampleVector_size", _wrap_SampleVector_size, NULL},
    { SWIG_prefix "SampleVector_resize", _wrap_SampleVector_resize, NULL},
    { SWIG_prefix "SampleVector_clear", _wrap_SampleVector_clear, NULL},
    { SWIG_prefix "SampleVector_copy", _wrap_SampleVector_copy, NULL},
    { SWIG_prefix "SampleVector_getAt", _wrap_SampleVector_getAt, NULL},
    { SWIG_prefix "SampleVector_setAt", _wrap_SampleVector_setAt, NULL},
    { SWIG_prefix "SampleVector", SwigObjectCmd, &_wrap_class_SampleVector},
    { SWIG_prefix "new_AiffFile", _wrap_new_AiffFile, NULL},
    { SWIG_prefix "delete_AiffFile", _wrap_delete_AiffFile, NULL},
    { SWIG_prefix "AiffFile_channels", _wrap_AiffFile_channels, NULL},
    { SWIG_prefix "AiffFile_sampleFrames", _wrap_AiffFile_sampleFrames, NULL},
    { SWIG_prefix "AiffFile_sampleRate", _wrap_AiffFile_sampleRate, NULL},
    { SWIG_prefix "AiffFile_sampleSize", _wrap_AiffFile_sampleSize, NULL},
    { SWIG_prefix "AiffFile_samples", _wrap_AiffFile_samples, NULL},
    { SWIG_prefix "AiffFile", SwigObjectCmd, &_wrap_class_AiffFile},
    {0, 0, 0}
};

static swig_var_info swig_variables[] = {
    {0,0,0,0}
};

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_Partial[] = {{"_p_Partial", 0, "Partial *"},{"_p_Partial"},{0}};
static swig_type_info _swigt__p_PartialList[] = {{"_p_PartialList", 0, "PartialList *"},{"_p_PartialList"},{0}};
static swig_type_info _swigt__p_SampleVector[] = {{"_p_SampleVector", 0, "SampleVector *"},{"_p_SampleVector"},{0}};
static swig_type_info _swigt__p_AiffFile[] = {{"_p_AiffFile", 0, "AiffFile *"},{"_p_AiffFile"},{0}};
static swig_type_info _swigt__p_Analyzer[] = {{"_p_Analyzer", 0, "Analyzer *"},{"_p_Analyzer"},{0}};
static swig_type_info _swigt__p_PartialListIterator[] = {{"_p_PartialListIterator", 0, "PartialListIterator *"},{"_p_PartialListIterator"},{0}};
static swig_type_info _swigt__p_PartialIterator[] = {{"_p_PartialIterator", 0, "PartialIterator *"},{"_p_PartialIterator"},{0}};
static swig_type_info _swigt__p_Breakpoint[] = {{"_p_Breakpoint", 0, "Breakpoint *"},{"_p_Breakpoint"},{0}};
static swig_type_info _swigt__p_BreakpointEnvelope[] = {{"_p_BreakpointEnvelope", 0, "BreakpointEnvelope *"},{"_p_BreakpointEnvelope"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_Partial, 
_swigt__p_PartialList, 
_swigt__p_SampleVector, 
_swigt__p_AiffFile, 
_swigt__p_Analyzer, 
_swigt__p_PartialListIterator, 
_swigt__p_PartialIterator, 
_swigt__p_Breakpoint, 
_swigt__p_BreakpointEnvelope, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

SWIGEXPORT(int) Loris_Init(Tcl_Interp *interp) {
    int i;
    if (interp == 0) return TCL_ERROR;
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
    }
    
    Loris::setNotifierHandler( printf_notifier );
    Loris::setDebuggerHandler( printf_notifier );
    for (i = 0; swig_commands[i].name; i++) {
        Tcl_CreateObjCommand(interp, (char *) swig_commands[i].name, swig_commands[i].wrapper, swig_commands[i].clientdata, NULL);
    }
    for (i = 0; swig_variables[i].name; i++) {
        Tcl_SetVar(interp, (char *) swig_variables[i].name, "", TCL_GLOBAL_ONLY);
        Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_READS | TCL_GLOBAL_ONLY, swig_variables[i].get, (ClientData) swig_variables[i].addr);
        Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_WRITES | TCL_GLOBAL_ONLY, swig_variables[i].set, (ClientData) swig_variables[i].addr);
    }
    return TCL_OK;
}

