/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.17u-20030304-1001
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */


#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    inline SwigValueWrapper() : tt(0) { }
    inline ~SwigValueWrapper() { if (tt) delete tt; } 
    inline SwigValueWrapper& operator=(const T& t) { tt = new T(t); return *this; }
    inline operator T&() const { return *tt; }
    inline T *operator&() { return tt; }
};                                                    
#endif

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) extern a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#                       define SWIGIMPORT(a) extern a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#                       define SWIGIMPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) a
#               endif
#       endif
#else
#       define SWIGEXPORT(a) a
#       define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;                 
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;	
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      if (tc->clientdata) ti->clientdata = tc->clientdata;	
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) 
{
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
     ty = (*ty->dcast)(ptr);
     if (ty) lastty = ty;
  }
  return lastty;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata == clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
	if ((strcmp(tc->name, equiv->name) == 0))
	  SWIG_TypeClientData(tc,clientdata);
	tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}
#endif

#ifdef __cplusplus
}

#endif

/*
 * $Header$
 * 
 * swigtcl8.swg
 */

#include <tcl.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Constant table */

#define SWIG_TCL_INT     1
#define SWIG_TCL_FLOAT   2
#define SWIG_TCL_STRING  3
#define SWIG_TCL_POINTER 4
#define SWIG_TCL_BINARY  5

/* Flags for pointer conversion */
#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_DISOWN        0x2

/* Swig fail macro */

#define SWIG_fail   goto fail
   
/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

typedef int   (*swig_wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
typedef int   (*swig_wrapper_func)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
typedef char *(*swig_variable_func)(ClientData, Tcl_Interp *, char *, char *, int);
typedef void  (*swig_delete_func)(ClientData);

typedef struct swig_method { 
  const char     *name;
  swig_wrapper   method;
} swig_method;

typedef struct swig_attribute {
  const char     *name;
  swig_wrapper   getmethod;
  swig_wrapper   setmethod;
} swig_attribute;
  
typedef struct swig_class {
  const char         *name;
  swig_type_info   **type;
  swig_wrapper       constructor;
  void              (*destructor)(void *);
  swig_method        *methods;
  swig_attribute     *attributes;
  struct swig_class **bases;
} swig_class;

typedef struct swig_instance {
  Tcl_Obj       *thisptr;
  void          *thisvalue;
  swig_class   *classptr;
  int            destroy;
  Tcl_Command    cmdtok;
} swig_instance;

#ifdef SWIG_NOINCLUDE
SWIGEXPORT(char *)    SWIG_PackData(char *c, void *ptr, int sz);
SWIGEXPORT(char *)    SWIG_UnpackData(char *c, void *ptr, int sz);
SWIGEXPORT(int)       SWIG_ConvertPtrFromString(Tcl_Interp *, char *, void **, swig_type_info *,int flags);
SWIGEXPORT(int)       SWIG_ConvertPtr(Tcl_Interp *, Tcl_Obj *, void **, swig_type_info *, int flags);
SWIGEXPORT(int)       SWIG_ConvertPacked(Tcl_Interp *, Tcl_Obj *, void *, int sz, swig_type_info *, int flags);
SWIGEXPORT(void)      SWIG_MakePtr(char *, void *, swig_type_info *, int flags);
SWIGEXPORT(Tcl_Obj *) SWIG_NewPointerObj(void *, swig_type_info *, int flags);
SWIGEXPORT(Tcl_Obj *) SWIG_NewPackedObj(void *, int sz, swig_type_info *, int flags);
SWIGEXPORT(int)       SWIG_GetArgs(Tcl_Interp *, int, Tcl_Obj *CONST [], const char *, ...);
SWIGEXPORT(char *)    SWIG_PointerTypeFromString(char *c);
SWIGEXPORT(void)      SWIG_Acquire(void *ptr);
SWIGEXPORT(int)       SWIG_Disown(void *ptr);
SWIGEXPORT(int)       SWIG_Thisown(void *ptr);
SWIGEXPORT(void)      SWIG_InstallConstants(Tcl_Interp *interp, struct swig_const_info constants[]);
SWIGEXPORT(Tcl_Obj *) SWIG_GetConstant(const char *key);
SWIGEXPORT(Tcl_Obj *) SWIG_NewInstanceObj(Tcl_Interp *interp, void *, swig_type_info *, int flags);
SWIGEXPORT(int)       SWIG_ObjectConstructor(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST objv[]);
SWIGEXPORT(int)       SWIG_MethodCommand(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST objv[]);
SWIGEXPORT(void)      SWIG_ObjectDelete(ClientData);
#else

/* Object support */
static Tcl_HashTable  swigobjectTable;
static int            swigobjectTableinit = 0;

/* Acquire ownership of a pointer */
SWIGRUNTIME(void)
SWIG_Acquire(void *ptr)
{
  Tcl_HashEntry *entryPtr;
  int newobj;
  if (!swigobjectTableinit) {
    Tcl_InitHashTable(&swigobjectTable, TCL_ONE_WORD_KEYS);
    swigobjectTableinit = 1;
  }
  entryPtr = Tcl_CreateHashEntry(&swigobjectTable, (char *) ptr, &newobj);
}

/* Disown a pointer.  Returns 1 if we owned it to begin with */
SWIGRUNTIME(int)
SWIG_Disown(void *ptr)
{
  Tcl_HashEntry *entryPtr;
  if (!swigobjectTableinit) return 0;
  entryPtr = Tcl_FindHashEntry(&swigobjectTable, (char *) ptr);
  if (entryPtr) {
    Tcl_DeleteHashEntry(entryPtr);
    return 1;
  } 
  return 0;
}

SWIGRUNTIME(int)
SWIG_Thisown(void *ptr) {
  if (!swigobjectTableinit) return 0;
  if (Tcl_FindHashEntry(&swigobjectTable, (char *) ptr)) {
    return 1;
  }
  return 0;
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  int i;
  unsigned char *u = (unsigned char *) ptr;
  register unsigned char uu;
  for (i = 0; i < sz; i++,u++) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu = 0;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  int i;
  if ((int)strlen(c) < (2*sz)) return c;
  for (i = 0; i < sz; i++, u++) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtrFromString(Tcl_Interp *interp, char *c, void **ptr, swig_type_info *ty, int flags)
{
  swig_type_info *tc;
  /* Pointer values must start with leading underscore */
  while (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) return TCL_OK;
    /* Hmmm. It could be an object name. */
    if (Tcl_VarEval(interp,c," cget -this", (char *) NULL) == TCL_OK) {
      Tcl_Obj *result = Tcl_GetObjResult(interp);
      c = Tcl_GetStringFromObj(result, NULL);
      continue;
    }
    if (flags & SWIG_POINTER_EXCEPTION) 
      Tcl_SetResult(interp, (char *) "Type error. Expected a pointer", TCL_STATIC);
    return TCL_ERROR;
  }
  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if ((!tc) && (flags & SWIG_POINTER_EXCEPTION)) {
      Tcl_SetResult(interp, (char *) "Type error. Expected ", TCL_STATIC);
      Tcl_AppendElement(interp, (char *) ty->name);
      return TCL_ERROR;
    } else if (!tc) {
      return TCL_ERROR;
    }
    if (flags & SWIG_POINTER_DISOWN) {
      SWIG_Disown((void *) *ptr);
    }
    *ptr = SWIG_TypeCast(tc,(void *) *ptr);
  }
  return TCL_OK;
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtr(Tcl_Interp *interp, Tcl_Obj *oc, void **ptr, swig_type_info *ty, int flags)
{
  return SWIG_ConvertPtrFromString(interp, Tcl_GetStringFromObj(oc,NULL), ptr, ty, flags);
}

/* Convert a pointer value */
SWIGRUNTIME(char *)
SWIG_PointerTypeFromString(char *c) {
  char d;
  /* Pointer values must start with leading underscore. NULL has no type */
  if (*c != '_') {
    return 0;
  }
  c++;
  /* Extract hex value from pointer */
  while ((d = *c)) {
    if (!(((d >= '0') && (d <= '9')) || ((d >= 'a') && (d <= 'f')))) break;
    c++;
  }
  return c;
}

/* Convert a packed value value */
SWIGRUNTIME(int)
SWIG_ConvertPacked(Tcl_Interp *interp, Tcl_Obj *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;
  
  if (!obj) goto type_error;
  c = Tcl_GetStringFromObj(obj,NULL);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return TCL_OK;

type_error:

  if (flags) {
    if (ty) {
      Tcl_SetResult(interp, (char *) "Type error. Expected ", TCL_STATIC);
      Tcl_AppendElement(interp, (char *) ty->name);
      return TCL_ERROR;
    } else {
      Tcl_SetResult(interp, (char *) "Expected packed data.", TCL_STATIC);
      return TCL_ERROR;
    }
  }
  return TCL_ERROR;
}


/* Take a pointer and convert it to a string */
SWIGRUNTIME(void) 
SWIG_MakePtr(char *c, void *ptr, swig_type_info *ty, int flags) {
  if (ptr) {
    *(c++) = '_';
    c = SWIG_PackData(c,&ptr,sizeof(void *));
    strcpy(c,ty->name);
  } else {
    strcpy(c,(char *)"NULL");
  }
  flags = 0;
}

/* Create a new pointer object */
SWIGRUNTIME(Tcl_Obj *)
SWIG_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
  Tcl_Obj *robj;
  char result[512];
  SWIG_MakePtr(result,ptr,type,flags);
  robj = Tcl_NewStringObj(result,-1);
  return robj;
}

SWIGRUNTIME(Tcl_Obj *)
SWIG_NewPackedObj(void *ptr, int sz, swig_type_info *type, int flags) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  flags = 0;
  return Tcl_NewStringObj(result,-1);
}

static Tcl_HashTable   swigconstTable;
static int             swigconstTableinit = 0;

/* Install Constants */
SWIGRUNTIME(void)
SWIG_InstallConstants(Tcl_Interp *interp, swig_const_info constants[]) {
  int i;
  Tcl_Obj *obj;
  Tcl_HashEntry *entryPtr;
  int            newobj;

  if (!swigconstTableinit) {
    Tcl_InitHashTable(&swigconstTable, TCL_STRING_KEYS);
    swigconstTableinit = 1;
  }
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_TCL_INT:
      obj = Tcl_NewIntObj(constants[i].lvalue);
      break;
    case SWIG_TCL_FLOAT:
      obj = Tcl_NewDoubleObj(constants[i].dvalue);
      break;
    case SWIG_TCL_STRING:
      obj = Tcl_NewStringObj((char *) constants[i].pvalue,-1);
      break;
    case SWIG_TCL_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_TCL_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype),0);
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      Tcl_ObjSetVar2(interp,Tcl_NewStringObj(constants[i].name,-1), NULL, obj, TCL_GLOBAL_ONLY);
      entryPtr = Tcl_CreateHashEntry(&swigconstTable, constants[i].name, &newobj);
      Tcl_SetHashValue(entryPtr, (ClientData) obj);
    }
  }
}

SWIGRUNTIME(Tcl_Obj *)
SWIG_GetConstant(const char *key) {
  Tcl_HashEntry *entryPtr;
  if (!swigconstTableinit) return 0;
  entryPtr = Tcl_FindHashEntry(&swigconstTable, key);
  if (entryPtr) {
    return (Tcl_Obj *) Tcl_GetHashValue(entryPtr);
  }
  printf("Searching %s\n", key);
  return 0;
}

/* Get arguments */
SWIGRUNTIME(int)
SWIG_GetArgs(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], const char *fmt, ...)
{
  int        argno = 0, opt = 0, tempi;
  double     tempd;
  const char *c;
  va_list    ap;
  void      *vptr;
  Tcl_Obj   *obj = 0;
  swig_type_info *ty;

  va_start(ap,fmt);
  for (c = fmt; (*c && (*c != ':') && (*c != ';')); c++,argno++) {
    if (*c == '|') {
      opt = 1;
      c++;
    }
    if (argno >= (objc-1)) {
      if (!opt) {
	Tcl_SetResult(interp, (char *) "Wrong # args. ", TCL_STATIC);
	goto argerror;
      } else {
	va_end(ap);
	return TCL_OK;
      }
    }

    vptr = va_arg(ap,void *);
    if (vptr) {
      if (isupper(*c)) {
	obj = SWIG_GetConstant(Tcl_GetStringFromObj(objv[argno+1],0));
	if (!obj) obj = objv[argno+1];
      } else {
	obj = objv[argno+1];
      }
      switch(*c) {
      case 'i': case 'I':
      case 'l': case 'L':
      case 'h': case 'H':
      case 'b': case 'B':
	if (Tcl_GetIntFromObj(interp,obj,&tempi) != TCL_OK) goto argerror;
	if ((*c == 'i') || (*c == 'I')) *((int *)vptr) = tempi;
	else if ((*c == 'l') || (*c == 'L')) *((long *)vptr) = tempi;
	else if ((*c == 'h') || (*c == 'H')) *((short*)vptr) = tempi;
	else if ((*c == 'b') || (*c == 'B')) *((unsigned char *)vptr) = tempi;
	break;
      case 'f': case 'F':
      case 'd': case 'D':
	if (Tcl_GetDoubleFromObj(interp,obj,&tempd) != TCL_OK) goto argerror;
	if ((*c == 'f') || (*c == 'F')) *((float *) vptr) = (float)tempd;
	else if ((*c == 'd') || (*c == 'D')) *((double*) vptr) = tempd;
	break;
      case 's': case 'S':
	if (*(c+1) == '#') {
	  int *vlptr = (int *) va_arg(ap, void *);
	  *((char **) vptr) = Tcl_GetStringFromObj(obj, vlptr);
	  c++;
	} else {
	  *((char **)vptr) = Tcl_GetStringFromObj(obj,NULL);
	}
	break;
      case 'c': case 'C':
	*((char *)vptr) = *(Tcl_GetStringFromObj(obj,NULL));
	break;
      case 'p': case 'P':
	ty = (swig_type_info *) va_arg(ap, void *);
	if (SWIG_ConvertPtr(interp, obj, (void **) vptr, ty, SWIG_POINTER_EXCEPTION) == TCL_ERROR) goto argerror;
	break;
      case 'o': case 'O':
	*((Tcl_Obj **)vptr) = objv[argno+1];
	break;
      default:
	break;
      }
    }
  }
  
  if ((*c != ';') && ((objc-1) > argno)) {
    Tcl_SetResult(interp, (char *) "Wrong # args.", TCL_STATIC);
    goto argerror;
  }
  va_end(ap);
  return TCL_OK;
  
 argerror:
  {
    char temp[32];
    sprintf(temp,"%d", argno+1);
    c = strchr(fmt,':');
    if (!c) c = strchr(fmt,';');
    if (!c) c = (char *)"";
    Tcl_AppendResult(interp,c," argument ", temp, NULL);
    va_end(ap);
    return TCL_ERROR;
  }
}

SWIGRUNTIME(void)
SWIG_ObjectDelete(ClientData clientData) {
  swig_instance *si = (swig_instance *) clientData;
  if ((si) && (si->destroy) && (SWIG_Disown(si->thisvalue))) {
    if (si->classptr->destructor) {
      (si->classptr->destructor)(si->thisvalue);
    }
  }
  Tcl_DecrRefCount(si->thisptr);
  free(si);
}

/* Function to invoke object methods given an instance */
SWIGRUNTIME(int)
SWIG_MethodCommand(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST _objv[])
{
  char *method,   *attrname;
  swig_instance   *inst = (swig_instance *) clientData;
  swig_method     *meth;
  swig_attribute  *attr;
  Tcl_Obj         *oldarg;
  Tcl_Obj         **objv;
  int              rcode;
  swig_class      *cls;
  swig_class      *cls_stack[64];
  int              cls_stack_bi[64];
  int              cls_stack_top = 0;
  int              numconf = 2;
  int              bi;

  objv = (Tcl_Obj **) _objv;
  if (objc < 2) {
    Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
    return TCL_ERROR;
  }
  method = Tcl_GetStringFromObj(objv[1],NULL);
  if (strcmp(method,"-acquire") == 0) {
    inst->destroy = 1;
    SWIG_Acquire(inst->thisvalue);
    return TCL_OK;
  } 
  if (strcmp(method,"-disown") == 0) {
    if (inst->destroy) {
      SWIG_Disown(inst->thisvalue);
    }
    inst->destroy = 0;
    return TCL_OK;
  }
  if (strcmp(method,"-delete") == 0) {
    Tcl_DeleteCommandFromToken(interp,inst->cmdtok);
    return TCL_OK;
  }
  cls_stack[cls_stack_top] = inst->classptr;
  cls_stack_bi[cls_stack_top] = -1;
  cls = inst->classptr;
  while (1) {
    bi = cls_stack_bi[cls_stack_top];
    cls = cls_stack[cls_stack_top];
    if (bi != -1) {
      cls = cls->bases[bi];
      if (cls) {
	cls_stack_bi[cls_stack_top]++;
	cls_stack_top++;
	cls_stack[cls_stack_top] = cls;
	cls_stack_bi[cls_stack_top] = -1;
	continue;
      }
    }
    if (!cls) {
      cls_stack_top--;
      if (cls_stack_top < 0) break;
      else continue;
    }
    cls_stack_bi[cls_stack_top]++;

    meth = cls->methods;
    /* Check for methods */
    while (meth && meth->name) {
      if (strcmp(meth->name,method) == 0) {
	oldarg = objv[1];
	objv[1] = inst->thisptr;
	Tcl_IncrRefCount(inst->thisptr);
	rcode = (*meth->method)(clientData,interp,objc,objv);
	objv[1] = oldarg;
	Tcl_DecrRefCount(inst->thisptr);
	return rcode;
      }
      meth++;
    }
    /* Check class methods for a match */
    if (strcmp(method,"cget") == 0) {
      if (objc < 3) {
	Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
	return TCL_ERROR;
      }
      attrname = Tcl_GetStringFromObj(objv[2],NULL);
      attr = cls->attributes;
      while (attr && attr->name) {
	if ((strcmp(attr->name, attrname) == 0) && (attr->getmethod)) {
	  oldarg = objv[1];
	  objv[1] = inst->thisptr;
	  Tcl_IncrRefCount(inst->thisptr);
	  rcode = (*attr->getmethod)(clientData,interp,2, objv);
	  objv[1] = oldarg;
	  Tcl_DecrRefCount(inst->thisptr);
	  return rcode;
	}
	attr++;
      }
      if (strcmp(attrname, "-this") == 0) {
	Tcl_SetObjResult(interp, Tcl_DuplicateObj(inst->thisptr));
	return TCL_OK;
      }
      if (strcmp(attrname, "-thisown") == 0) {
	if (SWIG_Thisown(inst->thisvalue)) {
	  Tcl_SetResult(interp,(char*)"1",TCL_STATIC);
	} else {
	  Tcl_SetResult(interp,(char*)"0",TCL_STATIC);
	}
	return TCL_OK;
      }
    } else if (strcmp(method, "configure") == 0) {
      int i;
      if (objc < 4) {
	Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
	return TCL_ERROR;
      }
      i = 2;
      while (i < objc) {
	attrname = Tcl_GetStringFromObj(objv[i],NULL);
	attr = cls->attributes;
	while (attr && attr->name) {
	  if ((strcmp(attr->name, attrname) == 0) && (attr->setmethod)) {
	    oldarg = objv[i];
	    objv[i] = inst->thisptr;
	    Tcl_IncrRefCount(inst->thisptr);
	    rcode = (*attr->setmethod)(clientData,interp,3, &objv[i-1]);
	    objv[i] = oldarg;
	    Tcl_DecrRefCount(inst->thisptr);
	    if (rcode != TCL_OK) return rcode;
	    numconf += 2;
	  }
	  attr++;
	}
	i+=2;
      }
    }
  }
  if (strcmp(method,"configure") == 0) {
    if (numconf >= objc) {
      return TCL_OK;
    } else {
      Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
      return TCL_ERROR;
    }
  }
  if (strcmp(method,"cget") == 0) {
      Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
      return TCL_ERROR;
  }

  Tcl_SetResult(interp, (char *) "Invalid method. Must be one of: configure cget -acquire -disown -delete", TCL_STATIC);
  cls = inst->classptr;
  bi = 0;
  while (cls) {
    meth = cls->methods;
    while (meth && meth->name) {
      char *cr = (char *) Tcl_GetStringResult(interp);
      if (!strstr(strchr(cr,':'), meth->name))
	Tcl_AppendElement(interp, (char *) meth->name);
      meth++;
    }
    cls = inst->classptr->bases[bi++];
  }
  return TCL_ERROR;
}

/* Function to create objects */
SWIGRUNTIME(int)
SWIG_ObjectConstructor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
    Tcl_Obj          *newObj = 0;
    void             *thisvalue = 0;
    swig_instance   *newinst = 0;
    swig_class      *classptr = (swig_class *) clientData;
    swig_wrapper     cons = 0;
    char             *name = 0;
    int               firstarg = 0;
    int               thisarg = 0;
    int               destroy = 1; 

    if (!classptr) {
      Tcl_SetResult(interp, (char *) "swig: internal runtime error. No class object defined.", TCL_STATIC);
      return TCL_ERROR;
    }
    cons = classptr->constructor;
    if (objc > 1) {
      char *s = Tcl_GetStringFromObj(objv[1],NULL);
      if (strcmp(s,"-this") == 0) {
	thisarg = 2;
	cons = 0;
      } else if (strcmp(s,"-args") == 0) {
	firstarg = 1;
      } else if (objc == 2) {
	firstarg = 1;
	name = s;
      } else if (objc >= 3) {
	char *s1;
	name = s;
	s1 = Tcl_GetStringFromObj(objv[2],NULL);
	if (strcmp(s1,"-this") == 0) {
	  thisarg = 3;
	  cons = 0;
	} else {
	  firstarg = 1;
	}
      }
    }
    if (cons) {
      int result;
      result = (*cons)(0, interp, objc-firstarg, &objv[firstarg]);
      if (result != TCL_OK) {
	return result;
      }
      newObj = Tcl_DuplicateObj(Tcl_GetObjResult(interp));
      if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
    } else if (thisarg > 0) {
      if (thisarg < objc) {
	destroy = 0;
	newObj = Tcl_DuplicateObj(objv[thisarg]);
	if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
      } else {
	Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
	return TCL_ERROR;
      }
    } else {
      Tcl_SetResult(interp, (char *) "No constructor available.", TCL_STATIC);
      return TCL_ERROR;
    }
    if (SWIG_ConvertPtr(interp,newObj, (void **) &thisvalue, *(classptr->type), SWIG_POINTER_EXCEPTION) == TCL_ERROR) {
      Tcl_DecrRefCount(newObj);
      return TCL_ERROR;
    }
    newinst = (swig_instance *) malloc(sizeof(swig_instance));
    newinst->thisptr = newObj;
    Tcl_IncrRefCount(newObj);
    newinst->thisvalue = thisvalue;
    newinst->classptr = classptr;
    newinst->destroy = destroy;
    if (destroy) {
      SWIG_Acquire(thisvalue);
    }
    newinst->cmdtok = Tcl_CreateObjCommand(interp,name, (swig_wrapper) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
    return TCL_OK;
}


/* This function takes the current result and turns it into an object command */
SWIGRUNTIME(Tcl_Obj *)
SWIG_NewInstanceObj(Tcl_Interp *interp, void *thisvalue, swig_type_info *type, int flags) {
  Tcl_Obj *robj = SWIG_NewPointerObj(thisvalue, type,0);
  /* Check to see if this pointer belongs to a class or not */
  if ((type->clientdata) && (interp)) {
    Tcl_CmdInfo    ci;
    char          *name;
    name = Tcl_GetStringFromObj(robj,NULL);
    if (!Tcl_GetCommandInfo(interp,name, &ci) || (flags)) {
      swig_instance *newinst = (swig_instance *) malloc(sizeof(swig_instance));
      newinst->thisptr = Tcl_DuplicateObj(robj);
      Tcl_IncrRefCount(newinst->thisptr);
      newinst->thisvalue = thisvalue;
      newinst->classptr = (swig_class *) type->clientdata;
      newinst->destroy = flags;
      newinst->cmdtok = Tcl_CreateObjCommand(interp, Tcl_GetStringFromObj(robj,NULL), (swig_wrapper_func) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
      if (flags) {
	SWIG_Acquire(thisvalue);
      }
    }
  }
  return robj;
}

#endif

/* Structure for command table */
typedef struct {
  const char *name;
  int       (*wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
  ClientData  clientdata;
} swig_command_info;

/* Structure for variable linking table */
typedef struct {
  const char *name;
  void *addr;
  char * (*get)(ClientData, Tcl_Interp *, char *, char *, int);
  char * (*set)(ClientData, Tcl_Interp *, char *, char *, int);
} swig_var_info;

#ifdef __cplusplus
}
#endif






/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_Partial swig_types[0] 
#define  SWIGTYPE_p_PartialList swig_types[1] 
#define  SWIGTYPE_p_SampleVector swig_types[2] 
#define  SWIGTYPE_p_AiffFile swig_types[3] 
#define  SWIGTYPE_p_Analyzer swig_types[4] 
#define  SWIGTYPE_p_double swig_types[5] 
#define  SWIGTYPE_p_PartialListIterator swig_types[6] 
#define  SWIGTYPE_p_PartialIterator swig_types[7] 
#define  SWIGTYPE_p_Breakpoint swig_types[8] 
#define  SWIGTYPE_p_BreakpointEnvelope swig_types[9] 
static swig_type_info *swig_types[11];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Tcloris_Init
#define SWIG_name    "tcloris"
#define SWIG_prefix  ""
#define SWIG_version "0.0"


#ifdef __cplusplus
extern "C" {
#endif
#ifdef MAC_TCL
#pragma export on
#endif
SWIGEXPORT(int) SWIG_init(Tcl_Interp *);
#ifdef MAC_TCL
#pragma export off
#endif
#ifdef __cplusplus
}
#endif



	#include<loris.h>
	
	//	import the entire Loris namespace, because
	//	SWIG does not seem to like to wrap functions
	//	with qualified names (like Loris::channelize),
	//	they simply get ignored.
	using namespace Loris;

	//	notification function for Loris debugging
	//	and notifications, installed in initialization
	//	block below:
	static void printf_notifier( const char * s )
	{
		printf("*\t%s\n", s);
	}	
	
	//	exception handling for the procedural interface
	//	(the pi catches all exceptions and handles them
	//	by passing their string descriptions to this 
	//	function):
	static char EXCEPTION_THROWN[256];
	static void exception_handler( const char * s )
	{
		sprintf(EXCEPTION_THROWN, "%255s\0", s);
	}


#include <vector>
#include <string>
using std::vector;
using std::string;

// helper function for converting a string to a
// vector of doubles (this will work anywhere)
static bool fill_vector( const string & s, vector<double> & v )
{
	std::string::size_type beg, end;
	const std::string numparts("1234567890+-.");
	beg = s.find_first_of( numparts );
	while ( beg != std::string::npos )
	{
		end = s.find_first_not_of( numparts, beg );
		if ( end == std::string::npos )
			end = s.length();

		double x = atof( s.c_str() + beg );
		v.push_back(x);

		beg = s.find_first_of( numparts, end );
	}
	return true;
}



#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


#define SWIG_exception(a,b)   { Tcl_SetResult(interp,b,TCL_VOLATILE); SWIG_fail; }


	#include <Exception.h>
	#include <Notifier.h>
	#include <string>
	#include <vector>
	
	//	Helper function for dilate: 
	//
	//	convert a string into a vector of doubles,
	//	ignore any extraneous characters:
	static std::vector<double> strtovec( const std::string & s )
	{
		std::vector<double> v;
		std::string::size_type beg, end;
		const std::string numparts("1234567890+-.");
		beg = s.find_first_of( numparts );
		while ( beg != std::string::npos )
		{
			end = s.find_first_not_of( numparts, beg );
			if ( end == std::string::npos )
				end = s.length();
	
			double x = atof( s.c_str() + beg );
			v.push_back(x);
	
			beg = s.find_first_of( numparts, end );
		}
		return v;
	}

	void dilate_str( PartialList * partials, 
					 char * initial_times, char * target_times )
	{
		std::vector<double> ivec = strtovec( initial_times );
		std::vector<double> tvec = strtovec( target_times );
		
		Loris::debugger << ivec.size() << " initial points, " 
						<< tvec.size() << " target points" << Loris::endl;
			
		if ( ivec.size() != tvec.size() )
			Throw( Loris::InvalidArgument, "Invalid arguments to dilate(): there must be as many target points as initial points" );
				
		double * initial = &(ivec[0]);
		double * target = &(tvec[0]);
		int npts = ivec.size();
		dilate( partials, initial, target, npts );
	}
	
	void dilate_v( PartialList * partials, vector<double> & ivec, vector<double> & tvec )
	{
		Loris::debugger << ivec.size() << " initial points, " 
						<< tvec.size() << " target points" << Loris::endl;
						
		if ( ivec.size() != tvec.size() )
			Throw( Loris::InvalidArgument, "Invalid arguments to dilate(): there must be as many target points as initial points" );

		double * initial = &(ivec[0]);
		double * target = &(tvec[0]);
		int npts = ivec.size();
		dilate( partials, initial, target, npts );
	}
		


	void dilate_s( PartialList * partials, 
				   char * initial_times, char * target_times )
	{
		std::vector<double> ivec;
		fill_vector( initial_times, ivec );
		std::vector<double> tvec;
		fill_vector( target_times, tvec );
		
		dilate_v( partials, ivec, tvec );
	}


	PartialList * importSdif( const char * path )
	{
		PartialList * dst = createPartialList();
		importSdif( path, dst );

		// check for exception:
		if (*EXCEPTION_THROWN)
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	PartialList * importSpc( const char * path )
	{
		PartialList * dst = createPartialList();
		importSpc( path, dst );

		// check for exception:
		if (*EXCEPTION_THROWN)
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	PartialList * morph( const PartialList * src0, const PartialList * src1, 
						 const BreakpointEnvelope * ffreq, 
						 const BreakpointEnvelope * famp, 
						 const BreakpointEnvelope * fbw )
	{
		PartialList * dst = createPartialList();
		morph( src0, src1, ffreq, famp, fbw, dst );
		
		// check for exception:
		if (*EXCEPTION_THROWN)
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	SampleVector * synthesize( const PartialList * partials, double srate = 44100.0 )
	{
		SampleVector * dst = createSampleVector(0);
		synthesize( partials, dst, srate );
				
		// check for exception:
		if (*EXCEPTION_THROWN)
		{
			destroySampleVector( dst );
			dst = NULL;
		}
		return dst;
	}


	PartialList * extractLabeled( PartialList * partials, long label )
	{
		PartialList * dst = createPartialList();
		spliceByLabel( partials, label, dst );
		
		// check for exception:
		if (*EXCEPTION_THROWN)
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	const char * version( void )
	{
		static const char * vstr = LORIS_VERSION_STR;
		return vstr;
	}


	#include <Exception.h>
	#include <stdexcept>


	#include<AiffFile.h>

SampleVector *AiffFile_samples(AiffFile *self){
			SampleVector * vec = new SampleVector( self->sampleFrames() );
			if ( ! vec->empty() )
				self->getSamples( &((*vec)[0]), &((*vec)[vec->size()]) );
			return vec;
		}

	#include<Analyzer.h>
	#include<BreakpointEnvelope.h>
	#include<Partial.h>

Analyzer *new_Analyzer(double resolutionHz,double windowWidthHz){
			if ( windowWidthHz == 0. )
				windowWidthHz = resolutionHz;
			return new Analyzer( resolutionHz, windowWidthHz );
		}
Analyzer *Analyzer_copy(Analyzer *self){
			return new Analyzer( *self );
		}
PartialList *Analyzer_analyze__SWIG_0(Analyzer *self,SampleVector const *vec,double srate){
			PartialList * partials = new PartialList();
			if ( ! vec->empty() )
				self->analyze( &((*vec)[0]), &((*vec)[vec->size()]), srate );
			partials->splice( partials->end(), self->partials() );
			return partials;
		}
PartialList *Analyzer_analyze__SWIG_1(Analyzer *self,SampleVector const *vec,double srate,BreakpointEnvelope *env){
			PartialList * partials = new PartialList();
			if ( ! vec->empty() )
				self->analyze( *vec, srate, *env );
			partials->splice( partials->end(), self->partials() );
			return partials;
		}

	#include<BreakpointEnvelope.h>

BreakpointEnvelope *BreakpointEnvelope_copy(BreakpointEnvelope *self){
			return new BreakpointEnvelope( *self );
		}

	BreakpointEnvelope *
	BreakpointEnvelopeWithValue( double initialValue )
	{
		return new BreakpointEnvelope( initialValue );
	}

SampleVector *SampleVector_copy(SampleVector *self){
			return new SampleVector( *self );
		}
double SampleVector_getAt(SampleVector *self,unsigned long idx){
			if ( idx >= self->size() )
				throw std::out_of_range("SampleVector::getAt index out of range");
			return (*self)[idx];
		}
void SampleVector_setAt(SampleVector *self,unsigned long idx,double x){
			if ( idx >= self->size() )
				throw std::out_of_range("SampleVector::setAt index out of range");
			(*self)[idx] = x;
		}

#include<Partial.h>
#include<PartialList.h>
#include<PartialUtils.h>
#include<Notifier.h>
#include <list>

using Loris::debugger;
using Loris::Partial;
using Loris::PartialList;
using Loris::PartialListIterator;
using Loris::Breakpoint;

typedef Loris::Partial::iterator PartialIterator;

PartialList *new_PartialList(){
			debugger << "creating an empty list of Partials" << Loris::endl;
			return new PartialList();
		}
void delete_PartialList(PartialList *self){
			debugger << "destroying  a list of " << self->size() << " Partials" << Loris::endl;
			delete self;
		}
PartialList *PartialList_copy(PartialList *self){
			return new PartialList( *self );
		}
void PartialList_timeSpan(PartialList *self,double *tmin_out,double *tmax_out){
		 	std::pair<double, double> span = 
		 		Loris::PartialUtils::timeSpan( self->begin(), self->end() );
		 	*tmin_out = span.first;
		 	*tmax_out = span.second;
		 }
PartialListIterator *PartialListIterator_copy(PartialListIterator *self){
			return new PartialListIterator( *self );
		}
PartialListIterator *PartialListIterator_next(PartialListIterator *self){
			PartialListIterator * next = new PartialListIterator(*self);
			++(*next);
			return next;
		}
PartialListIterator *PartialListIterator_prev(PartialListIterator *self){
			PartialListIterator * prev = new PartialListIterator(*self);
			--(*prev);
			return prev;
		}
Partial *PartialListIterator_partial(PartialListIterator *self){
			Partial & current = **self;
			return &current;
		}
int PartialListIterator_equals(PartialListIterator *self,PartialListIterator *other){
			return *self == *other;
		}
int PartialListIterator_isInRange(PartialListIterator *self,PartialListIterator const *begin,PartialListIterator const *end){	
		 	PartialListIterator it;
		 	for ( it = *begin; it != *end; ++it )
		 	{
		 		if ( it == *self )
		 			return true;
		 	}
		 	return false;
		 }
Partial *Partial_copy(Partial *self){
			return new Partial( *self );
		}
int Partial_equals(Partial *self,Partial *other){
			return *self == *other;
		}
Breakpoint *PartialIterator_breakpoint(PartialIterator *self){ 
			return &(self->breakpoint());
		}
PartialIterator *PartialIterator_copy(PartialIterator *self){
			return new PartialIterator( *self );
		}
PartialIterator *PartialIterator_next(PartialIterator *self){
			PartialIterator * next = new PartialIterator(*self);
			++(*next);
			return next;
		}
PartialIterator *PartialIterator_prev(PartialIterator *self){
			PartialIterator * prev = new PartialIterator(*self);
			--(*prev);
			return prev;
		}
int PartialIterator_equals(PartialIterator *self,PartialIterator *other){
			return *self == *other;
		}
int PartialIterator_isInRange(PartialIterator *self,PartialIterator const *begin,PartialIterator const *end){	
		 	PartialIterator it;
		 	for ( it = *begin; it != *end; ++it )
		 	{
		 		if ( it == *self )
		 			return true;
		 	}
		 	return false;
		 }
Breakpoint *Breakpoint_copy(Breakpoint *self){
			return new Breakpoint( *self );
		}
int Breakpoint_equals(Breakpoint *self,Breakpoint *other){
			return *self == *other;
		}
#ifdef __cplusplus
extern "C" {
#endif
static int
_wrap_channelize(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    int arg3 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooi:channelize partials refFreqEnvelope refLabel ",0,0,&arg3) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        channelize(arg1,arg2,arg3);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_createFreqReference(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    double arg3 ;
    long arg4 = (long) 0 ;
    BreakpointEnvelope *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"odd|l:createFreqReference partials minFreq maxFreq numSamps ",0,&arg2,&arg3,&arg4) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        result = (BreakpointEnvelope *)createFreqReference(arg1,arg2,arg3,arg4);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_BreakpointEnvelope,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_dilate(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    char *arg2 ;
    char *arg3 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oss:dilate partials initial_times target_times ",0,&arg2,&arg3) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        dilate_s(arg1,arg2,arg3);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_distill(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:distill partials ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        distill(arg1);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_exportAiff(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 ;
    SampleVector *arg2 = (SampleVector *) 0 ;
    double arg3 = (double) 44100.0 ;
    int arg4 = (int) 1 ;
    int arg5 = (int) 16 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"so|dii:exportAiff path samples samplerate nchannels bitsPerSamp ",&arg1,0,&arg3,&arg4,&arg5) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        exportAiff((char const *)arg1,arg2,arg3,arg4,arg5);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_exportSdif(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 ;
    PartialList *arg2 = (PartialList *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"so:exportSdif path partials ",&arg1,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        exportSdif((char const *)arg1,arg2);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_exportSpc(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 ;
    PartialList *arg2 = (PartialList *) 0 ;
    double arg3 ;
    int arg4 = (int) true ;
    double arg5 = (double) 0. ;
    
    if (SWIG_GetArgs(interp, objc, objv,"sod|id:exportSpc path partials midiPitch enhanced endApproachTime ",&arg1,0,&arg3,&arg4,&arg5) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        exportSpc((char const *)arg1,arg2,arg3,arg4,arg5);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_importSdif(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 ;
    PartialList *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"s:importSdif path ",&arg1) == TCL_ERROR) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        result = (PartialList *)importSdif((char const *)arg1);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialList,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_importSpc(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 ;
    PartialList *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"s:importSpc path ",&arg1) == TCL_ERROR) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        result = (PartialList *)importSpc((char const *)arg1);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialList,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_morph(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    BreakpointEnvelope *arg3 = (BreakpointEnvelope *) 0 ;
    BreakpointEnvelope *arg4 = (BreakpointEnvelope *) 0 ;
    BreakpointEnvelope *arg5 = (BreakpointEnvelope *) 0 ;
    PartialList *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooooo:morph src0 src1 ffreq famp fbw ",0,0,0,0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[3], (void **) &arg3, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[4], (void **) &arg4, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[5], (void **) &arg5, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        result = (PartialList *)morph((PartialList const *)arg1,(PartialList const *)arg2,(BreakpointEnvelope const *)arg3,(BreakpointEnvelope const *)arg4,(BreakpointEnvelope const *)arg5);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialList,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_synthesize(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 = (double) 44100.0 ;
    SampleVector *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o|d:synthesize partials srate ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        result = (SampleVector *)synthesize((PartialList const *)arg1,arg2);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_SampleVector,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_sift(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:sift partials ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        sift(arg1);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_extractLabeled(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    long arg2 ;
    PartialList *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ol:extractLabeled partials label ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        result = (PartialList *)extractLabeled(arg1,arg2);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialList,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_scaleAmp(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:scaleAmp partials ampEnv ",0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        scaleAmp(arg1,arg2);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_scaleNoiseRatio(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:scaleNoiseRatio partials noiseEnv ",0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        scaleNoiseRatio(arg1,arg2);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_shiftPitch(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:shiftPitch partials pitchEnv ",0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        shiftPitch(arg1,arg2);
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_version(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":version ") == TCL_ERROR) SWIG_fail;
    {
        *EXCEPTION_THROWN = '\0';
        result = (char *)version();
        
        if (*EXCEPTION_THROWN)
        {
            SWIG_exception( SWIG_UnknownError, EXCEPTION_THROWN );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewStringObj(result,-1));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_new_AiffFile(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 ;
    AiffFile *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"s:new_AiffFile filename ",&arg1) == TCL_ERROR) SWIG_fail;
    {
        try
        {
            result = (AiffFile *)new AiffFile((char const *)arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_AiffFile,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_delete_AiffFile(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    AiffFile *arg1 = (AiffFile *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:delete_AiffFile self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_AiffFile_channels(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    AiffFile *arg1 = (AiffFile *) 0 ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AiffFile_channels self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (int)((AiffFile const *)arg1)->channels();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_AiffFile_sampleFrames(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    AiffFile *arg1 = (AiffFile *) 0 ;
    unsigned long result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AiffFile_sampleFrames self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (unsigned long)((AiffFile const *)arg1)->sampleFrames();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_AiffFile_sampleRate(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    AiffFile *arg1 = (AiffFile *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AiffFile_sampleRate self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((AiffFile const *)arg1)->sampleRate();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_AiffFile_sampleSize(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    AiffFile *arg1 = (AiffFile *) 0 ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AiffFile_sampleSize self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (int)((AiffFile const *)arg1)->sampleSize();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_AiffFile_samples(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    AiffFile *arg1 = (AiffFile *) 0 ;
    SampleVector *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AiffFile_samples self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (SampleVector *)AiffFile_samples(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_SampleVector,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static void swig_delete_AiffFile(void *obj) {
AiffFile *arg1 = (AiffFile *) obj;
delete arg1;
}
static swig_method swig_AiffFile_methods[] = {
    {"channels", _wrap_AiffFile_channels}, 
    {"sampleFrames", _wrap_AiffFile_sampleFrames}, 
    {"sampleRate", _wrap_AiffFile_sampleRate}, 
    {"sampleSize", _wrap_AiffFile_sampleSize}, 
    {"samples", _wrap_AiffFile_samples}, 
    {0,0}
};
static swig_attribute swig_AiffFile_attributes[] = {
    {0,0,0}
};
static swig_class *swig_AiffFile_bases[] = {0};
swig_class _wrap_class_AiffFile = { "AiffFile", &SWIGTYPE_p_AiffFile,_wrap_new_AiffFile, swig_delete_AiffFile, swig_AiffFile_methods, swig_AiffFile_attributes, swig_AiffFile_bases };
static int
_wrap_new_Analyzer(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    double arg1 ;
    double arg2 = (double) 0. ;
    Analyzer *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"d|d:new_Analyzer resolutionHz windowWidthHz ",&arg1,&arg2) == TCL_ERROR) SWIG_fail;
    {
        try
        {
            result = (Analyzer *)new_Analyzer(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_Analyzer,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    Analyzer *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Analyzer_copy self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (Analyzer *)Analyzer_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_Analyzer,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_analyze__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    SampleVector *arg2 = (SampleVector *) 0 ;
    double arg3 ;
    PartialList *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ood:Analyzer_analyze self vec srate ",0,0,&arg3) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (PartialList *)Analyzer_analyze__SWIG_0(arg1,(SampleVector const *)arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialList,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_analyze__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    SampleVector *arg2 = (SampleVector *) 0 ;
    double arg3 ;
    BreakpointEnvelope *arg4 = (BreakpointEnvelope *) 0 ;
    PartialList *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oodo:Analyzer_analyze self vec srate env ",0,0,&arg3,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[4], (void **) &arg4, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (PartialList *)Analyzer_analyze__SWIG_1(arg1,(SampleVector const *)arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialList,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_analyze(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(interp, argv[0], (void **) &ptr, SWIGTYPE_p_Analyzer, 0) == TCL_ERROR) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(interp, argv[1], (void **) &ptr, SWIGTYPE_p_SampleVector, 0) == TCL_ERROR) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    double tmp;
                    if (Tcl_GetDoubleFromObj(NULL,argv[2],&tmp) == TCL_ERROR) _v = 0;
                    else _v = 1;
                }
                if (_v) {
                    return _wrap_Analyzer_analyze__SWIG_0(clientData, interp, objc, objv);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(interp, argv[0], (void **) &ptr, SWIGTYPE_p_Analyzer, 0) == TCL_ERROR) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(interp, argv[1], (void **) &ptr, SWIGTYPE_p_SampleVector, 0) == TCL_ERROR) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    double tmp;
                    if (Tcl_GetDoubleFromObj(NULL,argv[2],&tmp) == TCL_ERROR) _v = 0;
                    else _v = 1;
                }
                if (_v) {
                    {
                        void *ptr;
                        if (SWIG_ConvertPtr(interp, argv[3], (void **) &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == TCL_ERROR) {
                            _v = 0;
                        }else {
                            _v = 1;
                        }
                    }
                    if (_v) {
                        return _wrap_Analyzer_analyze__SWIG_1(clientData, interp, objc, objv);
                    }
                }
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'Analyzer_analyze'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_Analyzer_freqResolution(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Analyzer_freqResolution self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->freqResolution();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_ampFloor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Analyzer_ampFloor self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->ampFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_windowWidth(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Analyzer_windowWidth self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->windowWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_sidelobeLevel(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Analyzer_sidelobeLevel self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->sidelobeLevel();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_freqFloor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Analyzer_freqFloor self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->freqFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_hopTime(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Analyzer_hopTime self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->hopTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_freqDrift(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Analyzer_freqDrift self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->freqDrift();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_cropTime(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Analyzer_cropTime self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->cropTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_bwRegionWidth(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Analyzer_bwRegionWidth self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->bwRegionWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_setFreqResolution(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Analyzer_setFreqResolution self x ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->setFreqResolution(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_setAmpFloor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Analyzer_setAmpFloor self x ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->setAmpFloor(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_setWindowWidth(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Analyzer_setWindowWidth self x ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->setWindowWidth(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_setSidelobeLevel(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Analyzer_setSidelobeLevel self x ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->setSidelobeLevel(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_setFreqFloor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Analyzer_setFreqFloor self x ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->setFreqFloor(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_setFreqDrift(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Analyzer_setFreqDrift self x ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->setFreqDrift(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_setHopTime(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Analyzer_setHopTime self x ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->setHopTime(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_setCropTime(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Analyzer_setCropTime self x ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->setCropTime(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Analyzer_setBwRegionWidth(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Analyzer_setBwRegionWidth self x ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->setBwRegionWidth(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_delete_Analyzer(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Analyzer *arg1 = (Analyzer *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:delete_Analyzer self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static void swig_delete_Analyzer(void *obj) {
Analyzer *arg1 = (Analyzer *) obj;
delete arg1;
}
static swig_method swig_Analyzer_methods[] = {
    {"copy", _wrap_Analyzer_copy}, 
    {"analyze", _wrap_Analyzer_analyze}, 
    {"freqResolution", _wrap_Analyzer_freqResolution}, 
    {"ampFloor", _wrap_Analyzer_ampFloor}, 
    {"windowWidth", _wrap_Analyzer_windowWidth}, 
    {"sidelobeLevel", _wrap_Analyzer_sidelobeLevel}, 
    {"freqFloor", _wrap_Analyzer_freqFloor}, 
    {"hopTime", _wrap_Analyzer_hopTime}, 
    {"freqDrift", _wrap_Analyzer_freqDrift}, 
    {"cropTime", _wrap_Analyzer_cropTime}, 
    {"bwRegionWidth", _wrap_Analyzer_bwRegionWidth}, 
    {"setFreqResolution", _wrap_Analyzer_setFreqResolution}, 
    {"setAmpFloor", _wrap_Analyzer_setAmpFloor}, 
    {"setWindowWidth", _wrap_Analyzer_setWindowWidth}, 
    {"setSidelobeLevel", _wrap_Analyzer_setSidelobeLevel}, 
    {"setFreqFloor", _wrap_Analyzer_setFreqFloor}, 
    {"setFreqDrift", _wrap_Analyzer_setFreqDrift}, 
    {"setHopTime", _wrap_Analyzer_setHopTime}, 
    {"setCropTime", _wrap_Analyzer_setCropTime}, 
    {"setBwRegionWidth", _wrap_Analyzer_setBwRegionWidth}, 
    {0,0}
};
static swig_attribute swig_Analyzer_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Analyzer_bases[] = {0};
swig_class _wrap_class_Analyzer = { "Analyzer", &SWIGTYPE_p_Analyzer,_wrap_new_Analyzer, swig_delete_Analyzer, swig_Analyzer_methods, swig_Analyzer_attributes, swig_Analyzer_bases };
static int
_wrap_new_BreakpointEnvelope__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    BreakpointEnvelope *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":new_BreakpointEnvelope ") == TCL_ERROR) SWIG_fail;
    {
        try
        {
            result = (BreakpointEnvelope *)new BreakpointEnvelope();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_BreakpointEnvelope,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_new_BreakpointEnvelope__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    double arg1 ;
    BreakpointEnvelope *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"d:new_BreakpointEnvelope initialValue ",&arg1) == TCL_ERROR) SWIG_fail;
    {
        try
        {
            result = (BreakpointEnvelope *)new BreakpointEnvelope(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_BreakpointEnvelope,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_new_BreakpointEnvelope(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 0) {
        return _wrap_new_BreakpointEnvelope__SWIG_0(clientData, interp, objc, objv);
    }
    if (argc == 1) {
        int _v;
        {
            double tmp;
            if (Tcl_GetDoubleFromObj(NULL,argv[0],&tmp) == TCL_ERROR) _v = 0;
            else _v = 1;
        }
        if (_v) {
            return _wrap_new_BreakpointEnvelope__SWIG_1(clientData, interp, objc, objv);
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'new_BreakpointEnvelope'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_delete_BreakpointEnvelope(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:delete_BreakpointEnvelope self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_BreakpointEnvelope_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
    BreakpointEnvelope *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:BreakpointEnvelope_copy self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelope_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_BreakpointEnvelope,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_BreakpointEnvelope_insertBreakpoint(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
    double arg2 ;
    double arg3 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"odd:BreakpointEnvelope_insertBreakpoint self time value ",0,&arg2,&arg3) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->insertBreakpoint(arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_BreakpointEnvelope_valueAt(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
    double arg2 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:BreakpointEnvelope_valueAt self x ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((BreakpointEnvelope const *)arg1)->valueAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static void swig_delete_BreakpointEnvelope(void *obj) {
BreakpointEnvelope *arg1 = (BreakpointEnvelope *) obj;
delete arg1;
}
static swig_method swig_BreakpointEnvelope_methods[] = {
    {"copy", _wrap_BreakpointEnvelope_copy}, 
    {"insertBreakpoint", _wrap_BreakpointEnvelope_insertBreakpoint}, 
    {"valueAt", _wrap_BreakpointEnvelope_valueAt}, 
    {0,0}
};
static swig_attribute swig_BreakpointEnvelope_attributes[] = {
    {0,0,0}
};
static swig_class *swig_BreakpointEnvelope_bases[] = {0};
swig_class _wrap_class_BreakpointEnvelope = { "BreakpointEnvelope", &SWIGTYPE_p_BreakpointEnvelope,_wrap_new_BreakpointEnvelope, swig_delete_BreakpointEnvelope, swig_BreakpointEnvelope_methods, swig_BreakpointEnvelope_attributes, swig_BreakpointEnvelope_bases };
static int
_wrap_BreakpointEnvelopeWithValue(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    double arg1 ;
    BreakpointEnvelope *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"d:BreakpointEnvelopeWithValue initialValue ",&arg1) == TCL_ERROR) SWIG_fail;
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelopeWithValue(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_BreakpointEnvelope,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_new_SampleVector(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    unsigned long arg1 = (unsigned long) 0 ;
    SampleVector *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"|l:new_SampleVector size ",&arg1) == TCL_ERROR) SWIG_fail;
    {
        try
        {
            result = (SampleVector *)new SampleVector(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_SampleVector,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_delete_SampleVector(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    SampleVector *arg1 = (SampleVector *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:delete_SampleVector self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SampleVector_clear(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    SampleVector *arg1 = (SampleVector *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:SampleVector_clear self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->clear();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SampleVector_resize(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    SampleVector *arg1 = (SampleVector *) 0 ;
    unsigned long arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ol:SampleVector_resize self size ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->resize(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SampleVector_size(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    SampleVector *arg1 = (SampleVector *) 0 ;
    unsigned long result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:SampleVector_size self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (unsigned long)(arg1)->size();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SampleVector_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    SampleVector *arg1 = (SampleVector *) 0 ;
    SampleVector *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:SampleVector_copy self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (SampleVector *)SampleVector_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_SampleVector,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SampleVector_getAt(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    SampleVector *arg1 = (SampleVector *) 0 ;
    unsigned long arg2 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ol:SampleVector_getAt self idx ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)SampleVector_getAt(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SampleVector_setAt(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    SampleVector *arg1 = (SampleVector *) 0 ;
    unsigned long arg2 ;
    double arg3 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"old:SampleVector_setAt self idx x ",0,&arg2,&arg3) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            SampleVector_setAt(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static void swig_delete_SampleVector(void *obj) {
SampleVector *arg1 = (SampleVector *) obj;
delete arg1;
}
static swig_method swig_SampleVector_methods[] = {
    {"clear", _wrap_SampleVector_clear}, 
    {"resize", _wrap_SampleVector_resize}, 
    {"size", _wrap_SampleVector_size}, 
    {"copy", _wrap_SampleVector_copy}, 
    {"getAt", _wrap_SampleVector_getAt}, 
    {"setAt", _wrap_SampleVector_setAt}, 
    {0,0}
};
static swig_attribute swig_SampleVector_attributes[] = {
    {0,0,0}
};
static swig_class *swig_SampleVector_bases[] = {0};
swig_class _wrap_class_SampleVector = { "SampleVector", &SWIGTYPE_p_SampleVector,_wrap_new_SampleVector, swig_delete_SampleVector, swig_SampleVector_methods, swig_SampleVector_attributes, swig_SampleVector_bases };
static int
_wrap_new_PartialList(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":new_PartialList ") == TCL_ERROR) SWIG_fail;
    {
        try
        {
            result = (PartialList *)new_PartialList();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialList,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_delete_PartialList(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:delete_PartialList self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            delete_PartialList(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialList_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    PartialList *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:PartialList_copy self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (PartialList *)PartialList_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialList,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialList_timeSpan(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    double *arg2 = (double *) 0 ;
    double *arg3 = (double *) 0 ;
    double temp2 ;
    double temp3 ;
    
    arg2 = &temp2;
    arg3 = &temp3;
    if (SWIG_GetArgs(interp, objc, objv,"o:PartialList_timeSpan self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            PartialList_timeSpan(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    {
        Tcl_Obj *o;
        o = Tcl_NewDoubleObj((double) *(arg2));
        Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
    }
    {
        Tcl_Obj *o;
        o = Tcl_NewDoubleObj((double) *(arg3));
        Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialList_clear(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:PartialList_clear self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->clear();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialList_size(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    unsigned long result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:PartialList_size self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (unsigned long)(arg1)->size();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialList_begin(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    PartialListIterator result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:PartialList_begin self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (arg1)->begin();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultptr;
        resultptr = new PartialListIterator((PartialListIterator &) result);
        Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp,(void*) resultptr, SWIGTYPE_p_PartialListIterator,1));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialList_end(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    PartialListIterator result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:PartialList_end self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (arg1)->end();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultptr;
        resultptr = new PartialListIterator((PartialListIterator &) result);
        Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp,(void*) resultptr, SWIGTYPE_p_PartialListIterator,1));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialList_insert(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    PartialListIterator arg2 ;
    Partial *arg3 = 0 ;
    PartialListIterator result;
    PartialListIterator *argp2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:PartialList_insert self position partial ",0,0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &argp2, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION ) != TCL_OK)) SWIG_fail;
    arg2 = *argp2; 
    if ((SWIG_ConvertPtr(interp, objv[3], (void **) &arg3, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (arg1)->insert(arg2,(Partial const &)*arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultptr;
        resultptr = new PartialListIterator((PartialListIterator &) result);
        Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp,(void*) resultptr, SWIGTYPE_p_PartialListIterator,1));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialList_erase(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    PartialListIterator arg2 ;
    PartialListIterator *argp2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:PartialList_erase self position ",0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &argp2, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION ) != TCL_OK)) SWIG_fail;
    arg2 = *argp2; 
    {
        try
        {
            (arg1)->erase(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialList_splice(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialList *arg1 = (PartialList *) 0 ;
    PartialListIterator arg2 ;
    PartialList *arg3 = 0 ;
    PartialListIterator *argp2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:PartialList_splice self position list ",0,0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &argp2, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION ) != TCL_OK)) SWIG_fail;
    arg2 = *argp2; 
    if ((SWIG_ConvertPtr(interp, objv[3], (void **) &arg3, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->splice(arg2,*arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static void swig_delete_PartialList(void *obj) {
PartialList *arg1 = (PartialList *) obj;
delete_PartialList(arg1);
}
static swig_method swig_PartialList_methods[] = {
    {"copy", _wrap_PartialList_copy}, 
    {"timeSpan", _wrap_PartialList_timeSpan}, 
    {"clear", _wrap_PartialList_clear}, 
    {"size", _wrap_PartialList_size}, 
    {"begin", _wrap_PartialList_begin}, 
    {"end", _wrap_PartialList_end}, 
    {"insert", _wrap_PartialList_insert}, 
    {"erase", _wrap_PartialList_erase}, 
    {"splice", _wrap_PartialList_splice}, 
    {0,0}
};
static swig_attribute swig_PartialList_attributes[] = {
    {0,0,0}
};
static swig_class *swig_PartialList_bases[] = {0};
swig_class _wrap_class_PartialList = { "PartialList", &SWIGTYPE_p_PartialList,_wrap_new_PartialList, swig_delete_PartialList, swig_PartialList_methods, swig_PartialList_attributes, swig_PartialList_bases };
static int
_wrap_PartialListIterator_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PartialListIterator *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:PartialListIterator_copy self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialListIterator,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialListIterator_next(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PartialListIterator *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:PartialListIterator_next self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_next(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialListIterator,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialListIterator_prev(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PartialListIterator *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:PartialListIterator_prev self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_prev(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialListIterator,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialListIterator_partial(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    Partial *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:PartialListIterator_partial self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (Partial *)PartialListIterator_partial(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_Partial,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialListIterator_equals(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PartialListIterator *arg2 = (PartialListIterator *) 0 ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:PartialListIterator_equals self other ",0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (int)PartialListIterator_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialListIterator_isInRange(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PartialListIterator *arg2 = (PartialListIterator *) 0 ;
    PartialListIterator *arg3 = (PartialListIterator *) 0 ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:PartialListIterator_isInRange self begin end ",0,0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[3], (void **) &arg3, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (int)PartialListIterator_isInRange(arg1,(PartialListIterator const *)arg2,(PartialListIterator const *)arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_new_PartialListIterator(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialListIterator *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":new_PartialListIterator ") == TCL_ERROR) SWIG_fail;
    {
        try
        {
            result = (PartialListIterator *)new PartialListIterator();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialListIterator,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_delete_PartialListIterator(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:delete_PartialListIterator self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static void swig_delete_PartialListIterator(void *obj) {
PartialListIterator *arg1 = (PartialListIterator *) obj;
delete arg1;
}
static swig_method swig_PartialListIterator_methods[] = {
    {"copy", _wrap_PartialListIterator_copy}, 
    {"next", _wrap_PartialListIterator_next}, 
    {"prev", _wrap_PartialListIterator_prev}, 
    {"partial", _wrap_PartialListIterator_partial}, 
    {"equals", _wrap_PartialListIterator_equals}, 
    {"isInRange", _wrap_PartialListIterator_isInRange}, 
    {0,0}
};
static swig_attribute swig_PartialListIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_PartialListIterator_bases[] = {0};
swig_class _wrap_class_PartialListIterator = { "PartialListIterator", &SWIGTYPE_p_PartialListIterator,_wrap_new_PartialListIterator, swig_delete_PartialListIterator, swig_PartialListIterator_methods, swig_PartialListIterator_attributes, swig_PartialListIterator_bases };
static int
_wrap_new_Partial(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":new_Partial ") == TCL_ERROR) SWIG_fail;
    {
        try
        {
            result = (Partial *)new Partial();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_Partial,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_delete_Partial(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:delete_Partial self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_label(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Partial_label self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (int)((Partial const *)arg1)->label();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_initialPhase(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Partial_initialPhase self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Partial const *)arg1)->initialPhase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_startTime(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Partial_startTime self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Partial const *)arg1)->startTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_endTime(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Partial_endTime self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Partial const *)arg1)->endTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_duration(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Partial_duration self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Partial const *)arg1)->duration();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_numBreakpoints(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    long result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Partial_numBreakpoints self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (long)((Partial const *)arg1)->numBreakpoints();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_setLabel(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    int arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oi:Partial_setLabel self l ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->setLabel(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_begin(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    PartialIterator result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Partial_begin self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (arg1)->begin();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator((PartialIterator &) result);
        Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp,(void*) resultptr, SWIGTYPE_p_PartialIterator,1));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_end(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    PartialIterator result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Partial_end self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (arg1)->end();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator((PartialIterator &) result);
        Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp,(void*) resultptr, SWIGTYPE_p_PartialIterator,1));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_insert(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    Breakpoint *arg3 = 0 ;
    PartialIterator result;
    
    if (SWIG_GetArgs(interp, objc, objv,"odo:Partial_insert self time bp ",0,&arg2,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[3], (void **) &arg3, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (arg1)->insert(arg2,(Breakpoint const &)*arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator((PartialIterator &) result);
        Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp,(void*) resultptr, SWIGTYPE_p_PartialIterator,1));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_findAfter(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    PartialIterator result;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Partial_findAfter self time ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (arg1)->findAfter(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator((PartialIterator &) result);
        Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp,(void*) resultptr, SWIGTYPE_p_PartialIterator,1));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_findNearest(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    PartialIterator result;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Partial_findNearest self time ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (arg1)->findNearest(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator((PartialIterator &) result);
        Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp,(void*) resultptr, SWIGTYPE_p_PartialIterator,1));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_erase(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    PartialIterator *arg2 = 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:Partial_erase self pos ",0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->erase(*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_frequencyAt(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Partial_frequencyAt self time ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Partial const *)arg1)->frequencyAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_amplitudeAt(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Partial_amplitudeAt self time ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Partial const *)arg1)->amplitudeAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_bandwidthAt(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Partial_bandwidthAt self time ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Partial const *)arg1)->bandwidthAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_phaseAt(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Partial_phaseAt self time ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((Partial const *)arg1)->phaseAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    Partial *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Partial_copy self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (Partial *)Partial_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_Partial,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Partial_equals(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Partial *arg1 = (Partial *) 0 ;
    Partial *arg2 = (Partial *) 0 ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:Partial_equals self other ",0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (int)Partial_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static void swig_delete_Partial(void *obj) {
Partial *arg1 = (Partial *) obj;
delete arg1;
}
static swig_method swig_Partial_methods[] = {
    {"label", _wrap_Partial_label}, 
    {"initialPhase", _wrap_Partial_initialPhase}, 
    {"startTime", _wrap_Partial_startTime}, 
    {"endTime", _wrap_Partial_endTime}, 
    {"duration", _wrap_Partial_duration}, 
    {"numBreakpoints", _wrap_Partial_numBreakpoints}, 
    {"setLabel", _wrap_Partial_setLabel}, 
    {"begin", _wrap_Partial_begin}, 
    {"end", _wrap_Partial_end}, 
    {"insert", _wrap_Partial_insert}, 
    {"findAfter", _wrap_Partial_findAfter}, 
    {"findNearest", _wrap_Partial_findNearest}, 
    {"erase", _wrap_Partial_erase}, 
    {"frequencyAt", _wrap_Partial_frequencyAt}, 
    {"amplitudeAt", _wrap_Partial_amplitudeAt}, 
    {"bandwidthAt", _wrap_Partial_bandwidthAt}, 
    {"phaseAt", _wrap_Partial_phaseAt}, 
    {"copy", _wrap_Partial_copy}, 
    {"equals", _wrap_Partial_equals}, 
    {0,0}
};
static swig_attribute swig_Partial_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Partial_bases[] = {0};
swig_class _wrap_class_Partial = { "Partial", &SWIGTYPE_p_Partial,_wrap_new_Partial, swig_delete_Partial, swig_Partial_methods, swig_Partial_attributes, swig_Partial_bases };
static int
_wrap_PartialIterator_time(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:PartialIterator_time self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)((PartialIterator const *)arg1)->time();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialIterator_breakpoint(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    Breakpoint *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:PartialIterator_breakpoint self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (Breakpoint *)PartialIterator_breakpoint(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_Breakpoint,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialIterator_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PartialIterator *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:PartialIterator_copy self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialIterator,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialIterator_next(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PartialIterator *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:PartialIterator_next self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_next(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialIterator,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialIterator_prev(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PartialIterator *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:PartialIterator_prev self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_prev(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialIterator,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialIterator_equals(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PartialIterator *arg2 = (PartialIterator *) 0 ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:PartialIterator_equals self other ",0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (int)PartialIterator_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_PartialIterator_isInRange(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PartialIterator *arg2 = (PartialIterator *) 0 ;
    PartialIterator *arg3 = (PartialIterator *) 0 ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:PartialIterator_isInRange self begin end ",0,0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[3], (void **) &arg3, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (int)PartialIterator_isInRange(arg1,(PartialIterator const *)arg2,(PartialIterator const *)arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_new_PartialIterator(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *result;
    
    if (SWIG_GetArgs(interp, objc, objv,":new_PartialIterator ") == TCL_ERROR) SWIG_fail;
    {
        try
        {
            result = (PartialIterator *)new PartialIterator();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_PartialIterator,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_delete_PartialIterator(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:delete_PartialIterator self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static void swig_delete_PartialIterator(void *obj) {
PartialIterator *arg1 = (PartialIterator *) obj;
delete arg1;
}
static swig_method swig_PartialIterator_methods[] = {
    {"time", _wrap_PartialIterator_time}, 
    {"breakpoint", _wrap_PartialIterator_breakpoint}, 
    {"copy", _wrap_PartialIterator_copy}, 
    {"next", _wrap_PartialIterator_next}, 
    {"prev", _wrap_PartialIterator_prev}, 
    {"equals", _wrap_PartialIterator_equals}, 
    {"isInRange", _wrap_PartialIterator_isInRange}, 
    {0,0}
};
static swig_attribute swig_PartialIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_PartialIterator_bases[] = {0};
swig_class _wrap_class_PartialIterator = { "PartialIterator", &SWIGTYPE_p_PartialIterator,_wrap_new_PartialIterator, swig_delete_PartialIterator, swig_PartialIterator_methods, swig_PartialIterator_attributes, swig_PartialIterator_bases };
static int
_wrap_new_Breakpoint(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    double arg1 ;
    double arg2 ;
    double arg3 ;
    double arg4 = (double) 0. ;
    Breakpoint *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ddd|d:new_Breakpoint f a b p ",&arg1,&arg2,&arg3,&arg4) == TCL_ERROR) SWIG_fail;
    {
        try
        {
            result = (Breakpoint *)new Breakpoint(arg1,arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_Breakpoint,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_delete_Breakpoint(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:delete_Breakpoint self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Breakpoint_frequency(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Breakpoint_frequency self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->frequency();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Breakpoint_amplitude(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Breakpoint_amplitude self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->amplitude();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Breakpoint_bandwidth(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Breakpoint_bandwidth self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->bandwidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Breakpoint_phase(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Breakpoint_phase self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->phase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Breakpoint_setFrequency(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Breakpoint_setFrequency self x ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->setFrequency(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Breakpoint_setAmplitude(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Breakpoint_setAmplitude self x ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->setAmplitude(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Breakpoint_setBandwidth(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Breakpoint_setBandwidth self x ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->setBandwidth(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Breakpoint_setPhase(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:Breakpoint_setPhase self x ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            (arg1)->setPhase(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Breakpoint_copy(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    Breakpoint *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:Breakpoint_copy self ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (Breakpoint *)Breakpoint_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) result, SWIGTYPE_p_Breakpoint,0));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Breakpoint_equals(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    Breakpoint *arg2 = (Breakpoint *) 0 ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:Breakpoint_equals self other ",0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[1], (void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    if ((SWIG_ConvertPtr(interp, objv[2], (void **) &arg2, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
        try
        {
            result = (int)Breakpoint_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static void swig_delete_Breakpoint(void *obj) {
Breakpoint *arg1 = (Breakpoint *) obj;
delete arg1;
}
static swig_method swig_Breakpoint_methods[] = {
    {"frequency", _wrap_Breakpoint_frequency}, 
    {"amplitude", _wrap_Breakpoint_amplitude}, 
    {"bandwidth", _wrap_Breakpoint_bandwidth}, 
    {"phase", _wrap_Breakpoint_phase}, 
    {"setFrequency", _wrap_Breakpoint_setFrequency}, 
    {"setAmplitude", _wrap_Breakpoint_setAmplitude}, 
    {"setBandwidth", _wrap_Breakpoint_setBandwidth}, 
    {"setPhase", _wrap_Breakpoint_setPhase}, 
    {"copy", _wrap_Breakpoint_copy}, 
    {"equals", _wrap_Breakpoint_equals}, 
    {0,0}
};
static swig_attribute swig_Breakpoint_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Breakpoint_bases[] = {0};
swig_class _wrap_class_Breakpoint = { "Breakpoint", &SWIGTYPE_p_Breakpoint,_wrap_new_Breakpoint, swig_delete_Breakpoint, swig_Breakpoint_methods, swig_Breakpoint_attributes, swig_Breakpoint_bases };

static swig_command_info swig_commands[] = {
    { SWIG_prefix "channelize", (swig_wrapper_func) _wrap_channelize, NULL},
    { SWIG_prefix "createFreqReference", (swig_wrapper_func) _wrap_createFreqReference, NULL},
    { SWIG_prefix "dilate", (swig_wrapper_func) _wrap_dilate, NULL},
    { SWIG_prefix "distill", (swig_wrapper_func) _wrap_distill, NULL},
    { SWIG_prefix "exportAiff", (swig_wrapper_func) _wrap_exportAiff, NULL},
    { SWIG_prefix "exportSdif", (swig_wrapper_func) _wrap_exportSdif, NULL},
    { SWIG_prefix "exportSpc", (swig_wrapper_func) _wrap_exportSpc, NULL},
    { SWIG_prefix "importSdif", (swig_wrapper_func) _wrap_importSdif, NULL},
    { SWIG_prefix "importSpc", (swig_wrapper_func) _wrap_importSpc, NULL},
    { SWIG_prefix "morph", (swig_wrapper_func) _wrap_morph, NULL},
    { SWIG_prefix "synthesize", (swig_wrapper_func) _wrap_synthesize, NULL},
    { SWIG_prefix "sift", (swig_wrapper_func) _wrap_sift, NULL},
    { SWIG_prefix "extractLabeled", (swig_wrapper_func) _wrap_extractLabeled, NULL},
    { SWIG_prefix "scaleAmp", (swig_wrapper_func) _wrap_scaleAmp, NULL},
    { SWIG_prefix "scaleNoiseRatio", (swig_wrapper_func) _wrap_scaleNoiseRatio, NULL},
    { SWIG_prefix "shiftPitch", (swig_wrapper_func) _wrap_shiftPitch, NULL},
    { SWIG_prefix "version", (swig_wrapper_func) _wrap_version, NULL},
    { SWIG_prefix "new_AiffFile", (swig_wrapper_func) _wrap_new_AiffFile, NULL},
    { SWIG_prefix "delete_AiffFile", (swig_wrapper_func) _wrap_delete_AiffFile, NULL},
    { SWIG_prefix "AiffFile_channels", (swig_wrapper_func) _wrap_AiffFile_channels, NULL},
    { SWIG_prefix "AiffFile_sampleFrames", (swig_wrapper_func) _wrap_AiffFile_sampleFrames, NULL},
    { SWIG_prefix "AiffFile_sampleRate", (swig_wrapper_func) _wrap_AiffFile_sampleRate, NULL},
    { SWIG_prefix "AiffFile_sampleSize", (swig_wrapper_func) _wrap_AiffFile_sampleSize, NULL},
    { SWIG_prefix "AiffFile_samples", (swig_wrapper_func) _wrap_AiffFile_samples, NULL},
    { SWIG_prefix "AiffFile", (swig_wrapper_func) SWIG_ObjectConstructor, &_wrap_class_AiffFile},
    { SWIG_prefix "new_Analyzer", (swig_wrapper_func) _wrap_new_Analyzer, NULL},
    { SWIG_prefix "Analyzer_copy", (swig_wrapper_func) _wrap_Analyzer_copy, NULL},
    { SWIG_prefix "Analyzer_analyze", (swig_wrapper_func) _wrap_Analyzer_analyze, NULL},
    { SWIG_prefix "Analyzer_freqResolution", (swig_wrapper_func) _wrap_Analyzer_freqResolution, NULL},
    { SWIG_prefix "Analyzer_ampFloor", (swig_wrapper_func) _wrap_Analyzer_ampFloor, NULL},
    { SWIG_prefix "Analyzer_windowWidth", (swig_wrapper_func) _wrap_Analyzer_windowWidth, NULL},
    { SWIG_prefix "Analyzer_sidelobeLevel", (swig_wrapper_func) _wrap_Analyzer_sidelobeLevel, NULL},
    { SWIG_prefix "Analyzer_freqFloor", (swig_wrapper_func) _wrap_Analyzer_freqFloor, NULL},
    { SWIG_prefix "Analyzer_hopTime", (swig_wrapper_func) _wrap_Analyzer_hopTime, NULL},
    { SWIG_prefix "Analyzer_freqDrift", (swig_wrapper_func) _wrap_Analyzer_freqDrift, NULL},
    { SWIG_prefix "Analyzer_cropTime", (swig_wrapper_func) _wrap_Analyzer_cropTime, NULL},
    { SWIG_prefix "Analyzer_bwRegionWidth", (swig_wrapper_func) _wrap_Analyzer_bwRegionWidth, NULL},
    { SWIG_prefix "Analyzer_setFreqResolution", (swig_wrapper_func) _wrap_Analyzer_setFreqResolution, NULL},
    { SWIG_prefix "Analyzer_setAmpFloor", (swig_wrapper_func) _wrap_Analyzer_setAmpFloor, NULL},
    { SWIG_prefix "Analyzer_setWindowWidth", (swig_wrapper_func) _wrap_Analyzer_setWindowWidth, NULL},
    { SWIG_prefix "Analyzer_setSidelobeLevel", (swig_wrapper_func) _wrap_Analyzer_setSidelobeLevel, NULL},
    { SWIG_prefix "Analyzer_setFreqFloor", (swig_wrapper_func) _wrap_Analyzer_setFreqFloor, NULL},
    { SWIG_prefix "Analyzer_setFreqDrift", (swig_wrapper_func) _wrap_Analyzer_setFreqDrift, NULL},
    { SWIG_prefix "Analyzer_setHopTime", (swig_wrapper_func) _wrap_Analyzer_setHopTime, NULL},
    { SWIG_prefix "Analyzer_setCropTime", (swig_wrapper_func) _wrap_Analyzer_setCropTime, NULL},
    { SWIG_prefix "Analyzer_setBwRegionWidth", (swig_wrapper_func) _wrap_Analyzer_setBwRegionWidth, NULL},
    { SWIG_prefix "delete_Analyzer", (swig_wrapper_func) _wrap_delete_Analyzer, NULL},
    { SWIG_prefix "Analyzer", (swig_wrapper_func) SWIG_ObjectConstructor, &_wrap_class_Analyzer},
    { SWIG_prefix "new_BreakpointEnvelope", (swig_wrapper_func) _wrap_new_BreakpointEnvelope, NULL},
    { SWIG_prefix "delete_BreakpointEnvelope", (swig_wrapper_func) _wrap_delete_BreakpointEnvelope, NULL},
    { SWIG_prefix "BreakpointEnvelope_copy", (swig_wrapper_func) _wrap_BreakpointEnvelope_copy, NULL},
    { SWIG_prefix "BreakpointEnvelope_insertBreakpoint", (swig_wrapper_func) _wrap_BreakpointEnvelope_insertBreakpoint, NULL},
    { SWIG_prefix "BreakpointEnvelope_valueAt", (swig_wrapper_func) _wrap_BreakpointEnvelope_valueAt, NULL},
    { SWIG_prefix "BreakpointEnvelope", (swig_wrapper_func) SWIG_ObjectConstructor, &_wrap_class_BreakpointEnvelope},
    { SWIG_prefix "BreakpointEnvelopeWithValue", (swig_wrapper_func) _wrap_BreakpointEnvelopeWithValue, NULL},
    { SWIG_prefix "new_SampleVector", (swig_wrapper_func) _wrap_new_SampleVector, NULL},
    { SWIG_prefix "delete_SampleVector", (swig_wrapper_func) _wrap_delete_SampleVector, NULL},
    { SWIG_prefix "SampleVector_clear", (swig_wrapper_func) _wrap_SampleVector_clear, NULL},
    { SWIG_prefix "SampleVector_resize", (swig_wrapper_func) _wrap_SampleVector_resize, NULL},
    { SWIG_prefix "SampleVector_size", (swig_wrapper_func) _wrap_SampleVector_size, NULL},
    { SWIG_prefix "SampleVector_copy", (swig_wrapper_func) _wrap_SampleVector_copy, NULL},
    { SWIG_prefix "SampleVector_getAt", (swig_wrapper_func) _wrap_SampleVector_getAt, NULL},
    { SWIG_prefix "SampleVector_setAt", (swig_wrapper_func) _wrap_SampleVector_setAt, NULL},
    { SWIG_prefix "SampleVector", (swig_wrapper_func) SWIG_ObjectConstructor, &_wrap_class_SampleVector},
    { SWIG_prefix "new_PartialList", (swig_wrapper_func) _wrap_new_PartialList, NULL},
    { SWIG_prefix "delete_PartialList", (swig_wrapper_func) _wrap_delete_PartialList, NULL},
    { SWIG_prefix "PartialList_copy", (swig_wrapper_func) _wrap_PartialList_copy, NULL},
    { SWIG_prefix "PartialList_timeSpan", (swig_wrapper_func) _wrap_PartialList_timeSpan, NULL},
    { SWIG_prefix "PartialList_clear", (swig_wrapper_func) _wrap_PartialList_clear, NULL},
    { SWIG_prefix "PartialList_size", (swig_wrapper_func) _wrap_PartialList_size, NULL},
    { SWIG_prefix "PartialList_begin", (swig_wrapper_func) _wrap_PartialList_begin, NULL},
    { SWIG_prefix "PartialList_end", (swig_wrapper_func) _wrap_PartialList_end, NULL},
    { SWIG_prefix "PartialList_insert", (swig_wrapper_func) _wrap_PartialList_insert, NULL},
    { SWIG_prefix "PartialList_erase", (swig_wrapper_func) _wrap_PartialList_erase, NULL},
    { SWIG_prefix "PartialList_splice", (swig_wrapper_func) _wrap_PartialList_splice, NULL},
    { SWIG_prefix "PartialList", (swig_wrapper_func) SWIG_ObjectConstructor, &_wrap_class_PartialList},
    { SWIG_prefix "PartialListIterator_copy", (swig_wrapper_func) _wrap_PartialListIterator_copy, NULL},
    { SWIG_prefix "PartialListIterator_next", (swig_wrapper_func) _wrap_PartialListIterator_next, NULL},
    { SWIG_prefix "PartialListIterator_prev", (swig_wrapper_func) _wrap_PartialListIterator_prev, NULL},
    { SWIG_prefix "PartialListIterator_partial", (swig_wrapper_func) _wrap_PartialListIterator_partial, NULL},
    { SWIG_prefix "PartialListIterator_equals", (swig_wrapper_func) _wrap_PartialListIterator_equals, NULL},
    { SWIG_prefix "PartialListIterator_isInRange", (swig_wrapper_func) _wrap_PartialListIterator_isInRange, NULL},
    { SWIG_prefix "new_PartialListIterator", (swig_wrapper_func) _wrap_new_PartialListIterator, NULL},
    { SWIG_prefix "delete_PartialListIterator", (swig_wrapper_func) _wrap_delete_PartialListIterator, NULL},
    { SWIG_prefix "PartialListIterator", (swig_wrapper_func) SWIG_ObjectConstructor, &_wrap_class_PartialListIterator},
    { SWIG_prefix "new_Partial", (swig_wrapper_func) _wrap_new_Partial, NULL},
    { SWIG_prefix "delete_Partial", (swig_wrapper_func) _wrap_delete_Partial, NULL},
    { SWIG_prefix "Partial_label", (swig_wrapper_func) _wrap_Partial_label, NULL},
    { SWIG_prefix "Partial_initialPhase", (swig_wrapper_func) _wrap_Partial_initialPhase, NULL},
    { SWIG_prefix "Partial_startTime", (swig_wrapper_func) _wrap_Partial_startTime, NULL},
    { SWIG_prefix "Partial_endTime", (swig_wrapper_func) _wrap_Partial_endTime, NULL},
    { SWIG_prefix "Partial_duration", (swig_wrapper_func) _wrap_Partial_duration, NULL},
    { SWIG_prefix "Partial_numBreakpoints", (swig_wrapper_func) _wrap_Partial_numBreakpoints, NULL},
    { SWIG_prefix "Partial_setLabel", (swig_wrapper_func) _wrap_Partial_setLabel, NULL},
    { SWIG_prefix "Partial_begin", (swig_wrapper_func) _wrap_Partial_begin, NULL},
    { SWIG_prefix "Partial_end", (swig_wrapper_func) _wrap_Partial_end, NULL},
    { SWIG_prefix "Partial_insert", (swig_wrapper_func) _wrap_Partial_insert, NULL},
    { SWIG_prefix "Partial_findAfter", (swig_wrapper_func) _wrap_Partial_findAfter, NULL},
    { SWIG_prefix "Partial_findNearest", (swig_wrapper_func) _wrap_Partial_findNearest, NULL},
    { SWIG_prefix "Partial_erase", (swig_wrapper_func) _wrap_Partial_erase, NULL},
    { SWIG_prefix "Partial_frequencyAt", (swig_wrapper_func) _wrap_Partial_frequencyAt, NULL},
    { SWIG_prefix "Partial_amplitudeAt", (swig_wrapper_func) _wrap_Partial_amplitudeAt, NULL},
    { SWIG_prefix "Partial_bandwidthAt", (swig_wrapper_func) _wrap_Partial_bandwidthAt, NULL},
    { SWIG_prefix "Partial_phaseAt", (swig_wrapper_func) _wrap_Partial_phaseAt, NULL},
    { SWIG_prefix "Partial_copy", (swig_wrapper_func) _wrap_Partial_copy, NULL},
    { SWIG_prefix "Partial_equals", (swig_wrapper_func) _wrap_Partial_equals, NULL},
    { SWIG_prefix "Partial", (swig_wrapper_func) SWIG_ObjectConstructor, &_wrap_class_Partial},
    { SWIG_prefix "PartialIterator_time", (swig_wrapper_func) _wrap_PartialIterator_time, NULL},
    { SWIG_prefix "PartialIterator_breakpoint", (swig_wrapper_func) _wrap_PartialIterator_breakpoint, NULL},
    { SWIG_prefix "PartialIterator_copy", (swig_wrapper_func) _wrap_PartialIterator_copy, NULL},
    { SWIG_prefix "PartialIterator_next", (swig_wrapper_func) _wrap_PartialIterator_next, NULL},
    { SWIG_prefix "PartialIterator_prev", (swig_wrapper_func) _wrap_PartialIterator_prev, NULL},
    { SWIG_prefix "PartialIterator_equals", (swig_wrapper_func) _wrap_PartialIterator_equals, NULL},
    { SWIG_prefix "PartialIterator_isInRange", (swig_wrapper_func) _wrap_PartialIterator_isInRange, NULL},
    { SWIG_prefix "new_PartialIterator", (swig_wrapper_func) _wrap_new_PartialIterator, NULL},
    { SWIG_prefix "delete_PartialIterator", (swig_wrapper_func) _wrap_delete_PartialIterator, NULL},
    { SWIG_prefix "PartialIterator", (swig_wrapper_func) SWIG_ObjectConstructor, &_wrap_class_PartialIterator},
    { SWIG_prefix "new_Breakpoint", (swig_wrapper_func) _wrap_new_Breakpoint, NULL},
    { SWIG_prefix "delete_Breakpoint", (swig_wrapper_func) _wrap_delete_Breakpoint, NULL},
    { SWIG_prefix "Breakpoint_frequency", (swig_wrapper_func) _wrap_Breakpoint_frequency, NULL},
    { SWIG_prefix "Breakpoint_amplitude", (swig_wrapper_func) _wrap_Breakpoint_amplitude, NULL},
    { SWIG_prefix "Breakpoint_bandwidth", (swig_wrapper_func) _wrap_Breakpoint_bandwidth, NULL},
    { SWIG_prefix "Breakpoint_phase", (swig_wrapper_func) _wrap_Breakpoint_phase, NULL},
    { SWIG_prefix "Breakpoint_setFrequency", (swig_wrapper_func) _wrap_Breakpoint_setFrequency, NULL},
    { SWIG_prefix "Breakpoint_setAmplitude", (swig_wrapper_func) _wrap_Breakpoint_setAmplitude, NULL},
    { SWIG_prefix "Breakpoint_setBandwidth", (swig_wrapper_func) _wrap_Breakpoint_setBandwidth, NULL},
    { SWIG_prefix "Breakpoint_setPhase", (swig_wrapper_func) _wrap_Breakpoint_setPhase, NULL},
    { SWIG_prefix "Breakpoint_copy", (swig_wrapper_func) _wrap_Breakpoint_copy, NULL},
    { SWIG_prefix "Breakpoint_equals", (swig_wrapper_func) _wrap_Breakpoint_equals, NULL},
    { SWIG_prefix "Breakpoint", (swig_wrapper_func) SWIG_ObjectConstructor, &_wrap_class_Breakpoint},
    {0, 0, 0}
};

static swig_var_info swig_variables[] = {
    {0,0,0,0}
};

static swig_const_info swig_constants[] = {
    {0,0,0,0,0,0}
};

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_Partial[] = {{"_p_Partial", 0, "Partial *", &_wrap_class_Partial},{"_p_Partial"},{0}};
static swig_type_info _swigt__p_PartialList[] = {{"_p_PartialList", 0, "PartialList *", &_wrap_class_PartialList},{"_p_PartialList"},{0}};
static swig_type_info _swigt__p_SampleVector[] = {{"_p_SampleVector", 0, "SampleVector *", &_wrap_class_SampleVector},{"_p_SampleVector"},{0}};
static swig_type_info _swigt__p_AiffFile[] = {{"_p_AiffFile", 0, "AiffFile *", &_wrap_class_AiffFile},{"_p_AiffFile"},{0}};
static swig_type_info _swigt__p_Analyzer[] = {{"_p_Analyzer", 0, "Analyzer *", &_wrap_class_Analyzer},{"_p_Analyzer"},{0}};
static swig_type_info _swigt__p_double[] = {{"_p_double", 0, "double *", 0},{"_p_double"},{0}};
static swig_type_info _swigt__p_PartialListIterator[] = {{"_p_PartialListIterator", 0, "PartialListIterator *", &_wrap_class_PartialListIterator},{"_p_PartialListIterator"},{0}};
static swig_type_info _swigt__p_PartialIterator[] = {{"_p_PartialIterator", 0, "PartialIterator *", &_wrap_class_PartialIterator},{"_p_PartialIterator"},{0}};
static swig_type_info _swigt__p_Breakpoint[] = {{"_p_Breakpoint", 0, "Breakpoint *", &_wrap_class_Breakpoint},{"_p_Breakpoint"},{0}};
static swig_type_info _swigt__p_BreakpointEnvelope[] = {{"_p_BreakpointEnvelope", 0, "BreakpointEnvelope *", &_wrap_class_BreakpointEnvelope},{"_p_BreakpointEnvelope"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_Partial, 
_swigt__p_PartialList, 
_swigt__p_SampleVector, 
_swigt__p_AiffFile, 
_swigt__p_Analyzer, 
_swigt__p_double, 
_swigt__p_PartialListIterator, 
_swigt__p_PartialIterator, 
_swigt__p_Breakpoint, 
_swigt__p_BreakpointEnvelope, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

#ifdef __cplusplus
}
#endif

SWIGEXPORT(int) SWIG_init(Tcl_Interp *interp) {
    int i;
    static int _init = 0;
    if (interp == 0) return TCL_ERROR;
    #ifdef USE_TCL_STUBS
    if (Tcl_InitStubs(interp, (char*)"8.1", 0) == NULL) {
        return TCL_ERROR;
    }
    #endif
    
    Tcl_PkgProvide(interp, (char*)SWIG_name, (char*)SWIG_version);
    
    #ifdef SWIG_namespace
    Tcl_Eval(interp, "namespace eval " SWIG_namespace " { }");
    #endif
    if (!_init) {
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }
        _init = 1;
    }
    for (i = 0; swig_commands[i].name; i++) {
        Tcl_CreateObjCommand(interp, (char *) swig_commands[i].name, (swig_wrapper_func) swig_commands[i].wrapper, swig_commands[i].clientdata, NULL);
    }
    for (i = 0; swig_variables[i].name; i++) {
        Tcl_SetVar(interp, (char *) swig_variables[i].name, (char *) "", TCL_GLOBAL_ONLY);
        Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_READS | TCL_GLOBAL_ONLY, (Tcl_VarTraceProc *) swig_variables[i].get, (ClientData) swig_variables[i].addr);
        Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_WRITES | TCL_GLOBAL_ONLY, (Tcl_VarTraceProc *) swig_variables[i].set, (ClientData) swig_variables[i].addr);
    }
    SWIG_InstallConstants(interp, swig_constants);
    
    
    Loris::setNotifier( printf_notifier );
    Loris::setExceptionHandler( exception_handler );
    
    return TCL_OK;
}

