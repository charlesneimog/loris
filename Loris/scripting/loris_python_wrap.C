/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.11u-20020201-1626
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON

#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    inline SwigValueWrapper() : tt(0) { }
    inline ~SwigValueWrapper() { if (tt) delete tt; } 
    inline SwigValueWrapper& operator=(T t) {tt = new T(t); return *this;}
    inline operator T() const {return *tt;}
    inline T *operator&() { return tt; }
};                                                    
#endif

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#       endif
#endif
#else
#       define SWIGEXPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif



#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);

typedef struct swig_type_info {
  const char             *name;                 
  swig_converter_func     converter;
  const char             *str;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
  void                   *clientdata;	
} swig_type_info;

#ifdef SWIG_NOINCLUDE
SWIGEXPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGEXPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGEXPORT(void *) SWIG_TypeCast(swig_type_info *, void *);
SWIGEXPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGEXPORT(void) SWIG_TypeClientData(swig_type_info *, void *);
#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  while (s) {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  }
  return 0;
}

/* Cast a pointer (needed for C++ inheritance */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
	if ((strcmp(tc->name, equiv->name) == 0))
	  SWIG_TypeClientData(tc,clientdata);
	tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}
#endif

#ifdef __cplusplus
}

#endif




/***********************************************************************
 * python.swg
 *
 *     This file contains the runtime support for Python modules
 *     and includes code for managing global variables and pointer
 *     type checking.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 ************************************************************************/

#include <stdlib.h>
#include "Python.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_PY_INT     1
#define SWIG_PY_FLOAT   2
#define SWIG_PY_STRING  3
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

#ifdef SWIG_NOINCLUDE

SWIGEXPORT(PyObject *)        SWIG_newvarlink();
SWIGEXPORT(void)              SWIG_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
SWIGEXPORT(int)               SWIG_ConvertPtr(PyObject *, void **, swig_type_info *, int);
SWIGEXPORT(int)               SWIG_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
SWIGEXPORT(char *)            SWIG_PackData(char *c, void *, int);
SWIGEXPORT(char *)            SWIG_UnpackData(char *c, void *, int);
SWIGEXPORT(PyObject *)        SWIG_NewPointerObj(void *, swig_type_info *,int own);
SWIGEXPORT(PyObject *)        SWIG_NewPackedObj(void *, int sz, swig_type_info *);
SWIGEXPORT(void)              SWIG_InstallConstants(PyObject *d, swig_const_info constants[]);
SWIGEXPORT(PyObject *)        SWIG_MakeShadow(PyObject *robj, swig_type_info *type, int own);
#else

/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */

typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

static PyObject *
swig_varlink_repr(swig_varlinkobject *v) {
  v = v;
  return PyString_FromString("<Global variables>");
}

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
  swig_globalvar  *var;
  flags = flags;
  fprintf(fp,"Global variables { ");
  for (var = v->vars; var; var=var->next) {
    fprintf(fp,"%s", var->name);
    if (var->next) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->get_attr)();
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return NULL;
}

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->set_attr)(p);
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return 1;
}

statichere PyTypeObject varlinktype = {
  PyObject_HEAD_INIT(0)              
  0,
  (char *)"swigvarlink",                      /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */
SWIGRUNTIME(PyObject *)
SWIG_newvarlink(void) {
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  result->vars = 0;
  result->ob_refcnt = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGRUNTIME(void)
SWIG_addvarlink(PyObject *p, char *name,
	   PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v;
  swig_globalvar *gv;
  v= (swig_varlinkobject *) p;
  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  gv->name = (char *) malloc(strlen(name)+1);
  strcpy(gv->name,name);
  gv->get_attr = get_attr;
  gv->set_attr = set_attr;
  gv->next = v->vars;
  v->vars = gv;
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  int i;
  unsigned char *u = (unsigned char *) ptr;
  register unsigned char uu;
  for (i = 0; i < sz; i++,u++) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  int i;
  for (i = 0; i < sz; i++, u++) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;
  static PyObject *SWIG_this = 0;
  int    newref = 0;

  if (!obj) return 0;
  if (obj == Py_None) {
    *ptr = 0;
    return 0;
  }
#ifdef SWIG_COBJECT_TYPES
  if (!(PyCObject_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_InternFromString("this");
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyCObject_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  *ptr = PyCObject_AsVoidPtr(obj);
  c = (char *) PyCObject_GetDesc(obj);
  if (newref) Py_DECREF(obj);
  goto cobject;
#else
  if (!(PyString_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_InternFromString("this");
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyString_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) {
      if (newref) Py_DECREF(obj);
      return 0;
    } else {
      if (newref) Py_DECREF(obj);
      goto type_error;
    }
  }
  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (newref) Py_DECREF(obj);
#endif

#ifdef SWIG_COBJECT_TYPES
cobject:
#endif

  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
  }
  return 0;

type_error:
  if (flags) {
    if (ty) {
      char *temp = (char *) malloc(64+strlen(ty->name));
      sprintf(temp,"Type error. Expected %s", ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Convert a packed value value */
SWIGRUNTIME(int)
SWIG_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;

  if ((!obj) || (!PyString_Check(obj))) goto type_error;
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return 0;

type_error:

  if (flags) {
    if (ty) {
      char *temp = (char *) malloc(64+strlen(ty->name));
      sprintf(temp,"Type error. Expected %s", ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Create a new pointer object */
SWIGRUNTIME(PyObject *)
SWIG_NewPointerObj(void *ptr, swig_type_info *type, int own) {
  PyObject *robj;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#ifdef SWIG_COBJECT_TYPES
  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type->name, NULL);
#else
  {
    char result[512];
    char *r = result;
    *(r++) = '_';
    r = SWIG_PackData(r,&ptr,sizeof(void *));
    strcpy(r,type->name);
    robj = PyString_FromString(result);
  }
#endif
  if (!robj || (robj == Py_None)) return robj;
  if (type->clientdata) {
    PyObject *inst;
    PyObject *args = Py_BuildValue((char*)"(O)", robj);
    Py_DECREF(robj);
    inst = PyObject_CallObject((PyObject *) type->clientdata, args);
    Py_DECREF(args);
    if (own) {
      PyObject *n = PyInt_FromLong(1);
      PyObject_SetAttrString(inst,(char*)"thisown",n);
      Py_DECREF(n);
    }
    robj = inst;
  }
  return robj;
}

SWIGRUNTIME(PyObject *)
SWIG_MakeShadow(PyObject *robj, swig_type_info *type, int own) {
  if (!robj || (robj == Py_None)) return robj;
  if (type->clientdata) {
    PyInstanceObject *inst;
    inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
    if (!inst) return robj;
    inst->in_dict = PyDict_New();
    inst->in_class = (PyClassObject *) type->clientdata;
    Py_INCREF(inst->in_class);
    PyObject_SetAttrString((PyObject *)inst,(char*)"this",robj);
    Py_DECREF(robj);
    if (own) {
      PyObject *n = PyInt_FromLong(1);
      PyObject_SetAttrString((PyObject *)inst,(char*)"thisown",n);
      Py_DECREF(n);
    }
    robj = (PyObject *) inst;
    Py_INCREF(robj);
  }
  return robj;
}

SWIGRUNTIME(PyObject *)
SWIG_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  return PyString_FromString(result);
}

/* Install Constants */
SWIGRUNTIME(void)
SWIG_InstallConstants(PyObject *d, swig_const_info constants[]) {
  int i;
  PyObject *obj;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_PY_INT:
      obj = PyInt_FromLong(constants[i].lvalue);
      break;
    case SWIG_PY_FLOAT:
      obj = PyFloat_FromDouble(constants[i].dvalue);
      break;
    case SWIG_PY_STRING:
      obj = PyString_FromString((char *) constants[i].pvalue);
      break;
    case SWIG_PY_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_PY_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d,constants[i].name,obj);
      Py_DECREF(obj);
    }
  }
}

#endif

#ifdef __cplusplus
}
#endif








/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_Partial swig_types[0] 
#define  SWIGTYPE_p_PartialList swig_types[1] 
#define  SWIGTYPE_p_SampleVector swig_types[2] 
#define  SWIGTYPE_p_AiffFile swig_types[3] 
#define  SWIGTYPE_p_Analyzer swig_types[4] 
#define  SWIGTYPE_p_double swig_types[5] 
#define  SWIGTYPE_p_PartialListIterator swig_types[6] 
#define  SWIGTYPE_p_PartialIterator swig_types[7] 
#define  SWIGTYPE_p_Breakpoint swig_types[8] 
#define  SWIGTYPE_p_BreakpointEnvelope swig_types[9] 
static swig_type_info *swig_types[11];

/* -------- TYPES TABLE (END) -------- */


/*-----------------------------------------------
              @(target):= lorisc.so
  ------------------------------------------------*/
#define SWIG_init    initlorisc

#define SWIG_name    "lorisc"

	#include<Notifier.h>
	#include<Exception.h>
	#include <string>
	
	//	notification function for Loris debugging
	//	and notifications, installed in initialization
	//	block below:
	static void printf_notifier( const char * s )
	{
		printf("*\t%s\n", s);
	}	
	
	//	class NullPointer
	//
	//	Define a Loris::Exception subclass for catching NULL pointers.
	//	This is copied from lorisException_pi.h. It could be in Loris,
	//	but probably was never needed because Loris doesn't make much 
	//	use of pointers.
	//
	class NullPointer : public Loris::Exception
	{
	public: 
		NullPointer( const std::string & str, const std::string & where = "" ) : 
			Exception( std::string("NULL pointer exception -- ").append( str ), where ) {}
	};	//	end of class NullPointer
	
	//	define a macro for testing and throwing:
	#define ThrowIfNull(ptr) if ((ptr)==NULL) Throw( NullPointer, #ptr );	


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


static void _SWIG_exception(int code, char *msg) {
  switch(code) {
  case SWIG_MemoryError:
    PyErr_SetString(PyExc_MemoryError,msg);
    break;
  case SWIG_IOError:
    PyErr_SetString(PyExc_IOError,msg);
    break;
  case SWIG_RuntimeError:
    PyErr_SetString(PyExc_RuntimeError,msg);
    break;
  case SWIG_IndexError:
    PyErr_SetString(PyExc_IndexError,msg);
    break;
  case SWIG_TypeError:
    PyErr_SetString(PyExc_TypeError,msg);
    break;
  case SWIG_DivisionByZero:
    PyErr_SetString(PyExc_ZeroDivisionError,msg);
    break;
  case SWIG_OverflowError:
    PyErr_SetString(PyExc_OverflowError,msg);
    break;
  case SWIG_SyntaxError:
    PyErr_SetString(PyExc_SyntaxError,msg);
    break;
  case SWIG_ValueError:
    PyErr_SetString(PyExc_ValueError,msg);
    break;
  case SWIG_SystemError:
    PyErr_SetString(PyExc_SystemError,msg);
    break;
  default:
    PyErr_SetString(PyExc_RuntimeError,msg);
    break;
  }
}

#define SWIG_exception(a,b) { _SWIG_exception(a,b); return NULL; }


static PyObject* l_output_helper(PyObject* target, PyObject* o) {
    PyObject*   o2;
    if (!target) {                   
        target = o;
    } else if (target == Py_None) {  
        Py_DECREF(Py_None);
        target = o;
    } else {                         
        if (!PyList_Check(target)) {
            o2 = target;
            target = PyList_New(0);
            PyList_Append(target, o2);
	    Py_XDECREF(o2);
        }
        PyList_Append(target,o);
	Py_XDECREF(o);
    }
    return target;
}


static PyObject* t_output_helper(PyObject* target, PyObject* o) {
    PyObject*   o2;
    PyObject*   o3;

    if (!target) {                   
        target = o;
    } else if (target == Py_None) {  
        Py_DECREF(Py_None);
        target = o;
    } else {                         
        if (!PyTuple_Check(target)) {
            o2 = target;
            target = PyTuple_New(1);
            PyTuple_SetItem(target, 0, o2);
        }
        o3 = PyTuple_New(1);            
        PyTuple_SetItem(o3, 0, o);      

        o2 = target;
        target = PySequence_Concat(o2, o3); 
        Py_DECREF(o2);                      
        Py_DECREF(o3);
    }
    return target;
}


#include<Partial.h>
#include<PartialUtils.h>
#include<Notifier.h>
#include <list>

using Loris::debugger;
using Loris::Partial;
using Loris::PartialUtils;
using Loris::Breakpoint;

//	define the names of the classes that are 
//	wrapped by this interface file:
//	(additionally Partial and Breakpoint)
typedef std::list< Loris::Partial > PartialList;
typedef std::list< Loris::Partial >::iterator PartialListIterator;
typedef Loris::Partial::iterator PartialIterator;


PartialList *new_PartialList(){
			debugger << "creating an empty list of Partials" << Loris::endl;
			return new PartialList();
		}
void delete_PartialList(PartialList *self){
			debugger << "destroying  a list of " << self->size() << " Partials" << Loris::endl;
			delete self;
		}
PartialList *PartialList_copy(PartialList *self){
			return new PartialList( *self );
		}
void PartialList_timeSpan(PartialList *self,double *tmin_out,double *tmax_out){
		 	std::pair<double, double> span = 
		 		PartialUtils::timeSpan( self->begin(), self->end() );
		 	*tmin_out = span.first;
		 	*tmax_out = span.second;
		 }
PartialListIterator *PartialListIterator_copy(PartialListIterator *self){
			return new PartialListIterator( *self );
		}
PartialListIterator *PartialListIterator_next(PartialListIterator *self){
			PartialListIterator * next = new PartialListIterator(*self);
			++(*next);
			return next;
		}
PartialListIterator *PartialListIterator_prev(PartialListIterator *self){
			PartialListIterator * prev = new PartialListIterator(*self);
			--(*prev);
			return prev;
		}
Partial *PartialListIterator_partial(PartialListIterator *self){
			Partial & current = **self;
			return &current;
		}
int PartialListIterator_equals(PartialListIterator *self,PartialListIterator *other){
			return *self == *other;
		}
int PartialListIterator_isInRange(PartialListIterator *self,PartialListIterator const *begin,PartialListIterator const *end){	
		 	PartialListIterator it;
		 	for ( it = *begin; it != *end; ++it )
		 	{
		 		if ( it == *self )
		 			return true;
		 	}
		 	return false;
		 }
Partial *Partial_copy(Partial *self){
			return new Partial( *self );
		}
int Partial_equals(Partial *self,Partial *other){
			return *self == *other;
		}
Breakpoint *PartialIterator_breakpoint(PartialIterator *self){ 
			return &(self->breakpoint());
		}
PartialIterator *PartialIterator_copy(PartialIterator *self){
			return new PartialIterator( *self );
		}
PartialIterator *PartialIterator_next(PartialIterator *self){
			PartialIterator * next = new PartialIterator(*self);
			++(*next);
			return next;
		}
PartialIterator *PartialIterator_prev(PartialIterator *self){
			PartialIterator * prev = new PartialIterator(*self);
			--(*prev);
			return prev;
		}
int PartialIterator_equals(PartialIterator *self,PartialIterator *other){
			return *self == *other;
		}
int PartialIterator_isInRange(PartialIterator *self,PartialIterator const *begin,PartialIterator const *end){	
		 	PartialIterator it;
		 	for ( it = *begin; it != *end; ++it )
		 	{
		 		if ( it == *self )
		 			return true;
		 	}
		 	return false;
		 }
Breakpoint *Breakpoint_copy(Breakpoint *self){
			return new Breakpoint( *self );
		}
int Breakpoint_equals(Breakpoint *self,Breakpoint *other){
			return *self == *other;
		}

#include <stdexcept>
#include <vector>
typedef std::vector< double > SampleVector;

SampleVector *SampleVector_copy(SampleVector *self){
		return new SampleVector( *self );
	}
double SampleVector_getAt(SampleVector *self,unsigned long idx){
		// return self->at(idx);	//	g++ doesn't implement at()?
		if ( idx >= self->size() )
			throw std::out_of_range("vector::at index out of range");
		return (*self)[idx];
	}
void SampleVector_setAt(SampleVector *self,unsigned long idx,double x){
		// self->at(idx) = x;	//	g++ doesn't implement at()?
		if ( idx >= self->size() )
			throw std::out_of_range("vector::at index out of range");
		(*self)[idx] = x;
	}

#include<Analyzer.h>
#include<Partial.h>

using Loris::Analyzer;

Analyzer *new_Analyzer(double resolutionHz,double windowWidthHz){
		if ( windowWidthHz == 0. )
			windowWidthHz = resolutionHz;
		return new Analyzer( resolutionHz, windowWidthHz );
	}
Analyzer *Analyzer_copy(Analyzer *self){
		return new Analyzer( self->freqResolution() );
	}
PartialList *Analyzer_analyze(Analyzer *self,SampleVector const *vec,double srate){
		PartialList * partials = new PartialList();
		self->analyze( vec->begin(), vec->end(), srate );
		partials->splice( partials->end(), self->partials() );
		return partials;
	}

#include<BreakpointEnvelope.h>
using Loris::BreakpointEnvelope;

BreakpointEnvelope *BreakpointEnvelope_copy(BreakpointEnvelope *self){
		return new BreakpointEnvelope( *self );
	}

BreakpointEnvelope * BreakpointEnvelopeWithValue_( double initialValue )
{
	return new BreakpointEnvelope( initialValue );
}


#include<AiffFile.h>
using Loris::AiffFile;

SampleVector *AiffFile_samples(AiffFile *self){
		SampleVector * vec = new SampleVector( self->sampleFrames(), 0. );
		self->getSamples( vec->begin(), vec->end() );
		return vec;
	}

	#include<loris.h>


	#include<Dilator.h>
	#include <string>
	#include <vector>
	
	//	Helper function for dilate: 
	//
	//	convert a string into a vector of doubles,
	//	ignore any extraneous characters:
	static std::vector<double> strtovec( const std::string & s )
	{
		std::vector<double> v;
		std::string::size_type beg, end;
		const std::string numparts("1234567890+-.");
		beg = s.find_first_of( numparts );
		while ( beg != std::string::npos )
		{
			end = s.find_first_not_of( numparts, beg );
			if ( end == std::string::npos )
				end = s.length();
	
			double x = atof( s.c_str() + beg );
			v.push_back(x);
	
			beg = s.find_first_of( numparts, end );
		}
		return v;
	}

	void dilate_str( PartialList * partials, 
				 char * initial_times, char * target_times )
	{
		std::vector<double> ivec = strtovec( initial_times );
		std::vector<double> tvec = strtovec( target_times );
		
		Loris::debugger << ivec.size() << " initial points, " 
						<< tvec.size() << " target points" << Loris::endl;
			
		if ( ivec.size() != tvec.size() )
			Throw( Loris::InvalidArgument, "Invalid arguments to dilate(): there must be as many target points as initial points" );
				
		double * initial = ivec.begin();
		double * target = tvec.begin();
		int npts = ivec.size();
	
		//	USE THE PI INSTEAD!
			
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((double *) initial);
		ThrowIfNull((double *) target);
	
		Loris::notifier << "dilating " << partials->size() << " Partials" << Loris::endl;
		Loris::Dilator dil( initial, target, npts );
		dil.dilate( partials->begin(), partials->end() );
	}
	/*	Dilate Partials in a PartialList according to the given 
		initial and target time points. Partial envelopes are 
		stretched and compressed so that temporal features at
		the initial time points are aligned with the final time
		points. Time points are sorted, so Partial envelopes are 
		are only stretched and compressed, but breakpoints are not
		reordered. Duplicate time points are allowed. There must be
		the same number of initial and target time points.
		
		The time points are passed as strings; convert any native
		collection to a string representation, numerical elements
		will be extracted, other characters will be ignored.
	 */


	#include<SdifFile.h>
	PartialList * importSdif_( const char * path )
	{
		Loris::notifier << "importing Partials from " << path << Loris::endl;
		Loris::SdifFile imp( path );

		PartialList * partials = new PartialList();
		//	splice() can't throw, can it???
		partials->splice( partials->end(), imp.partials() );

		return partials;
	}


	#include<SpcFile.h>
	PartialList * importSpc_( const char * path )
	{
		Loris::notifier << "importing Partials from " << path << Loris::endl;
		Loris::SpcFile imp( path );

		PartialList * partials = new PartialList();
		//	splice() can't throw, can it???
		partials->splice( partials->end(), imp.partials() );

		return partials;
	}


	#include<Morpher.h>
	PartialList * morph_( const PartialList * src0, const PartialList * src1, 
						 const BreakpointEnvelope * ffreq, 
						 const BreakpointEnvelope * famp, 
						 const BreakpointEnvelope * fbw )
	{
		ThrowIfNull((PartialList *) src0);
		ThrowIfNull((PartialList *) src1);
		ThrowIfNull((BreakpointEnvelope *) ffreq);
		ThrowIfNull((BreakpointEnvelope *) famp);
		ThrowIfNull((BreakpointEnvelope *) fbw);

		Loris::notifier << "morphing " << src0->size() << " Partials with "
						<< src1->size() << " Partials" << Loris::endl;
					
		//	make a Morpher object and do it:
		Loris::Morpher m( *ffreq, *famp, *fbw );
		m.morph( src0->begin(), src0->end(), src1->begin(), src1->end() );
				
		//	splice the morphed Partials into a new PartialList:
		PartialList * dst = new PartialList();
		//	splice() can't throw, can it???
		dst->splice( dst->end(), m.partials() );
		return dst;
	}


	#include<Synthesizer.h>
	SampleVector * synthesize_( const PartialList * partials, double srate = 44100.0 )
	{
		ThrowIfNull((PartialList *) partials);

		Loris::notifier << "synthesizing " << partials->size() 
						<< " Partials at " << srate << " Hz" << Loris::endl;

		//	compute the duration:
		debugger << "computing duration..." << Loris::endl;
		double maxtime = 0.;
		PartialList::const_iterator it;
		for ( it = partials->begin(); it != partials->end(); ++it ) 
		{
			maxtime = std::max( maxtime, it->endTime() );
		}
		debugger << maxtime << " seconds" << Loris::endl;
		
		//	allocate a SampleVector to accomodate the fade-out at 
		//	the end of the latest Partial:
		const long nsamps = long( srate * ( maxtime + Partial::FadeTime() ) );	
		SampleVector * samples = new SampleVector( nsamps, 0. );
		
		//	synthesize:
		try
		{
			Loris::Synthesizer synth( srate, samples->begin(), samples->end() );
			for ( it = partials->begin(); it != partials->end(); ++it ) 
			{
				synth.synthesize( *it );
			}
		}
		catch(...)
		{
			delete samples;
			throw;
		}
		
		return samples;
	}


	#include<Sieve.h>


	void sift( PartialList * partials )
	{		
		
		ThrowIfNull((PartialList *) partials);

		Loris::notifier << "sifting " << partials->size() << " Partials" << Loris::endl;
		
		Loris::Sieve sieve( 0.0001 );
		sieve.sift( *partials );
	}
	/*	Eliminate overlapping Partials having the same label 
		(except zero). If any two partials with same label 
		overlap in time, keep only the longer of the two.
		Set the label of the shorter duration partial to zero.
		
	 */


	PartialList * extract_( PartialList * partials, long label )
	{
        ThrowIfNull((PartialList *) partials);

		PartialList * ret = new PartialList();
		try 
		{
			spliceByLabel( partials, label, ret );
		}
		catch(...)
		{
			delete ret;
			throw;
		}
		return ret;
	}


	const char * version( void )
	{
		static const char * vstr = LORIS_VERSION_STR;
		return vstr;
	}

#ifdef __cplusplus
extern "C" {
#endif
static PyObject *_wrap_new_PartialList(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_PartialList")) return NULL;
    {
        try
        {
            result = (PartialList *)new_PartialList();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
}


static PyObject *_wrap_delete_PartialList(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PartialList",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            delete_PartialList(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_PartialList_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    PartialList *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_copy",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialList *)PartialList_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
}


static PyObject *_wrap_PartialList_timeSpan(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    double *arg2 ;
    double *arg3 ;
    double temp2 ;
    double temp3 ;
    PyObject * obj0  = 0 ;
    
    {
        arg2 = &temp2;
    }
    {
        arg3 = &temp3;
    }
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_timeSpan",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            PartialList_timeSpan(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o;
        o = PyFloat_FromDouble((double) (*arg2));
        resultobj = t_output_helper(resultobj, o);
    }
    {
        PyObject *o;
        o = PyFloat_FromDouble((double) (*arg3));
        resultobj = t_output_helper(resultobj, o);
    }
    return resultobj;
}


static PyObject *_wrap_PartialList_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_clear",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->clear();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_PartialList_size(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    unsigned long result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_size",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            result = (unsigned long )(arg1)->size();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_PartialList_begin(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    SwigValueWrapper<PartialListIterator> result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_begin",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            result = (arg1)->begin();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultptr;
        resultptr = new PartialListIterator (result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialListIterator, 1);
    }
    return resultobj;
}


static PyObject *_wrap_PartialList_end(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    SwigValueWrapper<PartialListIterator> result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_end",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            result = (arg1)->end();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultptr;
        resultptr = new PartialListIterator (result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialListIterator, 1);
    }
    return resultobj;
}


static PyObject *_wrap_PartialList_insert(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    PartialListIterator arg2 ;
    Partial *arg3 ;
    SwigValueWrapper<PartialListIterator> result;
    PartialListIterator *argp2 ;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    PyObject * obj2  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialList_insert",&obj0,&obj1,&obj2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &argp2, SWIGTYPE_p_PartialListIterator,1) == -1)) return NULL;
    arg2 = *argp2; 
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (arg1)->insert(arg2,(Partial const &)*arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultptr;
        resultptr = new PartialListIterator (result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialListIterator, 1);
    }
    return resultobj;
}


static PyObject *_wrap_PartialList_erase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    PartialListIterator arg2 ;
    PartialListIterator *argp2 ;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialList_erase",&obj0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &argp2, SWIGTYPE_p_PartialListIterator,1) == -1)) return NULL;
    arg2 = *argp2; 
    {
        try
        {
            (arg1)->erase(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_PartialList_splice(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    PartialListIterator arg2 ;
    PartialList *arg3 ;
    PartialListIterator *argp2 ;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    PyObject * obj2  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialList_splice",&obj0,&obj1,&obj2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &argp2, SWIGTYPE_p_PartialListIterator,1) == -1)) return NULL;
    arg2 = *argp2; 
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->splice(arg2,*arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject * PartialList_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_PartialList, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_PartialListIterator_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 ;
    PartialListIterator *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_copy",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListIterator, 1);
    return resultobj;
}


static PyObject *_wrap_PartialListIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 ;
    PartialListIterator *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_next",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_next(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListIterator, 1);
    return resultobj;
}


static PyObject *_wrap_PartialListIterator_prev(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 ;
    PartialListIterator *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_prev",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_prev(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListIterator, 1);
    return resultobj;
}


static PyObject *_wrap_PartialListIterator_partial(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 ;
    Partial *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_partial",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (Partial *)PartialListIterator_partial(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Partial, 0);
    return resultobj;
}


static PyObject *_wrap_PartialListIterator_equals(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 ;
    PartialListIterator *arg2 ;
    int result;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialListIterator_equals",&obj0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (int )PartialListIterator_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_PartialListIterator_isInRange(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 ;
    PartialListIterator *arg2 ;
    PartialListIterator *arg3 ;
    int result;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    PyObject * obj2  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialListIterator_isInRange",&obj0,&obj1,&obj2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (int )PartialListIterator_isInRange(arg1,(PartialListIterator const *)arg2,(PartialListIterator const *)arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_new_PartialListIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_PartialListIterator")) return NULL;
    {
        try
        {
            result = (PartialListIterator *)new PartialListIterator();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListIterator, 0);
    return resultobj;
}


static PyObject *_wrap_delete_PartialListIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PartialListIterator",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject * PartialListIterator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_PartialListIterator, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_Partial(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_Partial")) return NULL;
    {
        try
        {
            result = (Partial *)new Partial();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Partial, 1);
    return resultobj;
}


static PyObject *_wrap_delete_Partial(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Partial",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Partial_label(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    int result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_label",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (int )((Partial const *)arg1)->label();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_Partial_initialPhase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_initialPhase",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Partial const *)arg1)->initialPhase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Partial_startTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_startTime",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Partial const *)arg1)->startTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Partial_endTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_endTime",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Partial const *)arg1)->endTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Partial_duration(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_duration",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Partial const *)arg1)->duration();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Partial_numBreakpoints(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    long result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_numBreakpoints",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (long )((Partial const *)arg1)->numBreakpoints();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_Partial_setLabel(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    int arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:Partial_setLabel",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->setLabel(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Partial_begin(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    SwigValueWrapper<PartialIterator> result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_begin",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (arg1)->begin();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator (result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialIterator, 1);
    }
    return resultobj;
}


static PyObject *_wrap_Partial_end(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    SwigValueWrapper<PartialIterator> result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_end",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (arg1)->end();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator (result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialIterator, 1);
    }
    return resultobj;
}


static PyObject *_wrap_Partial_insert(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    double arg2 ;
    Breakpoint *arg3 ;
    SwigValueWrapper<PartialIterator> result;
    PyObject * obj0  = 0 ;
    PyObject * obj2  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OdO:Partial_insert",&obj0,&arg2,&obj2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            result = (arg1)->insert(arg2,(Breakpoint const &)*arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator (result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialIterator, 1);
    }
    return resultobj;
}


static PyObject *_wrap_Partial_findAfter(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    double arg2 ;
    SwigValueWrapper<PartialIterator> result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_findAfter",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (arg1)->findAfter(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator (result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialIterator, 1);
    }
    return resultobj;
}


static PyObject *_wrap_Partial_findNearest(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    double arg2 ;
    SwigValueWrapper<PartialIterator> result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_findNearest",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (arg1)->findNearest(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator (result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialIterator, 1);
    }
    return resultobj;
}


static PyObject *_wrap_Partial_erase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    PartialIterator *arg2 ;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_erase",&obj0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->erase(*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Partial_frequencyAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    double arg2 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_frequencyAt",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Partial const *)arg1)->frequencyAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Partial_amplitudeAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    double arg2 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_amplitudeAt",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Partial const *)arg1)->amplitudeAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Partial_bandwidthAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    double arg2 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_bandwidthAt",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Partial const *)arg1)->bandwidthAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Partial_phaseAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    double arg2 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_phaseAt",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Partial const *)arg1)->phaseAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Partial_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    Partial *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_copy",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (Partial *)Partial_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Partial, 1);
    return resultobj;
}


static PyObject *_wrap_Partial_equals(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 ;
    Partial *arg2 ;
    int result;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_equals",&obj0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (int )Partial_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject * Partial_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_Partial, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_PartialIterator_time(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_time",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((PartialIterator const *)arg1)->time();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_PartialIterator_breakpoint(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 ;
    Breakpoint *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_breakpoint",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (Breakpoint *)PartialIterator_breakpoint(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Breakpoint, 0);
    return resultobj;
}


static PyObject *_wrap_PartialIterator_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 ;
    PartialIterator *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_copy",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialIterator, 1);
    return resultobj;
}


static PyObject *_wrap_PartialIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 ;
    PartialIterator *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_next",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_next(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialIterator, 1);
    return resultobj;
}


static PyObject *_wrap_PartialIterator_prev(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 ;
    PartialIterator *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_prev",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_prev(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialIterator, 1);
    return resultobj;
}


static PyObject *_wrap_PartialIterator_equals(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 ;
    PartialIterator *arg2 ;
    int result;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialIterator_equals",&obj0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (int )PartialIterator_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_PartialIterator_isInRange(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 ;
    PartialIterator *arg2 ;
    PartialIterator *arg3 ;
    int result;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    PyObject * obj2  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialIterator_isInRange",&obj0,&obj1,&obj2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (int )PartialIterator_isInRange(arg1,(PartialIterator const *)arg2,(PartialIterator const *)arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_new_PartialIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_PartialIterator")) return NULL;
    {
        try
        {
            result = (PartialIterator *)new PartialIterator();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialIterator, 0);
    return resultobj;
}


static PyObject *_wrap_delete_PartialIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PartialIterator",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject * PartialIterator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_PartialIterator, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_Breakpoint(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double arg3 ;
    double arg4 = 0. ;
    Breakpoint *result;
    
    if(!PyArg_ParseTuple(args,(char *)"ddd|d:new_Breakpoint",&arg1,&arg2,&arg3,&arg4)) return NULL;
    {
        try
        {
            result = (Breakpoint *)new Breakpoint(arg1,arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Breakpoint, 1);
    return resultobj;
}


static PyObject *_wrap_delete_Breakpoint(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Breakpoint",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Breakpoint_frequency(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_frequency",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            result = (double )(arg1)->frequency();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Breakpoint_amplitude(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_amplitude",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            result = (double )(arg1)->amplitude();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Breakpoint_bandwidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_bandwidth",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            result = (double )(arg1)->bandwidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Breakpoint_phase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_phase",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            result = (double )(arg1)->phase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Breakpoint_setFrequency(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 ;
    double arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Breakpoint_setFrequency",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->setFrequency(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Breakpoint_setAmplitude(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 ;
    double arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Breakpoint_setAmplitude",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->setAmplitude(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Breakpoint_setBandwidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 ;
    double arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Breakpoint_setBandwidth",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->setBandwidth(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Breakpoint_setPhase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 ;
    double arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Breakpoint_setPhase",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->setPhase(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Breakpoint_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 ;
    Breakpoint *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_copy",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            result = (Breakpoint *)Breakpoint_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Breakpoint, 1);
    return resultobj;
}


static PyObject *_wrap_Breakpoint_equals(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 ;
    Breakpoint *arg2 ;
    int result;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Breakpoint_equals",&obj0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            result = (int )Breakpoint_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject * Breakpoint_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_Breakpoint, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_SampleVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned long arg1 = 0 ;
    SampleVector *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"|O:new_SampleVector",&obj0)) return NULL;
    if (obj0)
    arg1 = (unsigned long ) PyInt_AsLong(obj0);
    if (PyErr_Occurred()) return NULL;
    {
        try
        {
            result = (SampleVector *)new SampleVector(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector, 1);
    return resultobj;
}


static PyObject *_wrap_delete_SampleVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg1 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_SampleVector",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_SampleVector_size(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg1 ;
    unsigned long result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SampleVector_size",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            result = (unsigned long )(arg1)->size();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_SampleVector_resize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg1 ;
    unsigned long arg2 ;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SampleVector_resize",&obj0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    arg2 = (unsigned long ) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) return NULL;
    {
        try
        {
            (arg1)->resize(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_SampleVector_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg1 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SampleVector_clear",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->clear();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_SampleVector_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg1 ;
    SampleVector *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SampleVector_copy",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            result = (SampleVector *)SampleVector_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector, 1);
    return resultobj;
}


static PyObject *_wrap_SampleVector_getAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg1 ;
    unsigned long arg2 ;
    double result;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SampleVector_getAt",&obj0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    arg2 = (unsigned long ) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) return NULL;
    {
        try
        {
            result = (double )SampleVector_getAt(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_SampleVector_setAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg1 ;
    unsigned long arg2 ;
    double arg3 ;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOd:SampleVector_setAt",&obj0,&obj1,&arg3)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    arg2 = (unsigned long ) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) return NULL;
    {
        try
        {
            SampleVector_setAt(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject * SampleVector_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_SampleVector, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_delete_Analyzer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Analyzer",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_new_Analyzer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 = 0. ;
    Analyzer *result;
    
    if(!PyArg_ParseTuple(args,(char *)"d|d:new_Analyzer",&arg1,&arg2)) return NULL;
    {
        try
        {
            result = (Analyzer *)new_Analyzer(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Analyzer, 1);
    return resultobj;
}


static PyObject *_wrap_Analyzer_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    Analyzer *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_copy",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (Analyzer *)Analyzer_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Analyzer, 1);
    return resultobj;
}


static PyObject *_wrap_Analyzer_analyze(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    SampleVector *arg2 ;
    double arg3 ;
    PartialList *result;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOd:Analyzer_analyze",&obj0,&obj1,&arg3)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialList *)Analyzer_analyze(arg1,(SampleVector const *)arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
}


static PyObject *_wrap_Analyzer_freqResolution(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_freqResolution",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->freqResolution();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_ampFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_ampFloor",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->ampFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_windowWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_windowWidth",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->windowWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_freqFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_freqFloor",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->freqFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_hopTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_hopTime",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->hopTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_freqDrift(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_freqDrift",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->freqDrift();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_cropTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_cropTime",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->cropTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_bwRegionWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_bwRegionWidth",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->bwRegionWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_setFreqResolution(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setFreqResolution",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->setFreqResolution(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setAmpFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setAmpFloor",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->setAmpFloor(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setWindowWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setWindowWidth",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->setWindowWidth(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setFreqFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setFreqFloor",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->setFreqFloor(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setFreqDrift(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setFreqDrift",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->setFreqDrift(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setHopTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setHopTime",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->setHopTime(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setCropTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setCropTime",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->setCropTime(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setBwRegionWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 ;
    double arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setBwRegionWidth",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->setBwRegionWidth(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject * Analyzer_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_Analyzer, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_BreakpointEnvelope(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_BreakpointEnvelope")) return NULL;
    {
        try
        {
            result = (BreakpointEnvelope *)new BreakpointEnvelope();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope, 1);
    return resultobj;
}


static PyObject *_wrap_delete_BreakpointEnvelope(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg1 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_BreakpointEnvelope",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_BreakpointEnvelope_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg1 ;
    BreakpointEnvelope *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointEnvelope_copy",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelope_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope, 1);
    return resultobj;
}


static PyObject *_wrap_BreakpointEnvelope_valueAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg1 ;
    double arg2 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:BreakpointEnvelope_valueAt",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((BreakpointEnvelope const *)arg1)->valueAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_BreakpointEnvelope_insertBreakpoint(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg1 ;
    double arg2 ;
    double arg3 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Odd:BreakpointEnvelope_insertBreakpoint",&obj0,&arg2,&arg3)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            (arg1)->insertBreakpoint(arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject * BreakpointEnvelope_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_BreakpointEnvelope, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_BreakpointEnvelopeWithValue(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    BreakpointEnvelope *result;
    
    if(!PyArg_ParseTuple(args,(char *)"d:BreakpointEnvelopeWithValue",&arg1)) return NULL;
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelopeWithValue_(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope, 1);
    return resultobj;
}


static PyObject *_wrap_new_AiffFile(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    AiffFile *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:new_AiffFile",&arg1)) return NULL;
    {
        try
        {
            result = (AiffFile *)new AiffFile((char const *)arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AiffFile, 1);
    return resultobj;
}


static PyObject *_wrap_delete_AiffFile(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_AiffFile",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_AiffFile_channels(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 ;
    int result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_channels",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            result = (int )((AiffFile const *)arg1)->channels();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_AiffFile_sampleFrames(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 ;
    unsigned long result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_sampleFrames",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            result = (unsigned long )((AiffFile const *)arg1)->sampleFrames();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_AiffFile_sampleRate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 ;
    double result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_sampleRate",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            result = (double )((AiffFile const *)arg1)->sampleRate();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_AiffFile_sampleSize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 ;
    int result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_sampleSize",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            result = (int )((AiffFile const *)arg1)->sampleSize();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_AiffFile_samples(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 ;
    SampleVector *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_samples",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            result = (SampleVector *)AiffFile_samples(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector, 1);
    return resultobj;
}


static PyObject * AiffFile_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_AiffFile, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_channelize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    BreakpointEnvelope *arg2 ;
    int arg3 ;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOi:channelize",&obj0,&obj1,&arg3)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            channelize(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_createFreqReference(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    double arg2 ;
    double arg3 ;
    BreakpointEnvelope *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Odd:createFreqReference",&obj0,&arg2,&arg3)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            result = (BreakpointEnvelope *)createFreqReference(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope, 1);
    return resultobj;
}


static PyObject *_wrap_dilate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    char *arg2 ;
    char *arg3 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oss:dilate",&obj0,&arg2,&arg3)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            dilate_str(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_distill(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:distill",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            distill(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_exportAiff(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    SampleVector *arg2 ;
    double arg3 = 44100.0 ;
    int arg4 = 1 ;
    int arg5 = 16 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sO|dii:exportAiff",&arg1,&obj1,&arg3,&arg4,&arg5)) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            exportAiff((char const *)arg1,arg2,arg3,arg4,arg5);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_exportSdif(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PartialList *arg2 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sO:exportSdif",&arg1,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            exportSdif((char const *)arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_exportSpc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PartialList *arg2 ;
    double arg3 ;
    int arg4 = true ;
    double arg5 = 0. ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sOd|id:exportSpc",&arg1,&obj1,&arg3,&arg4,&arg5)) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            exportSpc((char const *)arg1,arg2,arg3,arg4,arg5);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_importSdif(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PartialList *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:importSdif",&arg1)) return NULL;
    {
        try
        {
            result = (PartialList *)importSdif_((char const *)arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
}


static PyObject *_wrap_importSpc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PartialList *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:importSpc",&arg1)) return NULL;
    {
        try
        {
            result = (PartialList *)importSpc_((char const *)arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
}


static PyObject *_wrap_morph(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    PartialList *arg2 ;
    BreakpointEnvelope *arg3 ;
    BreakpointEnvelope *arg4 ;
    BreakpointEnvelope *arg5 ;
    PartialList *result;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    PyObject * obj2  = 0 ;
    PyObject * obj3  = 0 ;
    PyObject * obj4  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:morph",&obj0,&obj1,&obj2,&obj3,&obj4)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj3,(void **) &arg4, SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj4,(void **) &arg5, SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialList *)morph_((PartialList const *)arg1,(PartialList const *)arg2,(BreakpointEnvelope const *)arg3,(BreakpointEnvelope const *)arg4,(BreakpointEnvelope const *)arg5);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
}


static PyObject *_wrap_synthesize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    double arg2 ;
    SampleVector *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:synthesize",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            result = (SampleVector *)synthesize_((PartialList const *)arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector, 1);
    return resultobj;
}


static PyObject *_wrap_sift(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:sift",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            sift(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_extractLabeled(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    long arg2 ;
    PartialList *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Ol:extractLabeled",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialList *)extract_(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
}


static PyObject *_wrap_scaleAmp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    BreakpointEnvelope *arg2 ;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleAmp",&obj0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            scaleAmp(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_scaleNoiseRatio(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    BreakpointEnvelope *arg2 ;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleNoiseRatio",&obj0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            scaleNoiseRatio(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_shiftPitch(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 ;
    BreakpointEnvelope *arg2 ;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:shiftPitch",&obj0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            shiftPitch(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_version(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *result;
    
    if(!PyArg_ParseTuple(args,(char *)":version")) return NULL;
    {
        try
        {
            result = (char *)version();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
}


static PyMethodDef SwigMethods[] = {
	 { (char *)"new_PartialList", _wrap_new_PartialList, METH_VARARGS },
	 { (char *)"delete_PartialList", _wrap_delete_PartialList, METH_VARARGS },
	 { (char *)"PartialList_copy", _wrap_PartialList_copy, METH_VARARGS },
	 { (char *)"PartialList_timeSpan", _wrap_PartialList_timeSpan, METH_VARARGS },
	 { (char *)"PartialList_clear", _wrap_PartialList_clear, METH_VARARGS },
	 { (char *)"PartialList_size", _wrap_PartialList_size, METH_VARARGS },
	 { (char *)"PartialList_begin", _wrap_PartialList_begin, METH_VARARGS },
	 { (char *)"PartialList_end", _wrap_PartialList_end, METH_VARARGS },
	 { (char *)"PartialList_insert", _wrap_PartialList_insert, METH_VARARGS },
	 { (char *)"PartialList_erase", _wrap_PartialList_erase, METH_VARARGS },
	 { (char *)"PartialList_splice", _wrap_PartialList_splice, METH_VARARGS },
	 { (char *)"PartialList_swigregister", PartialList_swigregister, METH_VARARGS },
	 { (char *)"PartialListIterator_copy", _wrap_PartialListIterator_copy, METH_VARARGS },
	 { (char *)"PartialListIterator_next", _wrap_PartialListIterator_next, METH_VARARGS },
	 { (char *)"PartialListIterator_prev", _wrap_PartialListIterator_prev, METH_VARARGS },
	 { (char *)"PartialListIterator_partial", _wrap_PartialListIterator_partial, METH_VARARGS },
	 { (char *)"PartialListIterator_equals", _wrap_PartialListIterator_equals, METH_VARARGS },
	 { (char *)"PartialListIterator_isInRange", _wrap_PartialListIterator_isInRange, METH_VARARGS },
	 { (char *)"new_PartialListIterator", _wrap_new_PartialListIterator, METH_VARARGS },
	 { (char *)"delete_PartialListIterator", _wrap_delete_PartialListIterator, METH_VARARGS },
	 { (char *)"PartialListIterator_swigregister", PartialListIterator_swigregister, METH_VARARGS },
	 { (char *)"new_Partial", _wrap_new_Partial, METH_VARARGS },
	 { (char *)"delete_Partial", _wrap_delete_Partial, METH_VARARGS },
	 { (char *)"Partial_label", _wrap_Partial_label, METH_VARARGS },
	 { (char *)"Partial_initialPhase", _wrap_Partial_initialPhase, METH_VARARGS },
	 { (char *)"Partial_startTime", _wrap_Partial_startTime, METH_VARARGS },
	 { (char *)"Partial_endTime", _wrap_Partial_endTime, METH_VARARGS },
	 { (char *)"Partial_duration", _wrap_Partial_duration, METH_VARARGS },
	 { (char *)"Partial_numBreakpoints", _wrap_Partial_numBreakpoints, METH_VARARGS },
	 { (char *)"Partial_setLabel", _wrap_Partial_setLabel, METH_VARARGS },
	 { (char *)"Partial_begin", _wrap_Partial_begin, METH_VARARGS },
	 { (char *)"Partial_end", _wrap_Partial_end, METH_VARARGS },
	 { (char *)"Partial_insert", _wrap_Partial_insert, METH_VARARGS },
	 { (char *)"Partial_findAfter", _wrap_Partial_findAfter, METH_VARARGS },
	 { (char *)"Partial_findNearest", _wrap_Partial_findNearest, METH_VARARGS },
	 { (char *)"Partial_erase", _wrap_Partial_erase, METH_VARARGS },
	 { (char *)"Partial_frequencyAt", _wrap_Partial_frequencyAt, METH_VARARGS },
	 { (char *)"Partial_amplitudeAt", _wrap_Partial_amplitudeAt, METH_VARARGS },
	 { (char *)"Partial_bandwidthAt", _wrap_Partial_bandwidthAt, METH_VARARGS },
	 { (char *)"Partial_phaseAt", _wrap_Partial_phaseAt, METH_VARARGS },
	 { (char *)"Partial_copy", _wrap_Partial_copy, METH_VARARGS },
	 { (char *)"Partial_equals", _wrap_Partial_equals, METH_VARARGS },
	 { (char *)"Partial_swigregister", Partial_swigregister, METH_VARARGS },
	 { (char *)"PartialIterator_time", _wrap_PartialIterator_time, METH_VARARGS },
	 { (char *)"PartialIterator_breakpoint", _wrap_PartialIterator_breakpoint, METH_VARARGS },
	 { (char *)"PartialIterator_copy", _wrap_PartialIterator_copy, METH_VARARGS },
	 { (char *)"PartialIterator_next", _wrap_PartialIterator_next, METH_VARARGS },
	 { (char *)"PartialIterator_prev", _wrap_PartialIterator_prev, METH_VARARGS },
	 { (char *)"PartialIterator_equals", _wrap_PartialIterator_equals, METH_VARARGS },
	 { (char *)"PartialIterator_isInRange", _wrap_PartialIterator_isInRange, METH_VARARGS },
	 { (char *)"new_PartialIterator", _wrap_new_PartialIterator, METH_VARARGS },
	 { (char *)"delete_PartialIterator", _wrap_delete_PartialIterator, METH_VARARGS },
	 { (char *)"PartialIterator_swigregister", PartialIterator_swigregister, METH_VARARGS },
	 { (char *)"new_Breakpoint", _wrap_new_Breakpoint, METH_VARARGS },
	 { (char *)"delete_Breakpoint", _wrap_delete_Breakpoint, METH_VARARGS },
	 { (char *)"Breakpoint_frequency", _wrap_Breakpoint_frequency, METH_VARARGS },
	 { (char *)"Breakpoint_amplitude", _wrap_Breakpoint_amplitude, METH_VARARGS },
	 { (char *)"Breakpoint_bandwidth", _wrap_Breakpoint_bandwidth, METH_VARARGS },
	 { (char *)"Breakpoint_phase", _wrap_Breakpoint_phase, METH_VARARGS },
	 { (char *)"Breakpoint_setFrequency", _wrap_Breakpoint_setFrequency, METH_VARARGS },
	 { (char *)"Breakpoint_setAmplitude", _wrap_Breakpoint_setAmplitude, METH_VARARGS },
	 { (char *)"Breakpoint_setBandwidth", _wrap_Breakpoint_setBandwidth, METH_VARARGS },
	 { (char *)"Breakpoint_setPhase", _wrap_Breakpoint_setPhase, METH_VARARGS },
	 { (char *)"Breakpoint_copy", _wrap_Breakpoint_copy, METH_VARARGS },
	 { (char *)"Breakpoint_equals", _wrap_Breakpoint_equals, METH_VARARGS },
	 { (char *)"Breakpoint_swigregister", Breakpoint_swigregister, METH_VARARGS },
	 { (char *)"new_SampleVector", _wrap_new_SampleVector, METH_VARARGS },
	 { (char *)"delete_SampleVector", _wrap_delete_SampleVector, METH_VARARGS },
	 { (char *)"SampleVector_size", _wrap_SampleVector_size, METH_VARARGS },
	 { (char *)"SampleVector_resize", _wrap_SampleVector_resize, METH_VARARGS },
	 { (char *)"SampleVector_clear", _wrap_SampleVector_clear, METH_VARARGS },
	 { (char *)"SampleVector_copy", _wrap_SampleVector_copy, METH_VARARGS },
	 { (char *)"SampleVector_getAt", _wrap_SampleVector_getAt, METH_VARARGS },
	 { (char *)"SampleVector_setAt", _wrap_SampleVector_setAt, METH_VARARGS },
	 { (char *)"SampleVector_swigregister", SampleVector_swigregister, METH_VARARGS },
	 { (char *)"delete_Analyzer", _wrap_delete_Analyzer, METH_VARARGS },
	 { (char *)"new_Analyzer", _wrap_new_Analyzer, METH_VARARGS },
	 { (char *)"Analyzer_copy", _wrap_Analyzer_copy, METH_VARARGS },
	 { (char *)"Analyzer_analyze", _wrap_Analyzer_analyze, METH_VARARGS },
	 { (char *)"Analyzer_freqResolution", _wrap_Analyzer_freqResolution, METH_VARARGS },
	 { (char *)"Analyzer_ampFloor", _wrap_Analyzer_ampFloor, METH_VARARGS },
	 { (char *)"Analyzer_windowWidth", _wrap_Analyzer_windowWidth, METH_VARARGS },
	 { (char *)"Analyzer_freqFloor", _wrap_Analyzer_freqFloor, METH_VARARGS },
	 { (char *)"Analyzer_hopTime", _wrap_Analyzer_hopTime, METH_VARARGS },
	 { (char *)"Analyzer_freqDrift", _wrap_Analyzer_freqDrift, METH_VARARGS },
	 { (char *)"Analyzer_cropTime", _wrap_Analyzer_cropTime, METH_VARARGS },
	 { (char *)"Analyzer_bwRegionWidth", _wrap_Analyzer_bwRegionWidth, METH_VARARGS },
	 { (char *)"Analyzer_setFreqResolution", _wrap_Analyzer_setFreqResolution, METH_VARARGS },
	 { (char *)"Analyzer_setAmpFloor", _wrap_Analyzer_setAmpFloor, METH_VARARGS },
	 { (char *)"Analyzer_setWindowWidth", _wrap_Analyzer_setWindowWidth, METH_VARARGS },
	 { (char *)"Analyzer_setFreqFloor", _wrap_Analyzer_setFreqFloor, METH_VARARGS },
	 { (char *)"Analyzer_setFreqDrift", _wrap_Analyzer_setFreqDrift, METH_VARARGS },
	 { (char *)"Analyzer_setHopTime", _wrap_Analyzer_setHopTime, METH_VARARGS },
	 { (char *)"Analyzer_setCropTime", _wrap_Analyzer_setCropTime, METH_VARARGS },
	 { (char *)"Analyzer_setBwRegionWidth", _wrap_Analyzer_setBwRegionWidth, METH_VARARGS },
	 { (char *)"Analyzer_swigregister", Analyzer_swigregister, METH_VARARGS },
	 { (char *)"new_BreakpointEnvelope", _wrap_new_BreakpointEnvelope, METH_VARARGS },
	 { (char *)"delete_BreakpointEnvelope", _wrap_delete_BreakpointEnvelope, METH_VARARGS },
	 { (char *)"BreakpointEnvelope_copy", _wrap_BreakpointEnvelope_copy, METH_VARARGS },
	 { (char *)"BreakpointEnvelope_valueAt", _wrap_BreakpointEnvelope_valueAt, METH_VARARGS },
	 { (char *)"BreakpointEnvelope_insertBreakpoint", _wrap_BreakpointEnvelope_insertBreakpoint, METH_VARARGS },
	 { (char *)"BreakpointEnvelope_swigregister", BreakpointEnvelope_swigregister, METH_VARARGS },
	 { (char *)"BreakpointEnvelopeWithValue", _wrap_BreakpointEnvelopeWithValue, METH_VARARGS },
	 { (char *)"new_AiffFile", _wrap_new_AiffFile, METH_VARARGS },
	 { (char *)"delete_AiffFile", _wrap_delete_AiffFile, METH_VARARGS },
	 { (char *)"AiffFile_channels", _wrap_AiffFile_channels, METH_VARARGS },
	 { (char *)"AiffFile_sampleFrames", _wrap_AiffFile_sampleFrames, METH_VARARGS },
	 { (char *)"AiffFile_sampleRate", _wrap_AiffFile_sampleRate, METH_VARARGS },
	 { (char *)"AiffFile_sampleSize", _wrap_AiffFile_sampleSize, METH_VARARGS },
	 { (char *)"AiffFile_samples", _wrap_AiffFile_samples, METH_VARARGS },
	 { (char *)"AiffFile_swigregister", AiffFile_swigregister, METH_VARARGS },
	 { (char *)"channelize", _wrap_channelize, METH_VARARGS },
	 { (char *)"createFreqReference", _wrap_createFreqReference, METH_VARARGS },
	 { (char *)"dilate", _wrap_dilate, METH_VARARGS },
	 { (char *)"distill", _wrap_distill, METH_VARARGS },
	 { (char *)"exportAiff", _wrap_exportAiff, METH_VARARGS },
	 { (char *)"exportSdif", _wrap_exportSdif, METH_VARARGS },
	 { (char *)"exportSpc", _wrap_exportSpc, METH_VARARGS },
	 { (char *)"importSdif", _wrap_importSdif, METH_VARARGS },
	 { (char *)"importSpc", _wrap_importSpc, METH_VARARGS },
	 { (char *)"morph", _wrap_morph, METH_VARARGS },
	 { (char *)"synthesize", _wrap_synthesize, METH_VARARGS },
	 { (char *)"sift", _wrap_sift, METH_VARARGS },
	 { (char *)"extractLabeled", _wrap_extractLabeled, METH_VARARGS },
	 { (char *)"scaleAmp", _wrap_scaleAmp, METH_VARARGS },
	 { (char *)"scaleNoiseRatio", _wrap_scaleNoiseRatio, METH_VARARGS },
	 { (char *)"shiftPitch", _wrap_shiftPitch, METH_VARARGS },
	 { (char *)"version", _wrap_version, METH_VARARGS },
	 { NULL, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_Partial[] = {{"_p_Partial", 0, "Partial *"},{"_p_Partial"},{0}};
static swig_type_info _swigt__p_PartialList[] = {{"_p_PartialList", 0, "PartialList *"},{"_p_PartialList"},{0}};
static swig_type_info _swigt__p_SampleVector[] = {{"_p_SampleVector", 0, "SampleVector *"},{"_p_SampleVector"},{0}};
static swig_type_info _swigt__p_AiffFile[] = {{"_p_AiffFile", 0, "AiffFile *"},{"_p_AiffFile"},{0}};
static swig_type_info _swigt__p_Analyzer[] = {{"_p_Analyzer", 0, "Analyzer *"},{"_p_Analyzer"},{0}};
static swig_type_info _swigt__p_double[] = {{"_p_double", 0, "double *"},{"_p_double"},{0}};
static swig_type_info _swigt__p_PartialListIterator[] = {{"_p_PartialListIterator", 0, "PartialListIterator *"},{"_p_PartialListIterator"},{0}};
static swig_type_info _swigt__p_PartialIterator[] = {{"_p_PartialIterator", 0, "PartialIterator *"},{"_p_PartialIterator"},{0}};
static swig_type_info _swigt__p_Breakpoint[] = {{"_p_Breakpoint", 0, "Breakpoint *"},{"_p_Breakpoint"},{0}};
static swig_type_info _swigt__p_BreakpointEnvelope[] = {{"_p_BreakpointEnvelope", 0, "BreakpointEnvelope *"},{"_p_BreakpointEnvelope"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_Partial, 
_swigt__p_PartialList, 
_swigt__p_SampleVector, 
_swigt__p_AiffFile, 
_swigt__p_Analyzer, 
_swigt__p_double, 
_swigt__p_PartialListIterator, 
_swigt__p_PartialIterator, 
_swigt__p_Breakpoint, 
_swigt__p_BreakpointEnvelope, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0}};

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void) SWIG_init(void) {
    static PyObject *SWIG_globals = 0; 
    static int       typeinit = 0;
    PyObject *m, *d;
    int       i;
    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
    m = Py_InitModule((char *) SWIG_name, SwigMethods);
    d = PyModule_GetDict(m);
    
    if (!typeinit) {
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }
        typeinit = 1;
    }
    SWIG_InstallConstants(d,swig_const_table);
    
    
    Loris::setNotifierHandler( printf_notifier );
    Loris::setDebuggerHandler( printf_notifier );
    
}

