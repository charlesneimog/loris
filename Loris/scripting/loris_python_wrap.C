/*
 * FILE : Dr. Sax:Loris development:Loris:scripting:loris_python_wrap.C
 * 
 * This file was automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1 (Patch 2)
 * 
 * Portions Copyright (c) 1995-1997
 * The University of Utah and The Regents of the University of California.
 * Permission is granted to distribute this file in any manner provided
 * this notice remains intact.
 * 
 * Do not make changes to this file--changes will be lost!
 *
 */


#define SWIGCODE
/* Implementation : PYTHON */

#define SWIGPYTHON
#include <string.h>
#include <stdlib.h>
/***********************************************************************
 * $Header$
 * swig_lib/python/python.cfg
 *
 * This file contains coded needed to add variable linking to the
 * Python interpreter.   C variables are added as a new kind of Python
 * datatype.
 *
 * Also contains supporting code for building python under Windows
 * and things like that.
 *
 * $Log$
 * Revision 1.8  2001/01/29 22:15:04  kfitz
 * Twiddled, seems to work, both C++ and Python 2.0, on G4.
 *
 ************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif
#include "Python.h"
#ifdef __cplusplus
}
#endif

/* Definitions for Windows/Unix exporting */
#if defined(__WIN32__)
#   if defined(_MSC_VER)
#	define SWIGEXPORT(a,b) __declspec(dllexport) a b
#   else
#	if defined(__BORLANDC__)
#	    define SWIGEXPORT(a,b) a _export b
#	else
#	    define SWIGEXPORT(a,b) a b
#	endif
#   endif
#else
#   define SWIGEXPORT(a,b) a b
#endif

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif

typedef struct {
  char  *name;
  PyObject *(*get_attr)(void);
  int (*set_attr)(PyObject *);
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar **vars;
  int      nvars;
  int      maxvars;
} swig_varlinkobject;

/* ----------------------------------------------------------------------
   swig_varlink_repr()

   Function for python repr method
   ---------------------------------------------------------------------- */

static PyObject *
swig_varlink_repr(swig_varlinkobject *v)
{
  v = v;
  return PyString_FromString("<Global variables>");
}

/* ---------------------------------------------------------------------
   swig_varlink_print()

   Print out all of the global variable names
   --------------------------------------------------------------------- */

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags)
{

  int i = 0;
  flags = flags;
  fprintf(fp,"Global variables { ");
  while (v->vars[i]) {
    fprintf(fp,"%s", v->vars[i]->name);
    i++;
    if (v->vars[i]) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

/* --------------------------------------------------------------------
   swig_varlink_getattr
 
   This function gets the value of a variable and returns it as a
   PyObject.   In our case, we'll be looking at the datatype and
   converting into a number or string
   -------------------------------------------------------------------- */

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n)
{
  int i = 0;
  char temp[128];

  while (v->vars[i]) {
    if (strcmp(v->vars[i]->name,n) == 0) {
      return (*v->vars[i]->get_attr)();
    }
    i++;
  }
  sprintf(temp,"C global variable %s not found.", n);
  PyErr_SetString(PyExc_NameError,temp);
  return NULL;
}

/* -------------------------------------------------------------------
   swig_varlink_setattr()

   This function sets the value of a variable.
   ------------------------------------------------------------------- */

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p)
{
  char temp[128];
  int i = 0;
  while (v->vars[i]) {
    if (strcmp(v->vars[i]->name,n) == 0) {
      return (*v->vars[i]->set_attr)(p);
    }
    i++;
  }
  sprintf(temp,"C global variable %s not found.", n);
  PyErr_SetString(PyExc_NameError,temp);
  return 1;
}

statichere PyTypeObject varlinktype = {
/*  PyObject_HEAD_INIT(&PyType_Type)  Note : This doesn't work on some machines */
  PyObject_HEAD_INIT(0)              
  0,
  "varlink",                          /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */

SWIGSTATIC PyObject *
SWIG_newvarlink(void)
{
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  /*  _Py_NewReference(result);  Does not seem to be necessary */
  result->nvars = 0;
  result->maxvars = 64;
  result->vars = (swig_globalvar **) malloc(64*sizeof(swig_globalvar *));
  result->vars[0] = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGSTATIC void
SWIG_addvarlink(PyObject *p, char *name,
	   PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p))
{
  swig_varlinkobject *v;
  v= (swig_varlinkobject *) p;
	
  if (v->nvars >= v->maxvars -1) {
    v->maxvars = 2*v->maxvars;
    v->vars = (swig_globalvar **) realloc(v->vars,v->maxvars*sizeof(swig_globalvar *));
    if (v->vars == NULL) {
      fprintf(stderr,"SWIG : Fatal error in initializing Python module.\n");
      exit(1);
    }
  }
  v->vars[v->nvars] = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  v->vars[v->nvars]->name = (char *) malloc(strlen(name)+1);
  strcpy(v->vars[v->nvars]->name,name);
  v->vars[v->nvars]->get_attr = get_attr;
  v->vars[v->nvars]->set_attr = set_attr;
  v->nvars++;
  v->vars[v->nvars] = 0;
}



/*****************************************************************************
 * $Header$
 *
 * swigptr.swg
 *
 * This file contains supporting code for the SWIG run-time type checking
 * mechanism.  The following functions are available :
 *
 * SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *));
 *
 *      Registers a new type-mapping with the type-checker.  origtype is the
 *      original datatype and newtype is an equivalent type.  cast is optional
 *      pointer to a function to cast pointer values between types (this
 *      is typically used to cast pointers from derived classes to base classes in C++)
 *      
 * SWIG_MakePtr(char *buffer, void *ptr, char *typestring);
 *     
 *      Makes a pointer string from a pointer and typestring.  The result is returned
 *      in buffer which is assumed to hold enough space for the result.
 *
 * char * SWIG_GetPtr(char *buffer, void **ptr, char *type)
 *
 *      Gets a pointer value from a string.  If there is a type-mismatch, returns
 *      a character string to the received type.  On success, returns NULL.
 *
 *
 * You can remap these functions by making a file called "swigptr.swg" in
 * your the same directory as the interface file you are wrapping.
 *
 * These functions are normally declared static, but this file can be
 * can be used in a multi-module environment by redefining the symbol
 * SWIGSTATIC.
 *****************************************************************************/

#include <stdlib.h>

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif


/* SWIG pointer structure */

typedef struct SwigPtrType {
  char               *name;               /* Datatype name                  */
  int                 len;                /* Length (used for optimization) */
  void               *(*cast)(void *);    /* Pointer casting function       */
  struct SwigPtrType *next;               /* Linked list pointer            */
} SwigPtrType;

/* Pointer cache structure */

typedef struct {
  int                 stat;               /* Status (valid) bit             */
  SwigPtrType        *tp;                 /* Pointer to type structure      */
  char                name[256];          /* Given datatype name            */
  char                mapped[256];        /* Equivalent name                */
} SwigCacheType;

/* Some variables  */

static int SwigPtrMax  = 64;           /* Max entries that can be currently held */
                                       /* This value may be adjusted dynamically */
static int SwigPtrN    = 0;            /* Current number of entries              */
static int SwigPtrSort = 0;            /* Status flag indicating sort            */
static int SwigStart[256];             /* Starting positions of types            */

/* Pointer table */
static SwigPtrType *SwigPtrTable = 0;  /* Table containing pointer equivalences  */

/* Cached values */

#define SWIG_CACHESIZE  8
#define SWIG_CACHEMASK  0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];  
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2) {
	SwigPtrType *d1 = (SwigPtrType *) data1;
	SwigPtrType *d2 = (SwigPtrType *) data2;
	return strcmp(d1->name,d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data) {
  char *k = (char *) key;
  SwigPtrType *d = (SwigPtrType *) data;
  return strncmp(k,d->name,d->len);
}

/* Register a new datatype with the type-checker */

SWIGSTATIC 
void SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *)) {

  int i;
  SwigPtrType *t = 0,*t1;

  /* Allocate the pointer table if necessary */

  if (!SwigPtrTable) {     
    SwigPtrTable = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrN = 0;
  }
  /* Grow the table */
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrTable = (SwigPtrType *) realloc((char *) SwigPtrTable,SwigPtrMax*sizeof(SwigPtrType));
  }
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrTable[i].name,origtype) == 0) {
      t = &SwigPtrTable[i];
      break;
    }
  if (!t) {
    t = &SwigPtrTable[SwigPtrN];
    t->name = origtype;
    t->len = strlen(t->name);
    t->cast = 0;
    t->next = 0;
    SwigPtrN++;
  }

  /* Check for existing entry */

  while (t->next) {
    if ((strcmp(t->name,newtype) == 0)) {
      if (cast) t->cast = cast;
      return;
    }
    t = t->next;
  }
  
  /* Now place entry (in sorted order) */

  t1 = (SwigPtrType *) malloc(sizeof(SwigPtrType));
  t1->name = newtype;
  t1->len = strlen(t1->name);
  t1->cast = cast;
  t1->next = 0;            
  t->next = t1;           
  SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATIC 
void SWIG_MakePtr(char *_c, const void *_ptr, char *type) {
  static char _hex[16] =
  {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'a', 'b', 'c', 'd', 'e', 'f'};
  unsigned long _p, _s;
  char _result[20], *_r;    /* Note : a 64-bit hex number = 16 digits */
  _r = _result;
  _p = (unsigned long) _ptr;
  if (_p > 0) {
    while (_p > 0) {
      _s = _p & 0xf;
      *(_r++) = _hex[_s];
      _p = _p >> 4;
    }
    *_r = '_';
    while (_r >= _result)
      *(_c++) = *(_r--);
  } else {
    strcpy (_c, "NULL");
  }
  if (_ptr)
    strcpy (_c, type);
}

/* Define for backwards compatibility */

#define _swig_make_hex   SWIG_MakePtr 

/* Function for getting a pointer value */

SWIGSTATIC 
char *SWIG_GetPtr(char *_c, void **ptr, char *_t)
{
  unsigned long _p;
  char temp_type[256];
  char *name;
  int  i, len;
  SwigPtrType *sp,*tp;
  SwigCacheType *cache;
  int  start, end;
  _p = 0;

  /* Pointer values must start with leading underscore */
  if (*_c == '_') {
      _c++;
      /* Extract hex value from pointer */
      while (*_c) {
	  if ((*_c >= '0') && (*_c <= '9'))
	    _p = (_p << 4) + (*_c - '0');
	  else if ((*_c >= 'a') && (*_c <= 'f'))
	    _p = (_p << 4) + ((*_c - 'a') + 10);
	  else
	    break;
	  _c++;
      }

      if (_t) {
	if (strcmp(_t,_c)) { 
	  if (!SwigPtrSort) {
	    qsort((void *) SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort); 
	    for (i = 0; i < 256; i++) {
	      SwigStart[i] = SwigPtrN;
	    }
	    for (i = SwigPtrN-1; i >= 0; i--) {
	      SwigStart[(int) (SwigPtrTable[i].name[1])] = i;
	    }
	    for (i = 255; i >= 1; i--) {
	      if (SwigStart[i-1] > SwigStart[i])
		SwigStart[i-1] = SwigStart[i];
	    }
	    SwigPtrSort = 1;
	    for (i = 0; i < SWIG_CACHESIZE; i++)  
	      SwigCache[i].stat = 0;
	  }
	  
	  /* First check cache for matches.  Uses last cache value as starting point */
	  cache = &SwigCache[SwigLastCache];
	  for (i = 0; i < SWIG_CACHESIZE; i++) {
	    if (cache->stat) {
	      if (strcmp(_t,cache->name) == 0) {
		if (strcmp(_c,cache->mapped) == 0) {
		  cache->stat++;
		  *ptr = (void *) _p;
		  if (cache->tp->cast) *ptr = (*(cache->tp->cast))(*ptr);
		  return (char *) 0;
		}
	      }
	    }
	    SwigLastCache = (SwigLastCache+1) & SWIG_CACHEMASK;
	    if (!SwigLastCache) cache = SwigCache;
	    else cache++;
	  }
	  /* We have a type mismatch.  Will have to look through our type
	     mapping table to figure out whether or not we can accept this datatype */

	  start = SwigStart[(int) _t[1]];
	  end = SwigStart[(int) _t[1]+1];
	  sp = &SwigPtrTable[start];
	  while (start < end) {
	    if (swigcmp(_t,sp) == 0) break;
	    sp++;
	    start++;
	  }
	  if (start >= end) sp = 0;
	  /* Try to find a match for this */
	  if (sp) {
	    while (swigcmp(_t,sp) == 0) {
	      name = sp->name;
	      len = sp->len;
	      tp = sp->next;
	      /* Try to find entry for our given datatype */
	      while(tp) {
		if (tp->len >= 255) {
		  return _c;
		}
		strncpy(temp_type,tp->name,255);
		strncat(temp_type,_t+len,255-tp->len);
		if (strcmp(_c,temp_type) == 0) {
		  
		  strcpy(SwigCache[SwigCacheIndex].mapped,_c);
		  strcpy(SwigCache[SwigCacheIndex].name,_t);
		  SwigCache[SwigCacheIndex].stat = 1;
		  SwigCache[SwigCacheIndex].tp = tp;
		  SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;
		  
		  /* Get pointer value */
		  *ptr = (void *) _p;
		  if (tp->cast) *ptr = (*(tp->cast))(*ptr);
		  return (char *) 0;
		}
		tp = tp->next;
	      }
	      sp++;
	      /* Hmmm. Didn't find it this time */
	    }
	  }
	  /* Didn't find any sort of match for this data.  
	     Get the pointer value and return the received type */
	  *ptr = (void *) _p;
	  return _c;
	} else {
	  /* Found a match on the first try.  Return pointer value */
	  *ptr = (void *) _p;
	  return (char *) 0;
	}
      } else {
	/* No type specified.  Good luck */
	*ptr = (void *) _p;
	return (char *) 0;
      }
  } else {
    if (strcmp (_c, "NULL") == 0) {
	*ptr = (void *) 0;
	return (char *) 0;
    }
    *ptr = (void *) 0;	
    return _c;
  }
}

/* Compatibility mode */

#define _swig_get_hex  SWIG_GetPtr

#define SWIG_init    initlorisc

#define SWIG_name    "lorisc"
static PyObject *_wrap_python_const___version__;

#define LORIS_OPAQUE_POINTERS 0
#include "loris.h"

#include <string>
#include <vector>

//	convert a string into a vector of doubles,
//	ignore any extraneous characters:
static std::vector<double> strtovec( const std::string & s )
{
    std::vector<double> v;
    std::string::size_type beg, end;
    //const string delims(" \t,[](){}");
    const string numparts("1234567890+-.");
    beg = s.find_first_of( numparts );
    while ( beg != string::npos )
    {
        end = s.find_first_not_of( numparts, beg );
        if ( end == string::npos )
            end = s.length();

        double x = atof( s.c_str() + beg );
        v.push_back(x);

        beg = s.find_first_of( numparts, end );
    }
    return v;
}

//	notification function for Loris exceptions
//	and notifications, installed in initialization
//	block below:
static void printf_notifier( const char * s )
{
	printf("*\t%s\n", s);
}

//	Exceptions absolutely cannot be thrown out of a shared
//	library on the Macintosh, so instead of rethrowing, 
//	store the error string from internal Loris exceptions
//	and catch it in the SWIG exception handler below:
static std::string LorisErrorString;
static void throw_string( const char * s )
{
	LorisErrorString = s;
}

#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99

static void _SWIG_exception(int code, char *msg) {
  switch(code) {
  case SWIG_MemoryError:
    PyErr_SetString(PyExc_MemoryError,msg);
    break;
  case SWIG_IOError:
    PyErr_SetString(PyExc_IOError,msg);
    break;
  case SWIG_RuntimeError:
    PyErr_SetString(PyExc_RuntimeError,msg);
    break;
  case SWIG_IndexError:
    PyErr_SetString(PyExc_IndexError,msg);
    break;
  case SWIG_TypeError:
    PyErr_SetString(PyExc_TypeError,msg);
    break;
  case SWIG_DivisionByZero:
    PyErr_SetString(PyExc_ZeroDivisionError,msg);
    break;
  case SWIG_OverflowError:
    PyErr_SetString(PyExc_OverflowError,msg);
    break;
  case SWIG_SyntaxError:
    PyErr_SetString(PyExc_SyntaxError,msg);
    break;
  case SWIG_ValueError:
    PyErr_SetString(PyExc_ValueError,msg);
    break;
  case SWIG_SystemError:
    PyErr_SetString(PyExc_SystemError,msg);
    break;
  default:
    PyErr_SetString(PyExc_RuntimeError,msg);
    break;
  }
}

#define SWIG_exception(a,b) _SWIG_exception(a,b); return NULL

static PyObject* t_output_helper(PyObject* target, PyObject* o) {
    PyObject*   o2;
    PyObject*   o3;

    if (!target) {                   
        target = o;
    } else if (target == Py_None) {  
        Py_DECREF(Py_None);
        target = o;
    } else {                         
        if (!PyTuple_Check(target)) {
            o2 = target;
            target = PyTuple_New(1);
            PyTuple_SetItem(target, 0, o2);
        }
        o3 = PyTuple_New(1);            
        PyTuple_SetItem(o3, 0, o);      

        o2 = target;
        target = PySequence_Concat(o2, o3); 
        Py_DECREF(o2);                      
        Py_DECREF(o3);
    }
    return target;
}

#include "Analyzer.h"
#include "Partial.h"
//#include <list>
//typedef std::list< Loris::Partial > PartialList;
//using Loris::Analyzer;

//	for procedural interface construction and 
//	destruction, see comment below:
#define LORIS_OPAQUE_POINTERS 0
#include "loris.h"

Analyzer * AnalyzerCopy_( const Analyzer * other )
{
	Analyzer * a = createAnalyzer( other->freqResolution() );
	*a = *other;
	return a;
}

#include "BreakpointEnvelope.h"
using Loris::BreakpointEnvelope;

//	for procedural interface construction and 
//	destruction, see comment below:
//#define LORIS_OPAQUE_POINTERS 0
//#include "loris.h"

BreakpointEnvelope * BreakpointEnvelopeCopy_( const BreakpointEnvelope * other )
{
	BreakpointEnvelope * env = createBreakpointEnvelope();
	*env = *other;
	return new BreakpointEnvelope( *other );
	//return copyBreakpointEnvelope( other );
}

BreakpointEnvelope * BreakpointEnvelopeWithValue_( double initialValue )
{
	/*
	BreakpointEnvelope * env = createBreakpointEnvelope();
	env->insertBreakpoint( 0., initialValue );
	//breakpointEnvelope_insertBreakpoint( env, 0., initialValue );
	return env;
	*/
	return new BreakpointEnvelope( initialValue );
}

#include "ExportSpc.h"
//#include "Partial.h"
//#include <list>
//typedef std::list< Loris::Partial > PartialList;
using Loris::ExportSpc;

//	for procedural interface construction and 
//	destruction, see comment below:
#define LORIS_OPAQUE_POINTERS 0
#include "loris.h"

#include "Partial.h"
#include <list>
typedef std::list< Loris::Partial > PartialList;

PartialList * PartialListCopy_( const PartialList * other )
{
	return new PartialList( *other );
}

#include <stdexcept>
#include <vector>
typedef std::vector< double > SampleVector;

SampleVector * SampleVectorCopy_( const SampleVector * other )
{
	return new SampleVector( *other );
}

void dilate_str( PartialList * partials, 
			 	 char * initial, char * target )
{
	std::vector<double> ivec = strtovec( initial );
	std::vector<double> tvec = strtovec( target );
	
	char s[256];
	sprintf(s, "%d initial points, %d target points",
				(int)ivec.size(), (int)tvec.size() );
	printf_notifier( s );
		
	if ( ivec.size() != tvec.size() )
	{
		std::string s( "Invalid arguments to dilate(): there must be as many target points as initial points" );
		throw s;
	}
			
	dilate( partials, ivec.begin(), tvec.begin(), ivec.size() );
}

	SampleVector * importAiff_( const char * path )
	{
		double samplerate;
		int nchannels;
		SampleVector * vec = new SampleVector();
		importAiff( path, vec, &samplerate, &nchannels );
		return vec;
	}

	unsigned long infoAiff( const char * path, double * samplerate, int * nchannels )
	{		
		char s[256];
		sprintf(s, "getting info for %s", path );
		printf_notifier( s );
		
		SampleVector * vec = new SampleVector();
		importAiff( path, vec, samplerate, nchannels );
		return vec->size() / *nchannels;
	}
	/*	Return the number of sample frames, sample rate, and number 
		of channels of audio samples stored in an AIFF file at the 
		given file path (or name). The samples themselves are obtained 
		using importAiff( path ). 
	 */

	PartialList * importSdif_( const char * path )
	{
		PartialList * partials = new PartialList();
		importSdif( path, partials );
		return partials;
	}

	PartialList * morph_( const PartialList * src0, const PartialList * src1, 
						  const BreakpointEnvelope * ffreq, 
						  const BreakpointEnvelope * famp, 
						  const BreakpointEnvelope * fbw )
	{
		
		PartialList * partials = new PartialList();
		morph( src0, src1, ffreq, famp, fbw, partials );
		return partials;
	}

	SampleVector * synthesize_( const PartialList * partials, double srate )
	{
		SampleVector * samples = new SampleVector();
		synthesize( partials, samples, srate );
		return samples;
	}
static PyObject *_wrap_AnalyzerCopy(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Analyzer * _result;
    Analyzer * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:AnalyzerCopy",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of AnalyzerCopy. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (Analyzer *)AnalyzerCopy_(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_Analyzer_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_BreakpointEnvelopeCopy(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BreakpointEnvelope * _result;
    BreakpointEnvelope * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:BreakpointEnvelopeCopy",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BreakpointEnvelope_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BreakpointEnvelopeCopy. Expected _BreakpointEnvelope_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (BreakpointEnvelope *)BreakpointEnvelopeCopy_(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_BreakpointEnvelope_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_BreakpointEnvelopeWithValue(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BreakpointEnvelope * _result;
    double  _arg0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"d:BreakpointEnvelopeWithValue",&_arg0)) 
        return NULL;
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (BreakpointEnvelope *)BreakpointEnvelopeWithValue_(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_BreakpointEnvelope_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_PartialListCopy(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PartialList * _result;
    PartialList * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:PartialListCopy",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of PartialListCopy. Expected _PartialList_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (PartialList *)PartialListCopy_(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_PartialList_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_SampleVectorCopy(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    SampleVector * _result;
    SampleVector * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:SampleVectorCopy",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_SampleVector_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of SampleVectorCopy. Expected _SampleVector_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (SampleVector *)SampleVectorCopy_(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_SampleVector_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_channelize(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PartialList * _arg0;
    BreakpointEnvelope * _arg1;
    int  _arg2;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ssi:channelize",&_argc0,&_argc1,&_arg2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of channelize. Expected _PartialList_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_BreakpointEnvelope_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of channelize. Expected _BreakpointEnvelope_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    channelize(_arg0,_arg1,_arg2);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static PyObject *_wrap_dilate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PartialList * _arg0;
    char * _arg1;
    char * _arg2;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sss:dilate",&_argc0,&_arg1,&_arg2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of dilate. Expected _PartialList_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    dilate_str(_arg0,_arg1,_arg2);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static PyObject *_wrap_distill(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PartialList * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:distill",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of distill. Expected _PartialList_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    distill(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static PyObject *_wrap_exportAiff(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    char * _arg0;
    SampleVector * _arg1;
    double  _arg2;
    int  _arg3;
    int  _arg4;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ssdii:exportAiff",&_arg0,&_argc1,&_arg2,&_arg3,&_arg4)) 
        return NULL;
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_SampleVector_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of exportAiff. Expected _SampleVector_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    exportAiff(_arg0,_arg1,_arg2,_arg3,_arg4);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static PyObject *_wrap_exportSdif(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    char * _arg0;
    PartialList * _arg1;
    double  _arg2 = 0.;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss|d:exportSdif",&_arg0,&_argc1,&_arg2)) 
        return NULL;
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of exportSdif. Expected _PartialList_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    exportSdif(_arg0,_arg1,_arg2);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static PyObject *_wrap_importAiff(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    SampleVector * _result;
    char * _arg0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:importAiff",&_arg0)) 
        return NULL;
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (SampleVector *)importAiff_(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_SampleVector_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_infoAiff(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    unsigned long  _result;
    char * _arg0;
    double * _arg1;
    double  temp;
    int * _arg2;
    int  temp0;

    self = self;
{
  _arg1 = &temp;
}
{
  _arg2 = &temp0;
}
    if(!PyArg_ParseTuple(args,"s:infoAiff",&_arg0)) 
        return NULL;
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (unsigned long )infoAiff(_arg0,_arg1,_arg2);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("l",_result);
{
    PyObject *o;
    o = PyFloat_FromDouble((double) (*_arg1));
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
{
    PyObject *o;
    o = PyInt_FromLong((long) (*_arg2));
    if (!_resultobj) {
      _resultobj = o;
    } else if (_resultobj == Py_None) {
      Py_DECREF(Py_None);
      _resultobj = o;
    } else {
      if (!PyList_Check(_resultobj)) {
	PyObject *o2 = _resultobj;
	_resultobj = PyList_New(0);
	PyList_Append(_resultobj,o2);
	Py_XDECREF(o2);
      }
      PyList_Append(_resultobj,o);
      Py_XDECREF(o);
    }
}
    return _resultobj;
}

static PyObject *_wrap_importSdif(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PartialList * _result;
    char * _arg0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:importSdif",&_arg0)) 
        return NULL;
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (PartialList *)importSdif_(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_PartialList_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_morph(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PartialList * _result;
    PartialList * _arg0;
    PartialList * _arg1;
    BreakpointEnvelope * _arg2;
    BreakpointEnvelope * _arg3;
    BreakpointEnvelope * _arg4;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;
    char * _argc3 = 0;
    char * _argc4 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"sssss:morph",&_argc0,&_argc1,&_argc2,&_argc3,&_argc4)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of morph. Expected _PartialList_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of morph. Expected _PartialList_p.");
        return NULL;
        }
    }
    if (_argc2) {
        if (SWIG_GetPtr(_argc2,(void **) &_arg2,"_BreakpointEnvelope_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 3 of morph. Expected _BreakpointEnvelope_p.");
        return NULL;
        }
    }
    if (_argc3) {
        if (SWIG_GetPtr(_argc3,(void **) &_arg3,"_BreakpointEnvelope_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 4 of morph. Expected _BreakpointEnvelope_p.");
        return NULL;
        }
    }
    if (_argc4) {
        if (SWIG_GetPtr(_argc4,(void **) &_arg4,"_BreakpointEnvelope_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 5 of morph. Expected _BreakpointEnvelope_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (PartialList *)morph_(_arg0,_arg1,_arg2,_arg3,_arg4);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_PartialList_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_synthesize(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    SampleVector * _result;
    PartialList * _arg0;
    double  _arg1;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"sd:synthesize",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of synthesize. Expected _PartialList_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (SampleVector *)synthesize_(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_SampleVector_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_copyByLabel(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PartialList * _arg0;
    long  _arg1;
    PartialList * _arg2;
    char * _argc0 = 0;
    char * _argc2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sls:copyByLabel",&_argc0,&_arg1,&_argc2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of copyByLabel. Expected _PartialList_p.");
        return NULL;
        }
    }
    if (_argc2) {
        if (SWIG_GetPtr(_argc2,(void **) &_arg2,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 3 of copyByLabel. Expected _PartialList_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    copyByLabel(_arg0,_arg1,_arg2);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static PyObject *_wrap_createFreqReference(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BreakpointEnvelope * _result;
    PartialList * _arg0;
    int  _arg1;
    double  _arg2;
    double  _arg3;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"sidd:createFreqReference",&_argc0,&_arg1,&_arg2,&_arg3)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of createFreqReference. Expected _PartialList_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (BreakpointEnvelope *)createFreqReference(_arg0,_arg1,_arg2,_arg3);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_BreakpointEnvelope_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_scaleAmp(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PartialList * _arg0;
    BreakpointEnvelope * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:scaleAmp",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of scaleAmp. Expected _PartialList_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_BreakpointEnvelope_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of scaleAmp. Expected _BreakpointEnvelope_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    scaleAmp(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static PyObject *_wrap_scaleNoiseRatio(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PartialList * _arg0;
    BreakpointEnvelope * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:scaleNoiseRatio",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of scaleNoiseRatio. Expected _PartialList_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_BreakpointEnvelope_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of scaleNoiseRatio. Expected _BreakpointEnvelope_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    scaleNoiseRatio(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static PyObject *_wrap_shiftPitch(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PartialList * _arg0;
    BreakpointEnvelope * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:shiftPitch",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of shiftPitch. Expected _PartialList_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_BreakpointEnvelope_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of shiftPitch. Expected _BreakpointEnvelope_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    shiftPitch(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static Analyzer *new_Analyzer(double resolutionHz) {
		return createAnalyzer( resolutionHz );
	}

static PyObject *_wrap_new_Analyzer(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Analyzer * _result;
    double  _arg0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"d:new_Analyzer",&_arg0)) 
        return NULL;
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (Analyzer *)new_Analyzer(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_Analyzer_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static void delete_Analyzer(Analyzer *self) {
		destroyAnalyzer( self );
	}
static PyObject *_wrap_delete_Analyzer(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Analyzer * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_Analyzer",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_Analyzer. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    delete_Analyzer(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static PartialList * Analyzer_analyze(Analyzer *self,const SampleVector * vec,double  srate) {
		PartialList * partials = new PartialList();
		//self->analyze( vec->begin(), vec->end(), srate );
		//partials->splice( partials->end(), self->partials() );
		analyzer_analyze( self, vec, srate, partials );
		return partials;
	}
static PyObject *_wrap_Analyzer_analyze(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PartialList * _result;
    Analyzer * _arg0;
    SampleVector * _arg1;
    double  _arg2;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"ssd:Analyzer_analyze",&_argc0,&_argc1,&_arg2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_analyze. Expected _Analyzer_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_SampleVector_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of Analyzer_analyze. Expected _SampleVector_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (PartialList *)Analyzer_analyze(_arg0,_arg1,_arg2);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_PartialList_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static void  Analyzer_configure(Analyzer *obj,double _arg0) {
    obj->configure(_arg0);
}
static PyObject *_wrap_Analyzer_configure(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Analyzer * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:Analyzer_configure",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_configure. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    Analyzer_configure(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static double  Analyzer_freqResolution(Analyzer *obj) {
    double  _result = (double )obj->freqResolution();
    return _result;
}
static PyObject *_wrap_Analyzer_freqResolution(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Analyzer * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Analyzer_freqResolution",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_freqResolution. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )Analyzer_freqResolution(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  Analyzer_ampFloor(Analyzer *obj) {
    double  _result = (double )obj->ampFloor();
    return _result;
}
static PyObject *_wrap_Analyzer_ampFloor(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Analyzer * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Analyzer_ampFloor",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_ampFloor. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )Analyzer_ampFloor(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  Analyzer_windowWidth(Analyzer *obj) {
    double  _result = (double )obj->windowWidth();
    return _result;
}
static PyObject *_wrap_Analyzer_windowWidth(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Analyzer * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Analyzer_windowWidth",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_windowWidth. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )Analyzer_windowWidth(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  Analyzer_freqFloor(Analyzer *obj) {
    double  _result = (double )obj->freqFloor();
    return _result;
}
static PyObject *_wrap_Analyzer_freqFloor(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Analyzer * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Analyzer_freqFloor",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_freqFloor. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )Analyzer_freqFloor(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  Analyzer_hopTime(Analyzer *obj) {
    double  _result = (double )obj->hopTime();
    return _result;
}
static PyObject *_wrap_Analyzer_hopTime(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Analyzer * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Analyzer_hopTime",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_hopTime. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )Analyzer_hopTime(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  Analyzer_freqDrift(Analyzer *obj) {
    double  _result = (double )obj->freqDrift();
    return _result;
}
static PyObject *_wrap_Analyzer_freqDrift(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Analyzer * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Analyzer_freqDrift",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_freqDrift. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )Analyzer_freqDrift(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  Analyzer_cropTime(Analyzer *obj) {
    double  _result = (double )obj->cropTime();
    return _result;
}
static PyObject *_wrap_Analyzer_cropTime(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Analyzer * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Analyzer_cropTime",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_cropTime. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )Analyzer_cropTime(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  Analyzer_bwRegionWidth(Analyzer *obj) {
    double  _result = (double )obj->bwRegionWidth();
    return _result;
}
static PyObject *_wrap_Analyzer_bwRegionWidth(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Analyzer * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Analyzer_bwRegionWidth",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_bwRegionWidth. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )Analyzer_bwRegionWidth(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static void  Analyzer_setFreqResolution(Analyzer *obj,double _arg0) {
    obj->setFreqResolution(_arg0);
}
static PyObject *_wrap_Analyzer_setFreqResolution(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Analyzer * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:Analyzer_setFreqResolution",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_setFreqResolution. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    Analyzer_setFreqResolution(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  Analyzer_setAmpFloor(Analyzer *obj,double _arg0) {
    obj->setAmpFloor(_arg0);
}
static PyObject *_wrap_Analyzer_setAmpFloor(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Analyzer * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:Analyzer_setAmpFloor",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_setAmpFloor. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    Analyzer_setAmpFloor(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  Analyzer_setWindowWidth(Analyzer *obj,double _arg0) {
    obj->setWindowWidth(_arg0);
}
static PyObject *_wrap_Analyzer_setWindowWidth(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Analyzer * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:Analyzer_setWindowWidth",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_setWindowWidth. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    Analyzer_setWindowWidth(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  Analyzer_setFreqFloor(Analyzer *obj,double _arg0) {
    obj->setFreqFloor(_arg0);
}
static PyObject *_wrap_Analyzer_setFreqFloor(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Analyzer * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:Analyzer_setFreqFloor",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_setFreqFloor. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    Analyzer_setFreqFloor(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  Analyzer_setFreqDrift(Analyzer *obj,double _arg0) {
    obj->setFreqDrift(_arg0);
}
static PyObject *_wrap_Analyzer_setFreqDrift(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Analyzer * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:Analyzer_setFreqDrift",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_setFreqDrift. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    Analyzer_setFreqDrift(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  Analyzer_setHopTime(Analyzer *obj,double _arg0) {
    obj->setHopTime(_arg0);
}
static PyObject *_wrap_Analyzer_setHopTime(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Analyzer * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:Analyzer_setHopTime",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_setHopTime. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    Analyzer_setHopTime(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  Analyzer_setCropTime(Analyzer *obj,double _arg0) {
    obj->setCropTime(_arg0);
}
static PyObject *_wrap_Analyzer_setCropTime(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Analyzer * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:Analyzer_setCropTime",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_setCropTime. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    Analyzer_setCropTime(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  Analyzer_setBwRegionWidth(Analyzer *obj,double _arg0) {
    obj->setBwRegionWidth(_arg0);
}
static PyObject *_wrap_Analyzer_setBwRegionWidth(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Analyzer * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:Analyzer_setBwRegionWidth",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Analyzer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Analyzer_setBwRegionWidth. Expected _Analyzer_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    Analyzer_setBwRegionWidth(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static BreakpointEnvelope *new_BreakpointEnvelope() {
    return new BreakpointEnvelope();
}
static PyObject *_wrap_new_BreakpointEnvelope(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BreakpointEnvelope * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":new_BreakpointEnvelope")) 
        return NULL;
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (BreakpointEnvelope *)new_BreakpointEnvelope();

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_BreakpointEnvelope_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static void delete_BreakpointEnvelope(BreakpointEnvelope *obj) {
    delete obj;
}
static PyObject *_wrap_delete_BreakpointEnvelope(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BreakpointEnvelope * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_BreakpointEnvelope",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BreakpointEnvelope_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_BreakpointEnvelope. Expected _BreakpointEnvelope_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    delete_BreakpointEnvelope(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static double  BreakpointEnvelope_valueAt(BreakpointEnvelope *obj,double _arg0) {
    double  _result = (double )obj->valueAt(_arg0);
    return _result;
}
static PyObject *_wrap_BreakpointEnvelope_valueAt(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BreakpointEnvelope * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:BreakpointEnvelope_valueAt",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BreakpointEnvelope_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BreakpointEnvelope_valueAt. Expected _BreakpointEnvelope_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )BreakpointEnvelope_valueAt(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static void  BreakpointEnvelope_insertBreakpoint(BreakpointEnvelope *obj,double _arg0,double _arg1) {
    obj->insertBreakpoint(_arg0,_arg1);
}
static PyObject *_wrap_BreakpointEnvelope_insertBreakpoint(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BreakpointEnvelope * _arg0;
    double  _arg1;
    double  _arg2;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sdd:BreakpointEnvelope_insertBreakpoint",&_argc0,&_arg1,&_arg2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BreakpointEnvelope_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BreakpointEnvelope_insertBreakpoint. Expected _BreakpointEnvelope_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    BreakpointEnvelope_insertBreakpoint(_arg0,_arg1,_arg2);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static ExportSpc *new_ExportSpc(double midiPitch) {
		return createExportSpc( midiPitch );
	}

static PyObject *_wrap_new_ExportSpc(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ExportSpc * _result;
    double  _arg0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"d:new_ExportSpc",&_arg0)) 
        return NULL;
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (ExportSpc *)new_ExportSpc(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_ExportSpc_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static void delete_ExportSpc(ExportSpc *self) {
		destroyExportSpc( self );
	}
static PyObject *_wrap_delete_ExportSpc(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ExportSpc * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_ExportSpc",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_ExportSpc. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    delete_ExportSpc(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  ExportSpc_write(ExportSpc *obj,const char *_arg0,const PartialList *_arg1) {
    obj->write(_arg0,*_arg1);
}
static PyObject *_wrap_ExportSpc_write(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ExportSpc * _arg0;
    char * _arg1;
    PartialList * _arg2;
    char * _argc0 = 0;
    char * _argc2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sss:ExportSpc_write",&_argc0,&_arg1,&_argc2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_write. Expected _ExportSpc_p.");
        return NULL;
        }
    }
    if (_argc2) {
        if (SWIG_GetPtr(_argc2,(void **) &_arg2,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 3 of ExportSpc_write. Expected _PartialList_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    ExportSpc_write(_arg0,_arg1,_arg2);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  ExportSpc_configure(ExportSpc *obj,double _arg0) {
    obj->configure(_arg0);
}
static PyObject *_wrap_ExportSpc_configure(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ExportSpc * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:ExportSpc_configure",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_configure. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    ExportSpc_configure(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static double  ExportSpc_midiPitch(ExportSpc *obj) {
    double  _result = (double )obj->midiPitch();
    return _result;
}
static PyObject *_wrap_ExportSpc_midiPitch(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    ExportSpc * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:ExportSpc_midiPitch",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_midiPitch. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )ExportSpc_midiPitch(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static int  ExportSpc_numPartials(ExportSpc *obj) {
    int  _result = (int )obj->numPartials();
    return _result;
}
static PyObject *_wrap_ExportSpc_numPartials(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    ExportSpc * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:ExportSpc_numPartials",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_numPartials. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (int )ExportSpc_numPartials(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static int  ExportSpc_refLabel(ExportSpc *obj) {
    int  _result = (int )obj->refLabel();
    return _result;
}
static PyObject *_wrap_ExportSpc_refLabel(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    ExportSpc * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:ExportSpc_refLabel",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_refLabel. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (int )ExportSpc_refLabel(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static int  ExportSpc_enhanced(ExportSpc *obj) {
    int  _result = (int )obj->enhanced();
    return _result;
}
static PyObject *_wrap_ExportSpc_enhanced(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    ExportSpc * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:ExportSpc_enhanced",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_enhanced. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (int )ExportSpc_enhanced(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static double  ExportSpc_hop(ExportSpc *obj) {
    double  _result = (double )obj->hop();
    return _result;
}
static PyObject *_wrap_ExportSpc_hop(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    ExportSpc * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:ExportSpc_hop",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_hop. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )ExportSpc_hop(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  ExportSpc_attackThreshold(ExportSpc *obj) {
    double  _result = (double )obj->attackThreshold();
    return _result;
}
static PyObject *_wrap_ExportSpc_attackThreshold(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    ExportSpc * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:ExportSpc_attackThreshold",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_attackThreshold. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )ExportSpc_attackThreshold(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  ExportSpc_startFreqTime(ExportSpc *obj) {
    double  _result = (double )obj->startFreqTime();
    return _result;
}
static PyObject *_wrap_ExportSpc_startFreqTime(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    ExportSpc * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:ExportSpc_startFreqTime",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_startFreqTime. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )ExportSpc_startFreqTime(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  ExportSpc_endTime(ExportSpc *obj) {
    double  _result = (double )obj->endTime();
    return _result;
}
static PyObject *_wrap_ExportSpc_endTime(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    ExportSpc * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:ExportSpc_endTime",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_endTime. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )ExportSpc_endTime(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  ExportSpc_endApproachTime(ExportSpc *obj) {
    double  _result = (double )obj->endApproachTime();
    return _result;
}
static PyObject *_wrap_ExportSpc_endApproachTime(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    ExportSpc * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:ExportSpc_endApproachTime",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_endApproachTime. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )ExportSpc_endApproachTime(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  ExportSpc_markerTime(ExportSpc *obj) {
    double  _result = (double )obj->markerTime();
    return _result;
}
static PyObject *_wrap_ExportSpc_markerTime(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    ExportSpc * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:ExportSpc_markerTime",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_markerTime. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )ExportSpc_markerTime(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static void  ExportSpc_setMidiPitch(ExportSpc *obj,double _arg0) {
    obj->setMidiPitch(_arg0);
}
static PyObject *_wrap_ExportSpc_setMidiPitch(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ExportSpc * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:ExportSpc_setMidiPitch",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_setMidiPitch. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    ExportSpc_setMidiPitch(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  ExportSpc_setNumPartials(ExportSpc *obj,int _arg0) {
    obj->setNumPartials(_arg0);
}
static PyObject *_wrap_ExportSpc_setNumPartials(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ExportSpc * _arg0;
    int  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"si:ExportSpc_setNumPartials",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_setNumPartials. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    ExportSpc_setNumPartials(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  ExportSpc_setRefLabel(ExportSpc *obj,int _arg0) {
    obj->setRefLabel(_arg0);
}
static PyObject *_wrap_ExportSpc_setRefLabel(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ExportSpc * _arg0;
    int  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"si:ExportSpc_setRefLabel",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_setRefLabel. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    ExportSpc_setRefLabel(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  ExportSpc_setEnhanced(ExportSpc *obj,int _arg0) {
    obj->setEnhanced(_arg0);
}
static PyObject *_wrap_ExportSpc_setEnhanced(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ExportSpc * _arg0;
    int  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"si:ExportSpc_setEnhanced",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_setEnhanced. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    ExportSpc_setEnhanced(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  ExportSpc_setHop(ExportSpc *obj,double _arg0) {
    obj->setHop(_arg0);
}
static PyObject *_wrap_ExportSpc_setHop(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ExportSpc * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:ExportSpc_setHop",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_setHop. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    ExportSpc_setHop(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  ExportSpc_setAttackThreshold(ExportSpc *obj,double _arg0) {
    obj->setAttackThreshold(_arg0);
}
static PyObject *_wrap_ExportSpc_setAttackThreshold(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ExportSpc * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:ExportSpc_setAttackThreshold",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_setAttackThreshold. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    ExportSpc_setAttackThreshold(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  ExportSpc_setStartFreqTime(ExportSpc *obj,double _arg0) {
    obj->setStartFreqTime(_arg0);
}
static PyObject *_wrap_ExportSpc_setStartFreqTime(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ExportSpc * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:ExportSpc_setStartFreqTime",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_setStartFreqTime. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    ExportSpc_setStartFreqTime(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  ExportSpc_setEndTime(ExportSpc *obj,double _arg0) {
    obj->setEndTime(_arg0);
}
static PyObject *_wrap_ExportSpc_setEndTime(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ExportSpc * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:ExportSpc_setEndTime",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_setEndTime. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    ExportSpc_setEndTime(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  ExportSpc_setEndApproachTime(ExportSpc *obj,double _arg0) {
    obj->setEndApproachTime(_arg0);
}
static PyObject *_wrap_ExportSpc_setEndApproachTime(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ExportSpc * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:ExportSpc_setEndApproachTime",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_setEndApproachTime. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    ExportSpc_setEndApproachTime(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  ExportSpc_setMarkerTime(ExportSpc *obj,double _arg0) {
    obj->setMarkerTime(_arg0);
}
static PyObject *_wrap_ExportSpc_setMarkerTime(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ExportSpc * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:ExportSpc_setMarkerTime",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ExportSpc_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ExportSpc_setMarkerTime. Expected _ExportSpc_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    ExportSpc_setMarkerTime(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static PartialList *new_PartialList() {
    return new PartialList();
}
static PyObject *_wrap_new_PartialList(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PartialList * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":new_PartialList")) 
        return NULL;
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (PartialList *)new_PartialList();

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_PartialList_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static void delete_PartialList(PartialList *obj) {
    delete obj;
}
static PyObject *_wrap_delete_PartialList(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PartialList * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_PartialList",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_PartialList. Expected _PartialList_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    delete_PartialList(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  PartialList_clear(PartialList *obj) {
    obj->clear();
}
static PyObject *_wrap_PartialList_clear(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PartialList * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:PartialList_clear",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of PartialList_clear. Expected _PartialList_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    PartialList_clear(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static unsigned long  PartialList_size(PartialList *obj) {
    unsigned long  _result = (unsigned long )obj->size();
    return _result;
}
static PyObject *_wrap_PartialList_size(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    unsigned long  _result;
    PartialList * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:PartialList_size",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of PartialList_size. Expected _PartialList_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (unsigned long )PartialList_size(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("l",_result);
    return _resultobj;
}

static void  PartialList_splice(PartialList *self,PartialList & other) {
		if ( self == &other )
		{
			std::string s( "Cannot splice a PartialList onto itself!" );
			throw s;
		}
		self->splice( self->end(), other );
	}
static PyObject *_wrap_PartialList_splice(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PartialList * _arg0;
    PartialList * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:PartialList_splice",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of PartialList_splice. Expected _PartialList_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_PartialList_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of PartialList_splice. Expected _PartialList_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    PartialList_splice(_arg0,*_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static SampleVector *new_SampleVector(unsigned long _arg0) {
    return new SampleVector(_arg0);
}
static PyObject *_wrap_new_SampleVector(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    SampleVector * _result;
    unsigned long  _arg0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"|l:new_SampleVector",&_arg0)) 
        return NULL;
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (SampleVector *)new_SampleVector(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_SampleVector_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static void delete_SampleVector(SampleVector *obj) {
    delete obj;
}
static PyObject *_wrap_delete_SampleVector(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    SampleVector * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_SampleVector",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_SampleVector_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_SampleVector. Expected _SampleVector_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    delete_SampleVector(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static unsigned long  SampleVector_size(SampleVector *obj) {
    unsigned long  _result = (unsigned long )obj->size();
    return _result;
}
static PyObject *_wrap_SampleVector_size(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    unsigned long  _result;
    SampleVector * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:SampleVector_size",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_SampleVector_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of SampleVector_size. Expected _SampleVector_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (unsigned long )SampleVector_size(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("l",_result);
    return _resultobj;
}

static void  SampleVector_resize(SampleVector *obj,unsigned long _arg0) {
    obj->resize(_arg0);
}
static PyObject *_wrap_SampleVector_resize(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    SampleVector * _arg0;
    unsigned long  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sl:SampleVector_resize",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_SampleVector_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of SampleVector_resize. Expected _SampleVector_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    SampleVector_resize(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  SampleVector_clear(SampleVector *obj) {
    obj->clear();
}
static PyObject *_wrap_SampleVector_clear(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    SampleVector * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:SampleVector_clear",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_SampleVector_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of SampleVector_clear. Expected _SampleVector_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    SampleVector_clear(_arg0);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static double  SampleVector_getAt(SampleVector *self,unsigned long  idx) {
		// return self->at(idx);	//	g++ doesn't implement at()?
		if ( idx >= self->size() )
			throw std::out_of_range("vector::at index out of range");
		return (*self)[idx];
	}
static PyObject *_wrap_SampleVector_getAt(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    SampleVector * _arg0;
    unsigned long  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sl:SampleVector_getAt",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_SampleVector_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of SampleVector_getAt. Expected _SampleVector_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    _result = (double )SampleVector_getAt(_arg0,_arg1);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static void  SampleVector_setAt(SampleVector *self,unsigned long  idx,double  x) {
		// self->at(idx) = x;	//	g++ doesn't implement at()?
		if ( idx >= self->size() )
			throw std::out_of_range("vector::at index out of range");
		(*self)[idx] = x;
	}
static PyObject *_wrap_SampleVector_setAt(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    SampleVector * _arg0;
    unsigned long  _arg1;
    double  _arg2;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sld:SampleVector_setAt",&_argc0,&_arg1,&_arg2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_SampleVector_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of SampleVector_setAt. Expected _SampleVector_p.");
        return NULL;
        }
    }
{
	try
	{	
		// LorisErrorString.clear();
		LorisErrorString = "";
		    SampleVector_setAt(_arg0,_arg1,_arg2);

		if ( ! LorisErrorString.empty() )
		{
			//	this is an improperly-braced macro!
			SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
		}
	}
	catch( std::exception & ex ) 
	{
		//	these are very unlikely to come from the interface
		//	code, and cannot escape the procedural interface to
		//	Loris, which catches all exceptions:
		std::string s("std C++ exception in scripting interface: " );
		s.append( ex.what() );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
	catch( std::string & exs )
	{
		//	exceptions generated by functions defined in this
		//	file may throw std:strings:
		std::string s("Exception thrown in scripting interface code: " );
		s.append( exs );
		SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static PyMethodDef loriscMethods[] = {
	 { "SampleVector_setAt", _wrap_SampleVector_setAt, 1 },
	 { "SampleVector_getAt", _wrap_SampleVector_getAt, 1 },
	 { "SampleVector_clear", _wrap_SampleVector_clear, 1 },
	 { "SampleVector_resize", _wrap_SampleVector_resize, 1 },
	 { "SampleVector_size", _wrap_SampleVector_size, 1 },
	 { "delete_SampleVector", _wrap_delete_SampleVector, 1 },
	 { "new_SampleVector", _wrap_new_SampleVector, 1 },
	 { "PartialList_splice", _wrap_PartialList_splice, 1 },
	 { "PartialList_size", _wrap_PartialList_size, 1 },
	 { "PartialList_clear", _wrap_PartialList_clear, 1 },
	 { "delete_PartialList", _wrap_delete_PartialList, 1 },
	 { "new_PartialList", _wrap_new_PartialList, 1 },
	 { "ExportSpc_setMarkerTime", _wrap_ExportSpc_setMarkerTime, 1 },
	 { "ExportSpc_setEndApproachTime", _wrap_ExportSpc_setEndApproachTime, 1 },
	 { "ExportSpc_setEndTime", _wrap_ExportSpc_setEndTime, 1 },
	 { "ExportSpc_setStartFreqTime", _wrap_ExportSpc_setStartFreqTime, 1 },
	 { "ExportSpc_setAttackThreshold", _wrap_ExportSpc_setAttackThreshold, 1 },
	 { "ExportSpc_setHop", _wrap_ExportSpc_setHop, 1 },
	 { "ExportSpc_setEnhanced", _wrap_ExportSpc_setEnhanced, 1 },
	 { "ExportSpc_setRefLabel", _wrap_ExportSpc_setRefLabel, 1 },
	 { "ExportSpc_setNumPartials", _wrap_ExportSpc_setNumPartials, 1 },
	 { "ExportSpc_setMidiPitch", _wrap_ExportSpc_setMidiPitch, 1 },
	 { "ExportSpc_markerTime", _wrap_ExportSpc_markerTime, 1 },
	 { "ExportSpc_endApproachTime", _wrap_ExportSpc_endApproachTime, 1 },
	 { "ExportSpc_endTime", _wrap_ExportSpc_endTime, 1 },
	 { "ExportSpc_startFreqTime", _wrap_ExportSpc_startFreqTime, 1 },
	 { "ExportSpc_attackThreshold", _wrap_ExportSpc_attackThreshold, 1 },
	 { "ExportSpc_hop", _wrap_ExportSpc_hop, 1 },
	 { "ExportSpc_enhanced", _wrap_ExportSpc_enhanced, 1 },
	 { "ExportSpc_refLabel", _wrap_ExportSpc_refLabel, 1 },
	 { "ExportSpc_numPartials", _wrap_ExportSpc_numPartials, 1 },
	 { "ExportSpc_midiPitch", _wrap_ExportSpc_midiPitch, 1 },
	 { "ExportSpc_configure", _wrap_ExportSpc_configure, 1 },
	 { "ExportSpc_write", _wrap_ExportSpc_write, 1 },
	 { "delete_ExportSpc", _wrap_delete_ExportSpc, 1 },
	 { "new_ExportSpc", _wrap_new_ExportSpc, 1 },
	 { "BreakpointEnvelope_insertBreakpoint", _wrap_BreakpointEnvelope_insertBreakpoint, 1 },
	 { "BreakpointEnvelope_valueAt", _wrap_BreakpointEnvelope_valueAt, 1 },
	 { "delete_BreakpointEnvelope", _wrap_delete_BreakpointEnvelope, 1 },
	 { "new_BreakpointEnvelope", _wrap_new_BreakpointEnvelope, 1 },
	 { "Analyzer_setBwRegionWidth", _wrap_Analyzer_setBwRegionWidth, 1 },
	 { "Analyzer_setCropTime", _wrap_Analyzer_setCropTime, 1 },
	 { "Analyzer_setHopTime", _wrap_Analyzer_setHopTime, 1 },
	 { "Analyzer_setFreqDrift", _wrap_Analyzer_setFreqDrift, 1 },
	 { "Analyzer_setFreqFloor", _wrap_Analyzer_setFreqFloor, 1 },
	 { "Analyzer_setWindowWidth", _wrap_Analyzer_setWindowWidth, 1 },
	 { "Analyzer_setAmpFloor", _wrap_Analyzer_setAmpFloor, 1 },
	 { "Analyzer_setFreqResolution", _wrap_Analyzer_setFreqResolution, 1 },
	 { "Analyzer_bwRegionWidth", _wrap_Analyzer_bwRegionWidth, 1 },
	 { "Analyzer_cropTime", _wrap_Analyzer_cropTime, 1 },
	 { "Analyzer_freqDrift", _wrap_Analyzer_freqDrift, 1 },
	 { "Analyzer_hopTime", _wrap_Analyzer_hopTime, 1 },
	 { "Analyzer_freqFloor", _wrap_Analyzer_freqFloor, 1 },
	 { "Analyzer_windowWidth", _wrap_Analyzer_windowWidth, 1 },
	 { "Analyzer_ampFloor", _wrap_Analyzer_ampFloor, 1 },
	 { "Analyzer_freqResolution", _wrap_Analyzer_freqResolution, 1 },
	 { "Analyzer_configure", _wrap_Analyzer_configure, 1 },
	 { "Analyzer_analyze", _wrap_Analyzer_analyze, 1 },
	 { "delete_Analyzer", _wrap_delete_Analyzer, 1 },
	 { "new_Analyzer", _wrap_new_Analyzer, 1 },
	 { "shiftPitch", _wrap_shiftPitch, 1 },
	 { "scaleNoiseRatio", _wrap_scaleNoiseRatio, 1 },
	 { "scaleAmp", _wrap_scaleAmp, 1 },
	 { "createFreqReference", _wrap_createFreqReference, 1 },
	 { "copyByLabel", _wrap_copyByLabel, 1 },
	 { "synthesize", _wrap_synthesize, 1 },
	 { "morph", _wrap_morph, 1 },
	 { "importSdif", _wrap_importSdif, 1 },
	 { "infoAiff", _wrap_infoAiff, 1 },
	 { "importAiff", _wrap_importAiff, 1 },
	 { "exportSdif", _wrap_exportSdif, 1 },
	 { "exportAiff", _wrap_exportAiff, 1 },
	 { "distill", _wrap_distill, 1 },
	 { "dilate", _wrap_dilate, 1 },
	 { "channelize", _wrap_channelize, 1 },
	 { "SampleVectorCopy", _wrap_SampleVectorCopy, 1 },
	 { "PartialListCopy", _wrap_PartialListCopy, 1 },
	 { "BreakpointEnvelopeWithValue", _wrap_BreakpointEnvelopeWithValue, 1 },
	 { "BreakpointEnvelopeCopy", _wrap_BreakpointEnvelopeCopy, 1 },
	 { "AnalyzerCopy", _wrap_AnalyzerCopy, 1 },
	 { NULL, NULL }
};
static PyObject *SWIG_globals;
#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT(void,initlorisc)() {
	 PyObject *m, *d;
	 SWIG_globals = SWIG_newvarlink();
	 m = Py_InitModule("lorisc", loriscMethods);
	 d = PyModule_GetDict(m);
	 _wrap_python_const___version__ = PyString_FromString("Loris 1.0beta2 ");
	 PyDict_SetItemString(d,"__version__", _wrap_python_const___version__);

	setNotifier( printf_notifier );
	setExceptionHandler( throw_string );
/*
 * These are the pointer type-equivalency mappings. 
 * (Used by the SWIG pointer type-checker).
 */
	 SWIG_RegisterMapping("_signed_long","_long",0);
	 SWIG_RegisterMapping("_class_BreakpointEnvelope","_BreakpointEnvelope",0);
	 SWIG_RegisterMapping("_PartialList","_class_PartialList",0);
	 SWIG_RegisterMapping("_long","_unsigned_long",0);
	 SWIG_RegisterMapping("_long","_signed_long",0);
	 SWIG_RegisterMapping("_Analyzer","_class_Analyzer",0);
	 SWIG_RegisterMapping("_SampleVector","_class_SampleVector",0);
	 SWIG_RegisterMapping("_class_SampleVector","_SampleVector",0);
	 SWIG_RegisterMapping("_unsigned_long","_long",0);
	 SWIG_RegisterMapping("_signed_int","_int",0);
	 SWIG_RegisterMapping("_unsigned_short","_short",0);
	 SWIG_RegisterMapping("_ExportSpc","_class_ExportSpc",0);
	 SWIG_RegisterMapping("_signed_short","_short",0);
	 SWIG_RegisterMapping("_unsigned_int","_int",0);
	 SWIG_RegisterMapping("_short","_unsigned_short",0);
	 SWIG_RegisterMapping("_short","_signed_short",0);
	 SWIG_RegisterMapping("_class_PartialList","_PartialList",0);
	 SWIG_RegisterMapping("_int","_unsigned_int",0);
	 SWIG_RegisterMapping("_int","_signed_int",0);
	 SWIG_RegisterMapping("_class_ExportSpc","_ExportSpc",0);
	 SWIG_RegisterMapping("_class_Analyzer","_Analyzer",0);
	 SWIG_RegisterMapping("_BreakpointEnvelope","_class_BreakpointEnvelope",0);
}
