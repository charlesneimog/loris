/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.24
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON

#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};
#endif


#ifndef SWIG_TEMPLATE_DISAMBIGUATOR
#  if defined(__SUNPRO_CC) 
#    define SWIG_TEMPLATE_DISAMBIGUATOR template
#  else
#    define SWIG_TEMPLATE_DISAMBIGUATOR 
#  endif
#endif


#include <Python.h>

/***********************************************************************
 * swigrun.swg
 *
 *     This file contains generic CAPI SWIG runtime support for pointer
 *     type checking.
 *
 ************************************************************************/

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "1"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
#define SWIG_QUOTE_STRING(x) #x
#define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
#define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
#define SWIG_TYPE_TABLE_NAME
#endif

#include <string.h>

#ifndef SWIGINLINE
#if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#  define SWIGINLINE inline
#else
#  define SWIGINLINE
#endif
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the swig runtime code.
  In 99.9% of the cases, swig just needs to declare them as 'static'.
  
  But only do this if is strictly necessary, ie, if you have problems
  with your compiler or so.
*/
#ifndef SWIGRUNTIME
#define SWIGRUNTIME static
#endif
#ifndef SWIGRUNTIMEINLINE
#define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return *f1 - *f2;
  }
  return (l1 - f1) - (l2 - f2);
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te) == 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Register a type mapping with the type-checking
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeRegisterTL(swig_type_info **tl, swig_type_info *ti) {
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = *tl;
  while (tc) {
    /* check simple type equivalence */
    int typeequiv = (strcmp(tc->name, ti->name) == 0);   
    /* check full type equivalence, resolving typedefs */
    if (!typeequiv) {
      /* only if tc is not a typedef (no '|' on it) */
      if (tc->str && ti->str && !strstr(tc->str,"|")) {
	typeequiv = SWIG_TypeEquiv(ti->str,tc->str);
      }
    }
    if (typeequiv) {
      /* Already exists in the table.  Just add additional types to the list */
      if (ti->clientdata) tc->clientdata = ti->clientdata;
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = *tl;
  *tl = ti;

  /* Build linked lists */
  l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;
  head->next = next;

  return ret;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
        s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_type_info *ty, void *ptr) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
  Search for a swig_type_info structure
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryTL(swig_type_info *tl, const char *name) {
  swig_type_info *ty = tl;
  while (ty) {
    if (ty->str && (SWIG_TypeEquiv(ty->str,name))) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientDataTL(swig_type_info *tl, swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata) return;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = tl;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0))
          SWIG_TypeClientDataTL(tl,tc,clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static char hex[17] = "0123456789abcdef";
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  register unsigned char uu;
  for (; u != eu; ++u) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register int d = *(c++);
    register unsigned char uu = 0;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
  This function will propagate the clientdata field of type to any new
  swig_type_info structures that have been added into the list of
  equivalent types.  It is like calling SWIG_TypeClientData(type,
  clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientDataTL(swig_type_info *tl, swig_type_info *type) {
  swig_type_info *equiv = type->next;
  swig_type_info *tc;
  if (!type->clientdata) return;
  while (equiv) {
    if (!equiv->converter) {
      tc = tl;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0) && !tc->clientdata)
          SWIG_TypeClientDataTL(tl,tc, type->clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/


#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  if !defined(STATIC_LINKED)
#    define SWIGEXPORT(a) __declspec(dllexport) a
#  else
#    define SWIGEXPORT(a) a
#  endif
#else
#  define SWIGEXPORT(a) a
#endif

#ifdef __cplusplus
extern "C" {
#endif


/*************************************************************************/


/* The static type info list */

static swig_type_info *swig_type_list = 0;
static swig_type_info **swig_type_list_handle = &swig_type_list;
  

/* Register a type mapping with the type-checking */
static swig_type_info *
SWIG_TypeRegister(swig_type_info *ti) {
  return SWIG_TypeRegisterTL(swig_type_list_handle, ti);
}

/* Search for a swig_type_info structure */
static swig_type_info *
SWIG_TypeQuery(const char *name) {
  return SWIG_TypeQueryTL(*swig_type_list_handle, name);
}

/* Set the clientdata field for a type */
static void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientDataTL(*swig_type_list_handle, ti, clientdata);
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
static void
SWIG_PropagateClientData(swig_type_info *type) {
  SWIG_PropagateClientDataTL(*swig_type_list_handle, type);
}

#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * SWIG API. Portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * for internal method declarations
 * ----------------------------------------------------------------------------- */

#ifndef SWIGINTERN
#define SWIGINTERN static 
#endif

#ifndef SWIGINTERNSHORT
#ifdef __cplusplus
#define SWIGINTERNSHORT static inline 
#else /* C case */
#define SWIGINTERNSHORT static 
#endif /* __cplusplus */
#endif


/*
  Exception handling in wrappers
*/
#define SWIG_fail                goto fail
#define SWIG_arg_fail(arg)       SWIG_Python_ArgFail(arg)
#define SWIG_append_errmsg(msg)   SWIG_Python_AddErrMesg(msg,0)
#define SWIG_preppend_errmsg(msg) SWIG_Python_AddErrMesg(msg,1)
#define SWIG_type_error(type,obj) SWIG_Python_TypeError(type,obj)
#define SWIG_null_ref(type)       SWIG_Python_NullRef(type)

/*
  Contract support
*/
#define SWIG_contract_assert(expr, msg) \
 if (!(expr)) { PyErr_SetString(PyExc_RuntimeError, (char *) msg ); goto fail; } else

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_INT     1
#define SWIG_PY_FLOAT   2
#define SWIG_PY_STRING  3
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;


/* -----------------------------------------------------------------------------
 * Alloc. memory flags
 * ----------------------------------------------------------------------------- */
#define SWIG_OLDOBJ  1
#define SWIG_NEWOBJ  SWIG_OLDOBJ + 1
#define SWIG_PYSTR   SWIG_NEWOBJ + 1

#ifdef __cplusplus
}
#endif


/***********************************************************************
 * pyrun.swg
 *
 *     This file contains the runtime support for Python modules
 *     and includes code for managing global variables and pointer
 *     type checking.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 ************************************************************************/

/* Common SWIG API */
#define SWIG_ConvertPtr(obj, pp, type, flags)    SWIG_Python_ConvertPtr(obj, pp, type, flags)
#define SWIG_NewPointerObj(p, type, flags)       SWIG_Python_NewPointerObj(p, type, flags)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)
 

/* Python-specific SWIG API */
#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags)   SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type)              SWIG_Python_NewPackedObj(ptr, sz, type)


/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */
/*
  Use SWIG_NO_COBJECT_TYPES to force the use of strings to represent
  C/C++ pointers in the python side. Very useful for debugging, but
  not always safe.
*/
#if !defined(SWIG_NO_COBJECT_TYPES) && !defined(SWIG_COBJECT_TYPES)
#  define SWIG_COBJECT_TYPES
#endif

/* Flags for pointer conversion */
#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_DISOWN        0x2


#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Create a new pointer string 
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_BUFFER_SIZE
#define SWIG_BUFFER_SIZE 1024
#endif

#if defined(SWIG_COBJECT_TYPES)
#if !defined(SWIG_COBJECT_PYTHON)
/* -----------------------------------------------------------------------------
 * Implements a simple Swig Object type, and use it instead of PyCObject
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *ptr;
  const char *desc;
} PySwigObject;

/* Declarations for objects of type PySwigObject */

SWIGRUNTIME int
PySwigObject_print(PySwigObject *v, FILE *fp, int flags)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackVoidPtr(result, v->ptr, v->desc, sizeof(result))) {
    fputs("<Swig Object at ", fp); fputs(result, fp); fputs(">", fp);
    return 0; 
  } else {
    return 1; 
  }
}
  
SWIGRUNTIME PyObject *
PySwigObject_repr(PySwigObject *v)
{
  char result[SWIG_BUFFER_SIZE];
  return SWIG_PackVoidPtr(result, v->ptr, v->desc, sizeof(result)) ?
    PyString_FromFormat("<Swig Object at %s>", result) : 0;
}

SWIGRUNTIME PyObject *
PySwigObject_str(PySwigObject *v)
{
  char result[SWIG_BUFFER_SIZE];
  return SWIG_PackVoidPtr(result, v->ptr, v->desc, sizeof(result)) ?
    PyString_FromString(result) : 0;
}

SWIGRUNTIME PyObject *
PySwigObject_long(PySwigObject *v)
{
  return PyLong_FromUnsignedLong((unsigned long) v->ptr);
}

SWIGRUNTIME PyObject *
PySwigObject_oct(PySwigObject *v)
{
  char buf[100];
  unsigned long x = (unsigned long)v->ptr;
  if (x == 0)
    strcpy(buf, "0");
  else
    PyOS_snprintf(buf, sizeof(buf), "0%lo", x);
  return PyString_FromString(buf);
}

SWIGRUNTIME PyObject *
PySwigObject_hex(PySwigObject *v)
{
  char buf[100];
  PyOS_snprintf(buf, sizeof(buf), "0x%lx", (unsigned long)v->ptr);
  return PyString_FromString(buf);
}

SWIGRUNTIME int
PySwigObject_compare(PySwigObject *v, PySwigObject *w)
{
  int c = strcmp(v->desc, w->desc);
  if (c) {
    return c;
  } else {
    void *i = v->ptr;
    void *j = w->ptr;
    return (i < j) ? -1 : (i > j) ? 1 : 0;
  }
}

SWIGRUNTIME void
PySwigObject_dealloc(PySwigObject *self)
{
  PyObject_DEL(self);
}

SWIGRUNTIME PyTypeObject*
PySwigObject_GetType() {
  static char PySwigObject_Type__doc__[] = 
    "Swig object carries a C/C++ instance pointer";
  
  static PyNumberMethods PySwigObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    (binaryfunc)0, /*nb_divide*/
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
    (coercion)0,   /*nb_coerce*/
    (unaryfunc)PySwigObject_long, /*nb_int*/
    (unaryfunc)PySwigObject_long, /*nb_long*/
    (unaryfunc)0,                 /*nb_float*/
    (unaryfunc)PySwigObject_oct,  /*nb_oct*/
    (unaryfunc)PySwigObject_hex,  /*nb_hex*/
#if PY_VERSION_HEX >= 0x02000000
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */ 
#endif
  };

  static int type_init = 0;  
  static PyTypeObject PySwigObject_Type;

  if (!type_init) {
    PyTypeObject tmp = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,					/*ob_size*/
    "PySwigObject",			/*tp_name*/
    sizeof(PySwigObject),		/*tp_basicsize*/
    0,					/*tp_itemsize*/
    /* methods */
    (destructor)PySwigObject_dealloc,	/*tp_dealloc*/
    (printfunc)PySwigObject_print,	/*tp_print*/
    (getattrfunc)0,			/*tp_getattr*/
    (setattrfunc)0,			/*tp_setattr*/
    (cmpfunc)PySwigObject_compare,	/*tp_compare*/
    (reprfunc)PySwigObject_repr,	/*tp_repr*/
    &PySwigObject_as_number,	        /*tp_as_number*/
    0,					/*tp_as_sequence*/
    0,					/*tp_as_mapping*/
    (hashfunc)0,			/*tp_hash*/
    (ternaryfunc)0,			/*tp_call*/
    (reprfunc)PySwigObject_str,		/*tp_str*/
    /* Space for future expansion */
    0L,0L,0L,0L,
    PySwigObject_Type__doc__, 	        /* Documentation string */
#if PY_VERSION_HEX >= 0x02000000
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
#endif
#if PY_VERSION_HEX >= 0x02010000
    0,                                  /* tp_richcompare */
    0,                                  /* tp_weaklistoffset */
#endif
#if PY_VERSION_HEX >= 0x02020000
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
    0,                                  /* tp_del */
#endif
#ifdef COUNT_ALLOCS
    0,0,0,0                             /* tp_alloc -> tp_next */
#endif
    };

    PySwigObject_Type = tmp;
    type_init = 1;
  }

  return &PySwigObject_Type;
}

SWIGRUNTIME PyObject *
PySwigObject_FromVoidPtrAndDesc(void *ptr, const char *desc)
{
  PySwigObject *self = PyObject_NEW(PySwigObject, PySwigObject_GetType());
  if (self == NULL) return NULL;
  self->ptr = ptr;
  self->desc = desc;
  return (PyObject *)self;
}

SWIGRUNTIMEINLINE void *
PySwigObject_AsVoidPtr(PyObject *self)
{
  return ((PySwigObject *)self)->ptr;
}

SWIGRUNTIMEINLINE const char *
PySwigObject_GetDesc(PyObject *self)
{
  return ((PySwigObject *)self)->desc;
}

SWIGRUNTIMEINLINE int
PySwigObject_Check(PyObject *op) {
  return ((op)->ob_type == PySwigObject_GetType()) 
    || (strcmp((op)->ob_type->tp_name,"PySwigObject") == 0);
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  const char *desc;
  size_t size;
} PySwigPacked;

SWIGRUNTIME int
PySwigPacked_print(PySwigPacked *v, FILE *fp, int flags)
{
  char result[SWIG_BUFFER_SIZE];
  fputs("<Swig Packed ", fp); 
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    fputs("at ", fp); 
    fputs(result, fp); 
  }
  fputs(v->desc,fp); 
  fputs(">", fp);
  return 0; 
}
  
SWIGRUNTIME PyObject *
PySwigPacked_repr(PySwigPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return PyString_FromFormat("<Swig Packed at %s%s>", result, v->desc);
  } else {
    return PyString_FromFormat("<Swig Packed %s>", v->desc);
  }  
}

SWIGRUNTIME PyObject *
PySwigPacked_str(PySwigPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return PyString_FromFormat("%s%s", result, v->desc);
  } else {
    return PyString_FromFormat("%s", v->desc);
  }  
}

SWIGRUNTIME int
PySwigPacked_compare(PySwigPacked *v, PySwigPacked *w)
{
  int c = strcmp(v->desc, w->desc);
  if (c) {
    return c;
  } else {
    size_t i = v->size;
    size_t j = w->size;
    int s = (i < j) ? -1 : (i > j) ? 1 : 0;
    return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
  }
}

SWIGRUNTIME void
PySwigPacked_dealloc(PySwigPacked *self)
{
  free(self->pack);
  PyObject_DEL(self);
}

SWIGRUNTIME PyTypeObject*
PySwigPacked_GetType() {
  static char PySwigPacked_Type__doc__[] = 
    "Swig object carries a C/C++ instance pointer";
  static int type_init = 0;
  
  static PyTypeObject PySwigPacked_Type;
  if (!type_init) {
    PyTypeObject tmp = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,					/*ob_size*/
    "PySwigPacked",			/*tp_name*/
    sizeof(PySwigPacked),		/*tp_basicsize*/
    0,					/*tp_itemsize*/
    /* methods */
    (destructor)PySwigPacked_dealloc,	/*tp_dealloc*/
    (printfunc)PySwigPacked_print,	/*tp_print*/
    (getattrfunc)0,			/*tp_getattr*/
    (setattrfunc)0,			/*tp_setattr*/
    (cmpfunc)PySwigPacked_compare,	/*tp_compare*/
    (reprfunc)PySwigPacked_repr,	/*tp_repr*/
    0,	                                /*tp_as_number*/
    0,					/*tp_as_sequence*/
    0,					/*tp_as_mapping*/
    (hashfunc)0,			/*tp_hash*/
    (ternaryfunc)0,			/*tp_call*/
    (reprfunc)PySwigPacked_str,		/*tp_str*/
    /* Space for future expansion */
    0L,0L,0L,0L,
    PySwigPacked_Type__doc__, 	        /* Documentation string */
#if PY_VERSION_HEX >= 0x02000000
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
#endif
#if PY_VERSION_HEX >= 0x02010000
    0,                                  /* tp_richcompare */
    0,                                  /* tp_weaklistoffset */
#endif
#if PY_VERSION_HEX >= 0x02020000         
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
    0,                                  /* tp_del */
#endif
#ifdef COUNT_ALLOCS
    0,0,0,0                             /* tp_alloc -> tp_next */
#endif
    };

    PySwigPacked_Type = tmp;
    type_init = 1;
  }
  
      

  return &PySwigPacked_Type;
}

SWIGRUNTIME PyObject *
PySwigPacked_FromDataAndDesc(void *ptr, size_t size, const char *desc)
{
  PySwigPacked *self = PyObject_NEW(PySwigPacked, PySwigPacked_GetType());
  if (self == NULL) {
    return NULL;
  } else {
    void *pack = malloc(size);
    memcpy(pack, ptr, size);
    self->pack = pack;
    self->desc = desc;
    self->size = size;
    return (PyObject *) self;
  }
}

SWIGRUNTIMEINLINE const char *
PySwigPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  PySwigPacked *self = (PySwigPacked *)obj;
  if (self->size != size) return 0;
  memcpy(ptr, self->pack, size);
  return self->desc;
}

SWIGRUNTIMEINLINE const char *
PySwigPacked_GetDesc(PyObject *self)
{
  return ((PySwigPacked *)self)->desc;
}

SWIGRUNTIMEINLINE int
PySwigPacked_Check(PyObject *op) {
  return ((op)->ob_type == PySwigPacked_GetType()) 
    || (strcmp((op)->ob_type->tp_name,"PySwigPacked") == 0);
}

#else
/* -----------------------------------------------------------------------------
 * Use the old Python PyCObject instead of PySwigObject
 * ----------------------------------------------------------------------------- */

#define PySwigObject_GetDesc(obj)	           PyCObject_GetDesc(obj)
#define PySwigObject_Check(obj)	           PyCObject_Check(obj)
#define PySwigObject_AsVoidPtr(obj)	   PyCObject_AsVoidPtr(obj)
#define PySwigObject_FromVoidPtrAndDesc(p, d)  PyCObject_FromVoidPtrAndDesc(p, d, NULL)

#endif

#endif

/* -----------------------------------------------------------------------------
 * errors manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (PySwigObject_Check(obj)) {
      const char *otype = (const char *) PySwigObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'PySwigObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? PyString_AsString(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_DECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}

SWIGRUNTIMEINLINE void
SWIG_Python_NullRef(const char *type)
{
  if (type) {
    PyErr_Format(PyExc_TypeError, "null reference of type '%s' was received",type);
  } else {
    PyErr_Format(PyExc_TypeError, "null reference was received");
  }
}

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      PyObject *old_str = PyObject_Str(value);
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, PyString_AsString(old_str));
      } else {
	PyErr_Format(type, "%s %s", PyString_AsString(old_str), mesg);
      }
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}

SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    sprintf(mesg, "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}


/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

/* Convert a pointer value */
SWIGRUNTIME int
SWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  const char *c = 0;
  static PyObject *SWIG_this = 0;
  int    newref = 0;
  PyObject  *pyobj = 0;
  void *vptr;
  
  if (!obj) return 0;
  if (obj == Py_None) {
    *ptr = 0;
    return 0;
  }

#ifdef SWIG_COBJECT_TYPES
  if (!(PySwigObject_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PySwigObject_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  }  
  vptr = PySwigObject_AsVoidPtr(obj);
  c = (const char *) PySwigObject_GetDesc(obj);
  if (newref) { Py_DECREF(obj); }
  goto type_check;
#else
  if (!(PyString_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyString_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  c = PyString_AS_STRING(obj);
  /* Pointer values must start with leading underscore */
  c = SWIG_UnpackVoidPtr(c, &vptr, ty->name);
  if (newref) { Py_DECREF(obj); }
  if (!c) goto type_error;
#endif

type_check:

  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
    *ptr = SWIG_TypeCast(tc,vptr);
  } else {
    *ptr = vptr;
  }

  if ((pyobj) && (flags & SWIG_POINTER_DISOWN)) {
    PyObject_SetAttrString(pyobj,(char*)"thisown",Py_False);
  }
  return 0;

type_error:
  PyErr_Clear();
  if (pyobj && !obj) {    
    obj = pyobj;
    if (PyCFunction_Check(obj)) {
      /* here we get the method pointer for callbacks */
      char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
      c = doc ? strstr(doc, "swig_ptr: ") : 0;
      if (c) {
	c = SWIG_UnpackVoidPtr(c + 10, &vptr, ty->name);
	if (!c) goto type_error;
	goto type_check;
      }
    }
  }
  if (flags & SWIG_POINTER_EXCEPTION) {
    if (ty) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
    } else {
      SWIG_Python_TypeError("C/C++ pointer", obj);
    }
  }
  return -1;
}

/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
    if (flags & SWIG_POINTER_EXCEPTION) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
  }
  return result;
}

/* Convert a packed value value */
SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  const char *c = 0;

#if defined(SWIG_COBJECT_TYPES) && !defined(SWIG_COBJECT_PYTHON)
  c = PySwigPacked_UnpackData(obj, ptr, sz);
#else
  if ((!obj) || (!PyString_Check(obj))) goto type_error;
  c = PyString_AS_STRING(obj);
  /* Pointer values must start with leading underscore */
  c = SWIG_UnpackDataName(c, ptr, sz, ty->name);
#endif
  if (!c) goto type_error;
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return 0;

type_error:
  PyErr_Clear();
  if (flags & SWIG_POINTER_EXCEPTION) {
    if (ty) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
    } else {
      SWIG_Python_TypeError("C/C++ packed data", obj);
    }
  }
  return -1;
}  

/* Create a new array object */
SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {
  PyObject *robj = 0;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#ifdef SWIG_COBJECT_TYPES
  robj = PySwigObject_FromVoidPtrAndDesc((void *) ptr, (char *)type->name);
#else
  {
    char result[SWIG_BUFFER_SIZE];
    robj = SWIG_PackVoidPtr(result, ptr, type->name, sizeof(result)) ?
      PyString_FromString(result) : 0;
  }
#endif
  if (!robj || (robj == Py_None)) return robj;
  if (type->clientdata) {
    PyObject *inst;
    PyObject *args = Py_BuildValue((char*)"(O)", robj);
    Py_DECREF(robj);
    inst = PyObject_CallObject((PyObject *) type->clientdata, args);
    Py_DECREF(args);
    if (inst) {
      if (own) {
        PyObject_SetAttrString(inst,(char*)"thisown",Py_True);
      }
      robj = inst;
    }
  }
  return robj;
}

SWIGRUNTIME PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  PyObject *robj = 0;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#if defined(SWIG_COBJECT_TYPES) && !defined(SWIG_COBJECT_PYTHON)
  robj = PySwigPacked_FromDataAndDesc((void *) ptr, sz, (char *)type->name);
#else
  {
    char result[SWIG_BUFFER_SIZE];
    robj = SWIG_PackDataName(result, ptr, sz, type->name, sizeof(result)) ?
      PyString_FromString(result) : 0;
  }
#endif
  return robj;
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

SWIGRUNTIME swig_type_info **
SWIG_Python_GetTypeListHandle() {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
#ifdef SWIG_LINK_RUNTIME
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
#else
    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }
  }
#endif
  return (swig_type_info **) type_pointer;
}

/*
  Search for a swig_type_info structure
 */
SWIGRUNTIMEINLINE swig_type_info *
SWIG_Python_GetTypeList() {
  swig_type_info **tlh = SWIG_Python_GetTypeListHandle();
  return tlh ? *tlh : (swig_type_info*)0;
}

#define SWIG_Runtime_GetTypeList SWIG_Python_GetTypeList 

#ifdef __cplusplus
}
#endif


/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_PartialList swig_types[0] 
#define  SWIGTYPE_std__size_t swig_types[1] 
#define  SWIGTYPE_size_t swig_types[2] 
#define  SWIGTYPE_p_SpcFile swig_types[3] 
#define  SWIGTYPE_p_Breakpoint swig_types[4] 
#define  SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t swig_types[5] 
#define  SWIGTYPE_p_Analyzer swig_types[6] 
#define  SWIGTYPE_p_allocator_type swig_types[7] 
#define  SWIGTYPE_p_double swig_types[8] 
#define  SWIGTYPE_p_Loris__Partial swig_types[9] 
#define  SWIGTYPE_p_Partial swig_types[10] 
#define  SWIGTYPE_p_std__allocatorTdouble_t swig_types[11] 
#define  SWIGTYPE_p_size_type swig_types[12] 
#define  SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t swig_types[13] 
#define  SWIGTYPE_p_char swig_types[14] 
#define  SWIGTYPE_p_BreakpointEnvelope swig_types[15] 
#define  SWIGTYPE_p_BreakpointPosition swig_types[16] 
#define  SWIGTYPE_p_value_type swig_types[17] 
#define  SWIGTYPE_p_difference_type swig_types[18] 
#define  SWIGTYPE_std__ptrdiff_t swig_types[19] 
#define  SWIGTYPE_ptrdiff_t swig_types[20] 
#define  SWIGTYPE_p_AiffFile swig_types[21] 
#define  SWIGTYPE_p_std__allocatorTMarker_t swig_types[22] 
#define  SWIGTYPE_p_SdifFile swig_types[23] 
#define  SWIGTYPE_p_Marker swig_types[24] 
#define  SWIGTYPE_p_NewPlistIterator swig_types[25] 
#define  SWIGTYPE_p_NewPartialIterator swig_types[26] 
#define  SWIGTYPE_p_PartialListIterator swig_types[27] 
#define  SWIGTYPE_p_PartialIterator swig_types[28] 
static swig_type_info *swig_types[30];

/* -------- TYPES TABLE (END) -------- */


/*-----------------------------------------------
              @(target):= _loris.so
  ------------------------------------------------*/
#define SWIG_init    init_loris

#define SWIG_name    "_loris"

#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


static void SWIG_exception_(int code, const char *msg) {
  switch(code) {
  case SWIG_MemoryError:
    PyErr_SetString(PyExc_MemoryError,msg);
    break;
  case SWIG_IOError:
    PyErr_SetString(PyExc_IOError,msg);
    break;
  case SWIG_RuntimeError:
    PyErr_SetString(PyExc_RuntimeError,msg);
    break;
  case SWIG_IndexError:
    PyErr_SetString(PyExc_IndexError,msg);
    break;
  case SWIG_TypeError:
    PyErr_SetString(PyExc_TypeError,msg);
    break;
  case SWIG_DivisionByZero:
    PyErr_SetString(PyExc_ZeroDivisionError,msg);
    break;
  case SWIG_OverflowError:
    PyErr_SetString(PyExc_OverflowError,msg);
    break;
  case SWIG_SyntaxError:
    PyErr_SetString(PyExc_SyntaxError,msg);
    break;
  case SWIG_ValueError:
    PyErr_SetString(PyExc_ValueError,msg);
    break;
  case SWIG_SystemError:
    PyErr_SetString(PyExc_SystemError,msg);
    break;
  default:
    PyErr_SetString(PyExc_RuntimeError,msg);
    break;
  }
}

#define SWIG_exception(a,b) { SWIG_exception_(a,b); SWIG_fail; }


#include <stdexcept>


#include <iostream>  


#if PY_VERSION_HEX < 0x02000000
#define PySequence_Size PySequence_Length
#endif
#include <stdexcept>


  
#if defined(__SUNPRO_CC) 
#define SWIG_STD_NOASSIGN_STL
#define SWIG_STD_NOINSERT_TEMPLATE_STL
#endif



#include <string>
#include <stdexcept>


#include <algorithm>


#include <vector>


#include <list>


	#include<loris.h>
	
	#include <AiffFile.h>
	#include <BreakpointEnvelope.h>
	#include <Exception.h>
	#include <Marker.h>
	#include <Partial.h>
	#include <Synthesizer.h>

	//	import the entire Loris namespace, because
	//	SWIG does not seem to like to wrap functions
	//	with qualified names (like Loris::channelize),
	//	they simply get ignored.
	//
	// (This has probably been fixed by now.)
	using namespace Loris;
	
	#include <list>
	#include <stdexcept>
	#include <vector>


SWIGINTERN int
  SWIG_AsVal_double(PyObject *obj, double *val)
{
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AS_DOUBLE(obj);
    return 1;
  }  
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AS_LONG(obj);
    return 1;
  }
  if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return 1;
    } else {
      if (!val) PyErr_Clear();
      return 0;
    }
  }
  if (val) {
    SWIG_type_error("double", obj);
  }
  return 0;
}


  /*@/usr/local/share/swig/1.3.24/python/pymacros.swg,66,SWIG_define@*/
#define SWIG_From_double PyFloat_FromDouble
/*@@*/


namespace swig {  
  template <class Type>
  struct noconst_traits {
    typedef Type noconst_type;
  };

  template <class Type>
  struct noconst_traits<const Type> {
    typedef Type noconst_type;
  };

  /*
    type categories
  */
  struct pointer_category { };  
  struct value_category { };

  /*
    General traits that provides type_name and type_info
  */
  template <class Type> struct traits { };

  template <class Type>
  inline const char* type_name() {
    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
  }

  template <class Type> 
  struct traits_info {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }    
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  template <class Type>
  inline swig_type_info *type_info() {
    return traits_info<Type>::type_info();
  }

  /*
    Partial specialization for pointers
  */
  template <class Type> struct traits <Type *> {
    typedef pointer_category category;
    static std::string make_ptr_name(const char* name) {
      std::string ptrname = name;
      ptrname += " *";
      return ptrname;
    }    
    static const char* type_name() {
      static std::string name = make_ptr_name(swig::type_name<Type>());
      return name.c_str();
    }
  };

  template <class Type, class Category> 
  struct traits_as { };
 
  template <class Type, class Category> 
  struct traits_check { };

}


namespace swig {  
  /*
    Traits that provides the from method
  */
  template <class Type> struct traits_from_ptr {
    static PyObject *from(Type *val, int owner = 0) {
      return SWIG_NewPointerObj(val, type_info<Type>(), owner);
    }
  };

  template <class Type> struct traits_from {
    static PyObject *from(const Type& val) {
      return traits_from_ptr<Type>::from(new Type(val), 1);
    }
  };

  template <class Type> struct traits_from<Type *> {
    static PyObject *from(Type* val) {
      return traits_from_ptr<Type>::from(val, 0);
    }
  };

  template <class Type>
  inline PyObject *from(const Type& val) {
    return traits_from<Type>::from(val);
  }

  template <class Type>
  inline PyObject *from_ptr(Type* val, int owner) {
    return traits_from_ptr<Type>::from(val, owner);
  }

  /*
    Traits that provides the asval/as/check method
  */
  template <class Type>
  struct traits_asptr {   
    static int asptr(PyObject *obj, Type **val) {
      Type *p;
      int res = (SWIG_ConvertPtr(obj, (void**)&p, type_info<Type>(), 0) != -1) 
	? SWIG_OLDOBJ : 0;
      if (res) {
	if (val) {
	  *val = p;
	}
      } else {
	SWIG_type_error(type_name<Type>(), obj);
      }
      return res;
    }
  }; 

  template <class Type>
  inline int asptr(PyObject *obj, Type **vptr) {
    return traits_asptr<Type>::asptr(obj, vptr);
  }

  template <class Type> 
  struct traits_asval {
    static bool asval(PyObject *obj, Type *val) {
      if (val) {
	Type *p = 0;
	int res = traits_asptr<Type>::asptr(obj, &p);
	if (res && p) {
	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
	  *(const_cast<noconst_type*>(val)) = *p;
	  if (res == SWIG_NEWOBJ) delete p;
	  return true;
	} else {
	  return false;
	}
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };

  template <class Type> struct traits_asval<Type*> {
    static bool asval(PyObject *obj, Type **val) {
      if (val) {
        typedef typename noconst_traits<Type>::noconst_type noconst_type;
        noconst_type *p = 0;
        int res = traits_asptr<noconst_type>::asptr(obj, &p);
        if (res) {
          *(const_cast<noconst_type**>(val)) = p;
     	  return true;
	} else {
	  return false;
	}
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };
  
  template <class Type>
  inline bool asval(PyObject *obj, Type *val) {
    return traits_asval<Type>::asval(obj, val);
  }

  template <class Type> 
  struct traits_as<Type, value_category> {
    static Type as(PyObject *obj, bool throw_error) {
      Type v;
      if (!obj || !asval(obj, &v)) {
	if (!PyErr_Occurred()) {
	  SWIG_type_error(swig::type_name<Type>(), obj);
	}
	if (throw_error) throw std::invalid_argument("bad type");
      }
      return v;
    }
  };

  template <class Type> 
  struct traits_as<Type, pointer_category> {
    static Type as(PyObject *obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : 0) && v;
      if (res) {
	if (res == SWIG_NEWOBJ) {
	  Type r(*v);
	  delete v;
	  return r;
	} else {
	  return *v;
	}
      } else {
	// Uninitialized return value, no Type() constructor required.
	static Type *v_def = (Type*) malloc(sizeof(Type));
	if (!PyErr_Occurred()) {
	  SWIG_type_error(swig::type_name<Type>(), obj);
	}
	if (throw_error) throw std::invalid_argument("bad type");
	memset(v_def,0,sizeof(Type));
	return *v_def;
      }
    }
  };

  template <class Type> 
  struct traits_as<Type*, pointer_category> {
    static Type* as(PyObject *obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : 0);
      if (res) {
	return v;
      } else {
	if (!PyErr_Occurred()) {
	  SWIG_type_error(swig::type_name<Type>(), obj);
	}
	if (throw_error) throw std::invalid_argument("bad type");
	return 0;
      }
    }
  };
    
  template <class Type>
  inline Type as(PyObject *obj, bool te = false) {
    return traits_as<Type, typename traits<Type>::category>::as(obj, te);
  }

  template <class Type> 
  struct traits_check<Type, value_category> {
    static bool check(PyObject *obj) {
      return obj && asval(obj, (Type *)(0));
    }
  };

  template <class Type> 
  struct traits_check<Type, pointer_category> {
    static bool check(PyObject *obj) {
      return obj && asptr(obj, (Type **)(0));
    }
  };

  template <class Type>
  inline bool check(PyObject *obj) {
    return traits_check<Type, typename traits<Type>::category>::check(obj);
  }
}


namespace swig {
  template <> struct traits<double > {
    typedef value_category category;
    static const char* type_name() { return"double"; }
  };  
  template <>  struct traits_asval<double > {   
    typedef double value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_double(obj, val);
    }
  };
  template <>  struct traits_from<double > {
    typedef double value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_double(val);
    }
  };
}


  namespace swig {
    struct PyObject_var {
      PyObject* ptr;
      PyObject_var(PyObject* obj = 0) : ptr(obj) { }      
      ~PyObject_var() { if (ptr) Py_DECREF(ptr); }      
      operator PyObject*() { return ptr; }
      PyObject* operator->() const { return ptr; }
    };
  }


namespace swig {
  inline size_t
  check_index(ptrdiff_t i, size_t size, bool insert = false) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size) 
	return (size_t) (i + size);
    } else if ( (size_t) i < size ) {
      return (size_t) i;
    } else if (insert && ((size_t) i == size)) {
      return size;
    }
    
    throw std::out_of_range("index out of range");
  }

  inline size_t
  slice_index(ptrdiff_t i, size_t size) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size) {
	return (size_t) (i + size);
      } else {
	throw std::out_of_range("index out of range");
      }
    } else {
      return ( (size_t) i < size ) ? ((size_t) i) : size;
    }
  }

  template <class Sequence, class Difference>
  inline typename Sequence::iterator 
  getpos(Sequence* self, Difference i)  {
    typename Sequence::iterator pos = self->begin(); 
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline typename Sequence::const_iterator 
  cgetpos(const Sequence* self, Difference i)  {
    typename Sequence::const_iterator pos = self->begin(); 
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline Sequence*
  getslice(const Sequence* self, Difference i, Difference j) { 
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    
    if (jj > ii) {
      typename Sequence::const_iterator vb = self->begin();
      typename Sequence::const_iterator ve = self->begin();
      std::advance(vb,ii);
      std::advance(ve,jj);
      return new Sequence(vb, ve);
    } else {
      return new Sequence();
    }
  }

  template <class Sequence, class Difference, class InputSeq>
  inline void
  setslice(Sequence* self, Difference i, Difference j, const InputSeq& v) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj < ii) jj = ii;
    typename Sequence::iterator sb = self->begin();
    typename InputSeq::const_iterator vmid = v.begin();
    std::advance(sb,ii);
    std::advance(vmid, jj - ii);
    self->insert(std::copy(v.begin(), vmid, sb), vmid, v.end());
  }
 
  template <class Sequence, class Difference>
  inline void
  delslice(Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj > ii) {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
    }
  }
}


#include <iterator>
namespace swig
{
  template <class T> 
  struct PySequence_Ref
  {
    PySequence_Ref(PyObject* seq, int index) 
      : _seq(seq), _index(index)
    {
    }

    operator T () const 
    {
      swig::PyObject_var item = PySequence_GetItem(_seq, _index);
      try {
	return swig::as<T>(item, true);
      } catch (std::exception& e) {
	char msg[1024];
	sprintf(msg,"in sequence element %d", _index);
	if (!PyErr_Occurred()) {
	  SWIG_type_error(swig::type_name<T>(), item);
	}
	SWIG_append_errmsg(msg);
	throw;
      }
    }
    
    PySequence_Ref& operator=(const T& v) 
    {
      PySequence_SetItem(_seq, _index, swig::from<T>(v));
      return *this;
    }
    
  private:
    PyObject* _seq;
    int _index;
  };

  template <class T> 
  struct PySequence_ArrowProxy 
  {
    PySequence_ArrowProxy(const T& x): m_value(x) {}
    const T* operator->() const { return &m_value; }
    operator const T*() const { return &m_value; }
    T m_value;
  };    

  template <class T, class Reference > 
  struct PySequence_Iter
  {
    typedef PySequence_Iter<T, Reference > self;

    typedef std::random_access_iterator_tag iterator_category;
    typedef Reference reference;
    typedef T value_type;
    typedef T* pointer;
    typedef int difference_type;

    PySequence_Iter()
    {
    }

    PySequence_Iter(PyObject* seq, int index)
      : _seq(seq), _index(index)
    {
    }

    reference operator*() const
    { 
      return reference(_seq, _index);
    }

    PySequence_ArrowProxy<T>
    operator->() const {
      return PySequence_ArrowProxy<T>(operator*());
    }

    bool operator==(const self& ri) const 
    { 
      return (_index == ri._index) && (_seq == ri._seq);
    }

    bool operator!=(const self& ri) const 
    {
      return !(operator==(ri));
    }    

    self& operator ++ ()
    {
      ++_index;      
      return *this;
    }

    self& operator -- ()
    {
      --_index;
      return *this;
    }

    self& operator += (difference_type n) 
    {
      _index += n;
      return *this;
    }

    self operator +(difference_type n) const
    {
      return self(_seq, _index + n);
    }

    self& operator -= (difference_type n) 
    {
      _index -= n;
      return *this;
    }

    self operator -(difference_type n) const
    {
      return self(_seq, _index - n);
    }    

    difference_type operator - (const self& ri) const
    {
      return _index - ri._index;
    }

    reference 
    operator[](difference_type n) const 
    { 
      return reference(_seq, _index + n);
    }

  private:
    PyObject* _seq;
    int _index;
  }; 

  template <class T> 
  struct PySequence_Cont
  {
    typedef PySequence_Ref<T> reference;
    typedef const PySequence_Ref<T> const_reference;
    typedef T value_type;
    typedef T* pointer;
    typedef int difference_type;
    typedef int size_type;
    typedef const pointer const_pointer;
    typedef PySequence_Iter<T, reference> iterator;
    typedef PySequence_Iter<T, const_reference> const_iterator;

    PySequence_Cont(PyObject* seq) : _seq(0)
    {
      if (!PySequence_Check(seq)) {
	throw std::invalid_argument("a sequence is expected");
      }
      _seq = seq;
      Py_INCREF(_seq);
    }

    ~PySequence_Cont() 
    {
      if (_seq) Py_DECREF(_seq);
    }

    size_type size() const
    {
      return PySequence_Size(_seq);
    }

    bool empty() const
    {
      return size() == 0;
    }    

    iterator begin()
    {
      return iterator(_seq, 0);
    }

    const_iterator begin() const
    {
      return const_iterator(_seq, 0);
    }
    
    iterator end()
    {
      return iterator(_seq, size());
    }
    
    const_iterator end() const
    {
      return const_iterator(_seq, size());
    }    

    reference operator[](difference_type n) 
    { 
      return reference(_seq, n);
    }

    const_reference operator[](difference_type n)  const
    { 
      return const_reference(_seq, n);
    }

    bool check(bool set_err = true) const
    {
      int s = size();
      for (int i = 0; i < s; ++i) {
	swig::PyObject_var item = PySequence_GetItem(_seq, i);
	if (!swig::check<value_type>(item)) {
	  if (set_err) {
	    char msg[1024];
	    sprintf(msg,"in sequence element %d", i);
	    SWIG_type_error(swig::type_name<value_type>(), item);
	    SWIG_append_errmsg(msg);
	  }
	  return 0;
	}
      }
      return 1;  
    }

  private:
    PyObject* _seq;
  };

}


  namespace swig {
    template <class PySeq, class Seq> 
    inline void
    assign(const PySeq& pyseq, Seq* seq) {
#ifdef SWIG_STD_NOASSIGN_STL
      typedef typename PySeq::value_type value_type;
      typename PySeq::const_iterator it = pyseq.begin();
      for (;it != pyseq.end(); ++it) {
	seq->insert(seq->end(),(value_type)(*it));
      }
#else
      seq->assign(pyseq.begin(), pyseq.end());
#endif
    }

    template <class Seq, class T = typename Seq::value_type >
    struct traits_asptr_stdseq {
      typedef Seq sequence;
      typedef T value_type;
		    
      static int asptr(PyObject *obj, sequence **seq) {
	if (PySequence_Check(obj)) {
	  try {
	    PySequence_Cont<value_type> pyseq(obj);
	    if (seq) {
	      sequence *pseq = new sequence();
	      assign(pyseq, pseq);
	      *seq = pseq;
	      return SWIG_NEWOBJ;
	    } else {
	      return pyseq.check();
	    }
	  } catch (std::exception& e) {
	    if (seq) {
	      if (!PyErr_Occurred())
		PyErr_SetString(PyExc_TypeError, e.what());
	    }
	    return 0;
	  }
	} else {
	  sequence *p;
	  if (SWIG_ConvertPtr(obj,(void**)&p,
			      swig::type_info<sequence>(),0) != -1) {
	    if (seq) *seq = p;
	    return 1;
	  }
	}
	if (seq) {
	  PyErr_Format(PyExc_TypeError, "a %s is expected", 
		       swig::type_name<sequence>());
	}
	return 0;	  
      }
    };

    template <class Seq, class T = typename Seq::value_type >
    struct traits_from_stdseq {
      typedef Seq sequence;
      typedef T value_type;
      typedef typename Seq::size_type size_type;
      typedef typename sequence::const_iterator const_iterator;

      static PyObject *from(const sequence& seq) {
	size_type size = seq.size();
	if (size <= (size_type)INT_MAX) {
	  PyObject *obj = PyTuple_New((int)size);
	  int i = 0;
	  for (const_iterator it = seq.begin();
	       it != seq.end(); ++it, ++i) {
	    PyTuple_SetItem(obj,i,swig::from<value_type>(*it));
	  }
	  return obj;
	} else {
	  PyErr_SetString(PyExc_OverflowError,
			  "sequence size not valid in python");
	  Py_INCREF(Py_None);
	  return Py_None;
	}
      }
    };
  }


  namespace swig {
    template <class T>
    struct traits_asptr<std::vector<T> >  {
      static int asptr(PyObject *obj, std::vector<T> **vec) {
	return traits_asptr_stdseq<std::vector<T> >::asptr(obj, vec);
      }
    };
    
    template <class T>
    struct traits_from<std::vector<T> > {
      static PyObject *from(const std::vector<T>& vec) {
	return traits_from_stdseq<std::vector<T> >::from(vec);
      }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector<double, std::allocator<double > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "double" "," "std::allocator<double >" " >";
	  }
	};
      }
    

SWIGINTERNSHORT PyObject*
  SWIG_From_bool(bool value)
{
  PyObject *obj = value ? Py_True : Py_False;
  Py_INCREF(obj);
  return obj;
}


SWIGINTERNSHORT PyObject* 
  SWIG_From_unsigned_SS_long(unsigned long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLong(value) 
    : PyInt_FromLong((long)(value)); 
}


SWIGINTERN int
  SWIG_AsVal_unsigned_SS_long(PyObject *obj, unsigned long *val) 
{
  if (PyInt_Check(obj)) {
    long v = PyInt_AS_LONG(obj);
    if (v >= 0) {
      if (val) *val = v;
      return 1;
    }   
  }
  if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return 1;
    } else {
      if (!val) PyErr_Clear();
      return 0;
    }
  } 
  if (val) {
    SWIG_type_error("unsigned long", obj);
  }
  return 0;
}


SWIGINTERNSHORT unsigned long
SWIG_As_unsigned_SS_long(PyObject* obj)
{
  unsigned long v;
  if (!SWIG_AsVal_unsigned_SS_long(obj, &v)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(unsigned long));
  }
  return v;
}

  
SWIGINTERNSHORT int
SWIG_Check_unsigned_SS_long(PyObject* obj)
{
  return SWIG_AsVal_unsigned_SS_long(obj, (unsigned long*)0);
}


SWIGINTERNSHORT double
SWIG_As_double(PyObject* obj)
{
  double v;
  if (!SWIG_AsVal_double(obj, &v)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(double));
  }
  return v;
}

  
SWIGINTERNSHORT int
SWIG_Check_double(PyObject* obj)
{
  return SWIG_AsVal_double(obj, (double*)0);
}

static bool std_vector_Sl_double_Sg____nonzero__(std::vector<double > const *self){
      return !(self->empty());
    }
static std::vector<double >::size_type std_vector_Sl_double_Sg____len__(std::vector<double > const *self){
      return self->size();
    }
static std::vector<double >::value_type std_vector_Sl_double_Sg__pop(std::vector<double > *self){
      if (self->size() == 0)
	throw std::out_of_range("pop from empty container");
      std::vector<double,std::allocator<double > >::value_type x = self->back();
      self->pop_back();
      return x;
    }

SWIGINTERN int
  SWIG_AsVal_long(PyObject * obj, long* val)
{
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AS_LONG(obj);
    return 1;
  }
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return 1;
    } else {
      if (!val) PyErr_Clear();
      return 0;
    }
  }
  if (val) {
    SWIG_type_error("long", obj);
  }
  return 0;
 }


SWIGINTERNSHORT long
SWIG_As_long(PyObject* obj)
{
  long v;
  if (!SWIG_AsVal_long(obj, &v)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(long));
  }
  return v;
}

  
SWIGINTERNSHORT int
SWIG_Check_long(PyObject* obj)
{
  return SWIG_AsVal_long(obj, (long*)0);
}

static std::vector<double,std::allocator<double > > *std_vector_Sl_double_Sg____getslice__(std::vector<double > *self,std::vector<double >::difference_type i,std::vector<double >::difference_type j){
      return swig::getslice(self, i, j);
    }
static void std_vector_Sl_double_Sg____setslice__(std::vector<double > *self,std::vector<double >::difference_type i,std::vector<double >::difference_type j,std::vector<double,std::allocator<double > > const &v){
      swig::setslice(self, i, j, v);
    }
static void std_vector_Sl_double_Sg____delslice__(std::vector<double > *self,std::vector<double >::difference_type i,std::vector<double >::difference_type j){
      swig::delslice(self, i, j);
    }
static void std_vector_Sl_double_Sg____delitem__(std::vector<double > *self,std::vector<double >::difference_type i){
      self->erase(swig::getpos(self,i));
    }
static std::vector<double >::value_type const &std_vector_Sl_double_Sg____getitem__(std::vector<double > const *self,std::vector<double >::difference_type i){
      return *(swig::cgetpos(self, i));
    }
static void std_vector_Sl_double_Sg____setitem__(std::vector<double > *self,std::vector<double >::difference_type i,std::vector<double >::value_type const &x){
      *(swig::getpos(self,i)) = x;
    }
static void std_vector_Sl_double_Sg__append(std::vector<double > *self,std::vector<double >::value_type const &x){
      self->push_back(x);
    }

  namespace swig {
    template <>  struct traits<Marker > {
      typedef pointer_category category;
      static const char* type_name() { return"Marker"; }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector<Marker, std::allocator<Marker > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "Marker" "," "std::allocator<Marker >" " >";
	  }
	};
      }
    
static bool std_vector_Sl_Marker_Sg____nonzero__(std::vector<Marker > const *self){
      return !(self->empty());
    }
static std::vector<Marker >::size_type std_vector_Sl_Marker_Sg____len__(std::vector<Marker > const *self){
      return self->size();
    }
static std::vector<Marker >::value_type std_vector_Sl_Marker_Sg__pop(std::vector<Marker > *self){
      if (self->size() == 0)
	throw std::out_of_range("pop from empty container");
      std::vector<Marker,std::allocator<Marker > >::value_type x = self->back();
      self->pop_back();
      return x;
    }
static std::vector<Marker,std::allocator<Marker > > *std_vector_Sl_Marker_Sg____getslice__(std::vector<Marker > *self,std::vector<Marker >::difference_type i,std::vector<Marker >::difference_type j){
      return swig::getslice(self, i, j);
    }
static void std_vector_Sl_Marker_Sg____setslice__(std::vector<Marker > *self,std::vector<Marker >::difference_type i,std::vector<Marker >::difference_type j,std::vector<Marker,std::allocator<Marker > > const &v){
      swig::setslice(self, i, j, v);
    }
static void std_vector_Sl_Marker_Sg____delslice__(std::vector<Marker > *self,std::vector<Marker >::difference_type i,std::vector<Marker >::difference_type j){
      swig::delslice(self, i, j);
    }
static void std_vector_Sl_Marker_Sg____delitem__(std::vector<Marker > *self,std::vector<Marker >::difference_type i){
      self->erase(swig::getpos(self,i));
    }
static std::vector<Marker >::value_type const &std_vector_Sl_Marker_Sg____getitem__(std::vector<Marker > const *self,std::vector<Marker >::difference_type i){
      return *(swig::cgetpos(self, i));
    }
static void std_vector_Sl_Marker_Sg____setitem__(std::vector<Marker > *self,std::vector<Marker >::difference_type i,std::vector<Marker >::value_type const &x){
      *(swig::getpos(self,i)) = x;
    }
static void std_vector_Sl_Marker_Sg__append(std::vector<Marker > *self,std::vector<Marker >::value_type const &x){
      self->push_back(x);
    }
 
	static char error_message[256];
	static int error_status = 0;
	
	void throw_exception( const char *msg ) 
	{
		strncpy(error_message,msg,256);
		error_status = 1;
	}
	
	void clear_exception( void ) 
	{
		error_status = 0;
	}
	
	char *check_exception( void ) 
	{
		if ( error_status ) 
		{
			return error_message;
		}
		else 
		{
			return NULL;
		}
	}


	//	notification function for Loris debugging
	//	and notifications, installed in initialization
	//	block below:
	static void printf_notifier( const char * s )
	{
		printf("*\t%s\n", s);
	}	


#include <limits.h>


SWIGINTERN int
  SWIG_CheckLongInRange(long value, long min_value, long max_value,
			const char *errmsg)
{
  if (value < min_value) {
    if (errmsg) {
      PyErr_Format(PyExc_OverflowError, 
		   "value %ld is less than '%s' minimum %ld", 
		   value, errmsg, min_value);
    }
    return 0;    
  } else if (value > max_value) {
    if (errmsg) {
      PyErr_Format(PyExc_OverflowError,
		   "value %ld is greater than '%s' maximum %ld", 
		   value, errmsg, max_value);
    }
    return 0;
  }
  return 1;
}


#if INT_MAX != LONG_MAX
SWIGINTERN int
  SWIG_AsVal_int(PyObject *obj, int *val)
{ 
  const char* errmsg = val ? "int" : (char*)0;
  long v;
  if (SWIG_AsVal_long(obj, &v)) {
    if (SWIG_CheckLongInRange(v, INT_MIN,INT_MAX, errmsg)) {
      if (val) *val = (int)(v);
      return 1;
    } else {
      return 0;
    }
  } else {
    PyErr_Clear();
  }
  if (val) {
    SWIG_type_error(errmsg, obj);
  }
  return 0;    
}
#else
SWIGINTERNSHORT int
  SWIG_AsVal_int(PyObject *obj, int *val)
{
  return SWIG_AsVal_long(obj,(long*)val);
}
#endif


SWIGINTERNSHORT int
SWIG_As_int(PyObject* obj)
{
  int v;
  if (!SWIG_AsVal_int(obj, &v)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(int));
  }
  return v;
}

  
SWIGINTERNSHORT int
SWIG_Check_int(PyObject* obj)
{
  return SWIG_AsVal_int(obj, (int*)0);
}


	BreakpointEnvelope * 
	createFreqReference( PartialList * partials, 
						 double minFreq, double maxFreq )
	{
		createFreqReference( partials, minFreq, maxFreq, 0 );
	}


	void dilate( PartialList * partials, 
		   	     const std::vector< double > & ivec, 
				 const std::vector< double > & tvec )
	{
		const double * initial = &( ivec.front() );
		const double * target = &( tvec.front() );
		int npts = ivec.size();
		dilate( partials, initial, target, npts );
	}


	void exportAiff( const char * path, const std::vector< double > & samples,
					 double samplerate = 44100.0, int bitsPerSamp = 16 )
	{
		exportAiff( path, &(samples.front()), samples.size(), 
					samplerate, bitsPerSamp );
	}


/* returns SWIG_OLDOBJ if the input is a raw char*, SWIG_PYSTR if is a PyString */
SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize)
{
  static swig_type_info* pchar_info = 0;
  char* vptr = 0;
  if (!pchar_info) pchar_info = SWIG_TypeQuery("char *");
  if (SWIG_ConvertPtr(obj, (void**)&vptr, pchar_info, 0) != -1) {
    if (cptr) *cptr = vptr;
    if (psize) *psize = vptr ? (strlen(vptr) + 1) : 0;
    return SWIG_OLDOBJ;
  } else {
    PyErr_Clear();
    if (PyString_Check(obj)) {
      if (cptr) {
	*cptr = PyString_AS_STRING(obj);
	if (psize) {
	  *psize = PyString_GET_SIZE(obj) + 1;
	}
      }
      return SWIG_PYSTR;
    }
  }
  if (cptr) {
    SWIG_type_error("char *", obj);
  }
  return 0;
}


SWIGINTERNSHORT int
SWIG_AsCharPtr(PyObject *obj, char **val)
{
  if (SWIG_AsCharPtrAndSize(obj, val, (size_t*)(0))) {
    return 1;
  }
  if (val) {
    PyErr_Clear();
    SWIG_type_error("char *", obj);
  }
  return 0;
}


void exportSpc( const char * path, PartialList * partials, double midiPitch,
			    int enhanced )
{
	exportSpc( path, partials, midiPitch, enhanced, 0. );
}


void exportSpc( const char * path, PartialList * partials, double midiPitch )
{
	exportSpc( path, partials, midiPitch, true, 0. );
}


	PartialList * importSdif( const char * path )
	{
		PartialList * dst = createPartialList();
		importSdif( path, dst );

		// check for exception:
		if (check_exception())
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	PartialList * importSpc( const char * path )
	{
		PartialList * dst = createPartialList();
		importSpc( path, dst );

		// check for exception:
		if (check_exception())
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	PartialList * morph( const PartialList * src0, const PartialList * src1, 
						 const BreakpointEnvelope * ffreq, 
						 const BreakpointEnvelope * famp, 
						 const BreakpointEnvelope * fbw )
	{
		PartialList * dst = createPartialList();
		morph( src0, src1, ffreq, famp, fbw, dst );
		
		// check for exception:
		if ( check_exception() )
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}
	
	PartialList * morph( const PartialList * src0, const PartialList * src1, 
						 double freqweight, 
						 double ampweight, 
						 double bwweight )
	{
		BreakpointEnvelope ffreq( freqweight ), famp( ampweight ), fbw( bwweight );
		
		PartialList * dst = createPartialList();
		morph( src0, src1, &ffreq, &famp, &fbw, dst );
		
		// check for exception:
		if ( check_exception() )
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	std::vector<double> synthesize( const PartialList * partials, double srate = 44100.0 )
	{
		std::vector<double> dst;
		Synthesizer synth( srate, dst );
		synth.synthesize( partials->begin(), partials->end() );
		return dst;
	}


	PartialList * copyLabeled( PartialList * partials, long label )
	{
		PartialList * dst = createPartialList();
		copyLabeled( partials, label, dst );
		
		// check for exception:
		if ( check_exception() )
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	PartialList * extractLabeled( PartialList * partials, long label )
	{
		PartialList * dst = createPartialList();
		extractLabeled( partials, label, dst );
		
		// check for exception:
		if ( check_exception() )
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}

	
	void scaleAmp( PartialList * partials, double val )
	{
		BreakpointEnvelope e( val );
		scaleAmp( partials, &e );
	}
	
	
	void scaleBandwidth( PartialList * partials, double val )
	{
		BreakpointEnvelope e( val );
		scaleBandwidth( partials, &e );
	}
	
	
	void scaleFrequency( PartialList * partials, double val )
	{
		BreakpointEnvelope e( val );
		scaleFrequency( partials, &e );
	}
	
	
	void scaleNoiseRatio( PartialList * partials, double val )
	{
		BreakpointEnvelope e( val );
		scaleNoiseRatio( partials, &e );
	}
	
	
	void shiftPitch( PartialList * partials, double val )
	{
		BreakpointEnvelope e( val );
		shiftPitch( partials, &e );
	}


	const char * version( void )
	{
		static const char * vstr = LORIS_VERSION_STR;
		return vstr;
	}


SWIGINTERN PyObject *
SWIG_FromCharPtr(const char* cptr)
{ 
  if (cptr) {
    size_t size = strlen(cptr);
    if (size > INT_MAX) {
      return SWIG_NewPointerObj((char*)(cptr), 
				SWIG_TypeQuery("char *"), 0);
    } else {
      if (size != 0) {
	return PyString_FromStringAndSize(cptr, size);
      } else {
	return PyString_FromString(cptr);
      }
    }
  }
  Py_INCREF(Py_None);
  return Py_None;
}

static char const *Marker_name(Marker *self){ return self->name().c_str(); }

SWIGINTERNSHORT int
  SWIG_CheckUnsignedLongInRange(unsigned long value,
				unsigned long max_value,
				const char *errmsg) 
{
  if (value > max_value) {
    if (errmsg) {
      PyErr_Format(PyExc_OverflowError,
		   "value %lu is greater than '%s' minimum %lu",
		   value, errmsg, max_value);
    }
    return 0;
  }
  return 1;
 }


#if UINT_MAX != ULONG_MAX
SWIGINTERN int
  SWIG_AsVal_unsigned_SS_int(PyObject *obj, unsigned int *val)
{ 
  const char* errmsg = val ? "unsigned int" : (char*)0;
  unsigned long v;
  if (SWIG_AsVal_unsigned_SS_long(obj, &v)) {
    if (SWIG_CheckUnsignedLongInRange(v, INT_MAX, errmsg)) {
      if (val) *val = (unsigned int)(v);
      return 1;
    }
  } else {
    PyErr_Clear();
  }
  if (val) {
    SWIG_type_error(errmsg, obj);
  }
  return 0;    
}
#else
SWIGINTERNSHORT unsigned int
  SWIG_AsVal_unsigned_SS_int(PyObject *obj, unsigned int *val)
{
  return SWIG_AsVal_unsigned_SS_long(obj,(unsigned long *)val);
}
#endif


SWIGINTERNSHORT unsigned int
SWIG_As_unsigned_SS_int(PyObject* obj)
{
  unsigned int v;
  if (!SWIG_AsVal_unsigned_SS_int(obj, &v)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(unsigned int));
  }
  return v;
}

  
SWIGINTERNSHORT int
SWIG_Check_unsigned_SS_int(PyObject* obj)
{
  return SWIG_AsVal_unsigned_SS_int(obj, (unsigned int*)0);
}

static AiffFile *new_AiffFile__SWIG_2(PartialList *l,double sampleRate=44100,double fadeTime=.001){
			return new AiffFile( l->begin(), l->end(), sampleRate, fadeTime );
		}
static std::vector<double > AiffFile_samples(AiffFile *self){
			return self->samples();
		}
static int AiffFile_channels(AiffFile *self){ return 1; }

  /*@/usr/local/share/swig/1.3.24/python/pymacros.swg,66,SWIG_define@*/
#define SWIG_From_int PyInt_FromLong
/*@@*/

static void AiffFile_addPartials__SWIG_0(AiffFile *self,PartialList *l,double fadeTime=0.001){
			self->addPartials( l->begin(), l->end(), fadeTime );
		}
static int AiffFile_numMarkers(AiffFile *self){ return self->markers().size(); }
static Marker *AiffFile_getMarker(AiffFile *self,int i){
			if ( i < 0 || i >= self->markers().size() )
			{
				Throw( InvalidArgument, "Marker index out of range." );
			}
			return new Marker( self->markers()[i] );
		}
static void AiffFile_removeMarker(AiffFile *self,int i){
			if ( i < 0 || i >= self->markers().size() )
			{
				Throw( InvalidArgument, "Marker index out of range." );
			}
			self->markers().erase( self->markers().begin() + i );
		}
static void AiffFile_addMarker(AiffFile *self,Marker m){
			self->markers().push_back( m );
		}
static void AiffFile_clearMarkers(AiffFile *self){
			self->markers().clear();
		}
static std::vector<Marker > AiffFile_markers(AiffFile *self){
			return self->markers();
		}
static void AiffFile_addMarkers(AiffFile *self,std::vector<Marker > const &markers){
			self->markers().insert( self->markers().end(), 
									markers.begin(), markers.end() );
		}

	#include<Analyzer.h>
	#include<Partial.h>

static Analyzer *new_Analyzer__SWIG_0(double resolutionHz,double windowWidthHz=0.){
			if ( windowWidthHz == 0. )
				windowWidthHz = resolutionHz;
			return new Analyzer( resolutionHz, windowWidthHz );
		}
static Analyzer *Analyzer_copy(Analyzer *self){
			return new Analyzer( *self );
		}
static PartialList *Analyzer_analyze__SWIG_0(Analyzer *self,std::vector<double > const &vec,double srate){
			PartialList * partials = new PartialList();
			if ( ! vec.empty() )
			{
				self->analyze( vec, srate );
			}
			partials->splice( partials->end(), self->partials() );
			return partials;
		}
static PartialList *Analyzer_analyze__SWIG_1(Analyzer *self,std::vector<double > const &vec,double srate,BreakpointEnvelope *env){
			PartialList * partials = new PartialList();
			if ( ! vec.empty() )
			{
				self->analyze( vec, srate, *env );
			}
			partials->splice( partials->end(), self->partials() );
			return partials;
		}

	#include<BreakpointEnvelope.h>

static BreakpointEnvelope *BreakpointEnvelope_copy(BreakpointEnvelope *self){
			return new BreakpointEnvelope( *self );
		}

	BreakpointEnvelope *
	BreakpointEnvelopeWithValue( double initialValue )
	{
		return new BreakpointEnvelope( initialValue );
	}


	#include<SdifFile.h>

static SdifFile *new_SdifFile__SWIG_2(PartialList *l){
			return new SdifFile( l->begin(), l->end() );
		}
static PartialList *SdifFile_partials(SdifFile *self){
			PartialList * plist = new PartialList( self->partials() );
			return plist;
		}
static void SdifFile_addPartials(SdifFile *self,PartialList *l){
			self->addPartials( l->begin(), l->end() );
		}
static int SdifFile_numMarkers(SdifFile *self){ return self->markers().size(); }
static Marker *SdifFile_getMarker(SdifFile *self,int i){
			if ( i < 0 || i >= self->markers().size() )
			{
				Throw( InvalidArgument, "Marker index out of range." );
			}
			return new Marker( self->markers()[i] );
		}
static void SdifFile_removeMarker(SdifFile *self,int i){
			if ( i < 0 || i >= self->markers().size() )
			{
				Throw( InvalidArgument, "Marker index out of range." );
			}
			self->markers().erase( self->markers().begin() + i );
		}
static void SdifFile_addMarker(SdifFile *self,Marker m){
			self->markers().push_back( m );
		}
static void SdifFile_clearMarkers(SdifFile *self){
			self->markers().clear();
		}
static std::vector<Marker > SdifFile_markers(SdifFile *self){
			return self->markers();
		}
static void SdifFile_addMarkers(SdifFile *self,std::vector<Marker > const &markers){
			self->markers().insert( self->markers().end(), 
									markers.begin(), markers.end() );
		}

	#include<SpcFile.h>


SWIGINTERN int
  SWIG_AsVal_bool(PyObject *obj, bool *val)
{
  if (obj == Py_True) {
    if (val) *val = true;
    return 1;
  }
  if (obj == Py_False) {
    if (val) *val = false;
    return 1;
  }
  int res = 0;
  if (SWIG_AsVal_int(obj, &res)) {    
    if (val) *val = res ? true : false;
    return 1;
  } else {
    PyErr_Clear();
  }  
  if (val) {
    SWIG_type_error("bool", obj);
  }
  return 0;
}


SWIGINTERNSHORT bool
SWIG_As_bool(PyObject* obj)
{
  bool v;
  if (!SWIG_AsVal_bool(obj, &v)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(bool));
  }
  return v;
}

  
SWIGINTERNSHORT int
SWIG_Check_bool(PyObject* obj)
{
  return SWIG_AsVal_bool(obj, (bool*)0);
}

static SpcFile *new_SpcFile__SWIG_3(PartialList *l,double midiNoteNum=60){
			return new SpcFile( l->begin(), l->end(), midiNoteNum );
		}
static PartialList *SpcFile_partials(SpcFile *self){
			PartialList * plist = new PartialList( self->partials().begin(), self->partials().end() );
			return plist;
		}
static void SpcFile_addPartials(SpcFile *self,PartialList *l){
			self->addPartials( l->begin(), l->end() );
		}
static int SpcFile_numMarkers(SpcFile *self){ return self->markers().size(); }
static Marker *SpcFile_getMarker(SpcFile *self,int i){
			if ( i < 0 || i >= self->markers().size() )
			{
				Throw( InvalidArgument, "Marker index out of range." );
			}
			return new Marker( self->markers()[i] );
		}
static void SpcFile_removeMarker(SpcFile *self,int i){
			if ( i < 0 || i >= self->markers().size() )
			{
				Throw( InvalidArgument, "Marker index out of range." );
			}
			self->markers().erase( self->markers().begin() + i );
		}
static void SpcFile_addMarker(SpcFile *self,Marker m){
			self->markers().push_back( m );
		}
static void SpcFile_clearMarkers(SpcFile *self){
			self->markers().clear();
		}
static std::vector<Marker > SpcFile_markers(SpcFile *self){
			return self->markers();
		}
static void SpcFile_addMarkers(SpcFile *self,std::vector<Marker > const &markers){
			self->markers().insert( self->markers().end(), 
									markers.begin(), markers.end() );
		}

#include<Partial.h>
#include<PartialList.h>
#include<PartialUtils.h>
#include<Notifier.h>
#include <list>

using Loris::debugger;
using Loris::Partial;
using Loris::PartialList;
using Loris::PartialListIterator;
using Loris::Breakpoint;

typedef Loris::Partial::iterator PartialIterator;

/*	new iterator definitions

	These are much better than the old things, more like the 
	iterators in Python 2.2 and later, very much simpler.
	The old iterators will be replaced entirely by the new
	kind soon, very soon.
	
	Note: the only reason I cannot merge the new functionality 
	into the old iterators is that the old iterators use the
	next() method to advance and return another iterator. Duh.
*/
struct NewPlistIterator
{
	PartialList & subject;
	PartialList::iterator it;

	NewPlistIterator( PartialList & l ) : subject( l ), it ( l.begin() ) {}
	NewPlistIterator( PartialList & l, PartialList::iterator i ) : subject( l ), it ( i ) {}
	
	bool atEnd( void ) { return it == subject.end(); }
	bool hasNext( void ) { return !atEnd(); }

	Partial * next( void )
	{
		if ( atEnd() )
		{
			throw_exception("end of PartialList");
			return 0;
		}
		Partial * ret = &(*it);
		++it;
		return ret;
	}
};

typedef Partial::iterator BreakpointPosition;

struct NewPartialIterator
{
	Partial & subject;
	Partial::iterator it;

	NewPartialIterator( Partial & p ) : subject( p ), it ( p.begin() ) {}
	NewPartialIterator( Partial & p, Partial::iterator i ) : subject( p ), it ( i ) {}
	
	bool atEnd( void ) { return it == subject.end(); }
	bool hasNext( void ) { return !atEnd(); }

	BreakpointPosition * next( void )
	{
		if ( atEnd() )
		{
			throw_exception("end of Partial");
			return 0;
		}
		BreakpointPosition * ret = new BreakpointPosition(it);
		++it;
		return ret;
	}
};


static Partial *NewPlistIterator_partial(NewPlistIterator *self){
			if ( self->atEnd() )
			{
				throw_exception("end of PartialList");
				return 0;
			}			
			Partial & current = *(self->it);
			return &current;
		}

SWIGINTERN PyObject*
t_output_helper(PyObject* target, PyObject* o) {
  if (!target) {
    target = o;
  } else if (target == Py_None) {  
    Py_DECREF(target);
    target = o;
  } else {
    if (!PyList_Check(target)) {
      PyObject *o2 = target;
      target = PyList_New(1);
      PyList_SetItem(target, 0, o2);
    }
    PyList_Append(target,o);
    }
  return target;
}


static void PartialList_timeSpan(PartialList *self,double *tmin_out,double *tmax_out){
		 	std::pair<double, double> span = 
		 		Loris::PartialUtils::timeSpan( self->begin(), self->end() );
		 	*tmin_out = span.first;
		 	*tmax_out = span.second;
		 }
static NewPlistIterator *PartialList_iterator(PartialList *self){
			return new NewPlistIterator(*self);
		}
static NewPlistIterator *PartialList___iter__(PartialList *self){
			return new NewPlistIterator(*self);
		}
static void PartialList_append(PartialList *self,Partial *partial){
			self->insert( self->end(), *partial );
		}
static NewPlistIterator *PartialList_insert__SWIG_0(PartialList *self,NewPlistIterator *position,Partial *partial){
			if ( self != &(position->subject) )
				return 0;
			return new NewPlistIterator(*self, self->insert( position->it, *partial ) );
		}
static void PartialList_erase__SWIG_0(PartialList *self,Partial *partial){
			PartialList::iterator it = self->begin();
			while ( it != self->end() )
			{
				if ( &(*it) == partial )	// compare addresses
				{
					self->erase( it );
					return;
				}
				++it;
			}
			throw_exception( "PartialList.erase(p): p not in PartialList" );
		}
static void PartialList_splice__SWIG_0(PartialList *self,PartialList *other){
			self->splice( self->end(), *other );
		}
static Partial *PartialList_first(PartialList *self){
			if ( self->empty() )
			{
				return 0;
			}
			else
			{
				return &( self->front() );
			}
		}
static Partial *PartialList_last(PartialList *self){
			if ( self->empty() )
			{
				return 0;
			}
			else
			{
				return &( self->back() );
			}
		}
static PartialListIterator PartialList_insert__SWIG_2(PartialList *self,Partial const &partial){
			return self->insert( self->end(), partial );
		}
static PartialList *PartialList_copy(PartialList *self){ return new PartialList( *self ); }

  /*@/usr/local/share/swig/1.3.24/python/pymacros.swg,66,SWIG_define@*/
#define SWIG_From_long PyInt_FromLong
/*@@*/

static NewPartialIterator *Partial_iterator(Partial *self){
			return new NewPartialIterator(*self);
		}
static NewPartialIterator *Partial___iter__(Partial *self){
			return new NewPartialIterator(*self);
		}
static void Partial_erase__SWIG_0(Partial *self,BreakpointPosition *pos){
			if ( *pos != self->end() )
			{
				*pos = self->erase( *pos );
			}
		}
static Breakpoint *Partial_first(Partial *self){
            if ( self->numBreakpoints() == 0 )
            {
                return 0;
            }
            else
            {
                return &( self->first() );
            }
        }
static Breakpoint *Partial_last(Partial *self){
            if ( self->numBreakpoints() == 0 )
            {
                return 0;
            }
            else
            {
                return &( self->last() );
            }
        }
static Partial *Partial_copy(Partial *self){ return new Partial( *self ); }
static Breakpoint *Breakpoint_copy(Breakpoint *self){
			return new Breakpoint( *self );
		}
static double BreakpointPosition_time(BreakpointPosition *self){ 
			return self->time(); 
		}
static Breakpoint *BreakpointPosition_breakpoint(BreakpointPosition *self){ 
			return &(self->breakpoint());
		}
static double BreakpointPosition_frequency(BreakpointPosition *self){ return self->breakpoint().frequency(); }
static double BreakpointPosition_amplitude(BreakpointPosition *self){ return self->breakpoint().amplitude(); }
static double BreakpointPosition_bandwidth(BreakpointPosition *self){ return self->breakpoint().bandwidth(); }
static double BreakpointPosition_phase(BreakpointPosition *self){ return self->breakpoint().phase(); }
static void BreakpointPosition_setFrequency(BreakpointPosition *self,double x){ self->breakpoint().setFrequency( x ); }
static void BreakpointPosition_setAmplitude(BreakpointPosition *self,double x){ self->breakpoint().setAmplitude( x ); }
static void BreakpointPosition_setBandwidth(BreakpointPosition *self,double x){ self->breakpoint().setBandwidth( x ); }
static void BreakpointPosition_setPhase(BreakpointPosition *self,double x){ self->breakpoint().setPhase( x ); }
static Breakpoint *PartialIterator_breakpoint(PartialIterator *self){ 
			return &(self->breakpoint());
		}
static PartialIterator *PartialIterator_copy(PartialIterator *self){
			return new PartialIterator( *self );
		}
static PartialIterator *PartialIterator_next(PartialIterator *self){
			PartialIterator * next = new PartialIterator(*self);
			++(*next);
			return next;
		}
static PartialIterator *PartialIterator_prev(PartialIterator *self){
			PartialIterator * prev = new PartialIterator(*self);
			--(*prev);
			return prev;
		}
static int PartialIterator_equals(PartialIterator *self,PartialIterator *other){
			return *self == *other;
		}
static int PartialIterator_isInRange(PartialIterator *self,PartialIterator const *begin,PartialIterator const *end){	
		 	PartialIterator it;
		 	for ( it = *begin; it != *end; ++it )
		 	{
		 		if ( it == *self )
		 			return true;
		 	}
		 	return false;
		 }
static PartialListIterator *PartialListIterator_copy(PartialListIterator *self){
			return new PartialListIterator( *self );
		}
static PartialListIterator *PartialListIterator_next(PartialListIterator *self){
			PartialListIterator * next = new PartialListIterator(*self);
			++(*next);
			return next;
		}
static PartialListIterator *PartialListIterator_prev(PartialListIterator *self){
			PartialListIterator * prev = new PartialListIterator(*self);
			--(*prev);
			return prev;
		}
static Partial *PartialListIterator_partial(PartialListIterator *self){
			Partial & current = **self;
			return &current;
		}
static int PartialListIterator_equals(PartialListIterator *self,PartialListIterator *other){
			return *self == *other;
		}
static int PartialListIterator_isInRange(PartialListIterator *self,PartialListIterator const *begin,PartialListIterator const *end){	
		 	PartialListIterator it;
		 	for ( it = *begin; it != *end; ++it )
		 	{
		 		if ( it == *self )
		 			return true;
		 	}
		 	return false;
		 }
#ifdef __cplusplus
extern "C" {
#endif
static PyObject *_wrap_new_DoubleVector__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_DoubleVector")) goto fail;
    result = (std::vector<double > *)new std::vector<double >();
    
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_DoubleVector__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = 0 ;
    std::vector<double > *result;
    int res1 = 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_DoubleVector",&obj0)) goto fail;
    {
        std::vector<double,std::allocator<double > > *ptr = (std::vector<double,std::allocator<double > > *)0;
        res1 = swig::asptr(obj0, &ptr);
        if (!res1) {
            if (!PyErr_Occurred())
            SWIG_type_error("std::vector<double >", obj0);
        } else if (!ptr) {
            SWIG_null_ref("std::vector<double >");
        }
        if (SWIG_arg_fail(1)) SWIG_fail;
        arg1 = ptr;
    }
    result = (std::vector<double > *)new std::vector<double >((std::vector<double > const &)*arg1);
    
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, 1);
    if (res1 == SWIG_NEWOBJ) delete arg1;
    return resultobj;
    fail:
    if (res1 == SWIG_NEWOBJ) delete arg1;
    return NULL;
}


static PyObject *_wrap_DoubleVector_empty(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:DoubleVector_empty",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    result = (bool)((std::vector<double > const *)arg1)->empty();
    
    {
        resultobj = SWIG_From_bool((bool)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector_size(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::size_type result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:DoubleVector_size",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    result = ((std::vector<double > const *)arg1)->size();
    
    {
        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector_clear(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:DoubleVector_clear",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    (arg1)->clear();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector_swap(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double > *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:DoubleVector_swap",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (arg2 == NULL) {
            SWIG_null_ref("std::vector<double >");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    (arg1)->swap(*arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector_get_allocator(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    SwigValueWrapper<std::allocator<double > > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:DoubleVector_get_allocator",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    result = ((std::vector<double > const *)arg1)->get_allocator();
    
    {
        std::vector<double >::allocator_type * resultptr;
        resultptr = new std::vector<double >::allocator_type((std::vector<double >::allocator_type &)(result));
        resultobj = SWIG_NewPointerObj((void *)(resultptr), SWIGTYPE_p_std__allocatorTdouble_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_DoubleVector__SWIG_2(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double >::size_type arg1 ;
    std::vector<double > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_DoubleVector",&obj0)) goto fail;
    {
        arg1 = (std::vector<double >::size_type)(SWIG_As_unsigned_SS_long(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    result = (std::vector<double > *)new std::vector<double >(arg1);
    
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector_pop_back(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:DoubleVector_pop_back",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    (arg1)->pop_back();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector_resize__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::size_type arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:DoubleVector_resize",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<double >::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    (arg1)->resize(arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_DoubleVector__SWIG_3(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double >::size_type arg1 ;
    std::vector<double >::value_type *arg2 = 0 ;
    std::vector<double > *result;
    std::vector<double >::value_type temp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_DoubleVector",&obj0,&obj1)) goto fail;
    {
        arg1 = (std::vector<double >::size_type)(SWIG_As_unsigned_SS_long(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        temp2 = (std::vector<double >::value_type)(SWIG_As_double(obj1));
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = &temp2;
    }
    result = (std::vector<double > *)new std::vector<double >(arg1,(double const &)*arg2);
    
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_DoubleVector(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_DoubleVector__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        _v = SWIG_Check_unsigned_SS_long(argv[0]);
        if (_v) {
            return _wrap_new_DoubleVector__SWIG_2(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        _v = swig::asptr(argv[0], (std::vector<double,std::allocator<double > >**)(0));
        if (_v) {
            return _wrap_new_DoubleVector__SWIG_1(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        _v = SWIG_Check_unsigned_SS_long(argv[0]);
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                return _wrap_new_DoubleVector__SWIG_3(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'new_DoubleVector'");
    return NULL;
}


static PyObject *_wrap_DoubleVector_push_back(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::value_type *arg2 = 0 ;
    std::vector<double >::value_type temp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:DoubleVector_push_back",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        temp2 = (std::vector<double >::value_type)(SWIG_As_double(obj1));
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = &temp2;
    }
    (arg1)->push_back((double const &)*arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector_front(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::value_type *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:DoubleVector_front",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        std::vector<double >::value_type const &_result_ref = ((std::vector<double > const *)arg1)->front();
        result = (std::vector<double >::value_type *) &_result_ref;
    }
    
    {
        resultobj = SWIG_From_double((double)(*result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector_back(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::value_type *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:DoubleVector_back",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        std::vector<double >::value_type const &_result_ref = ((std::vector<double > const *)arg1)->back();
        result = (std::vector<double >::value_type *) &_result_ref;
    }
    
    {
        resultobj = SWIG_From_double((double)(*result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector_assign(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::size_type arg2 ;
    std::vector<double >::value_type *arg3 = 0 ;
    std::vector<double >::value_type temp3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:DoubleVector_assign",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<double >::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        temp3 = (std::vector<double >::value_type)(SWIG_As_double(obj2));
        if (SWIG_arg_fail(3)) SWIG_fail;
        arg3 = &temp3;
    }
    (arg1)->assign(arg2,(double const &)*arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector_resize__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::size_type arg2 ;
    std::vector<double >::value_type *arg3 = 0 ;
    std::vector<double >::value_type temp3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:DoubleVector_resize",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<double >::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        temp3 = (std::vector<double >::value_type)(SWIG_As_double(obj2));
        if (SWIG_arg_fail(3)) SWIG_fail;
        arg3 = &temp3;
    }
    (arg1)->resize(arg2,(double const &)*arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector_resize(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[4];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_Check_unsigned_SS_long(argv[1]);
            if (_v) {
                return _wrap_DoubleVector_resize__SWIG_0(self,args);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_Check_unsigned_SS_long(argv[1]);
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    return _wrap_DoubleVector_resize__SWIG_1(self,args);
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'DoubleVector_resize'");
    return NULL;
}


static PyObject *_wrap_DoubleVector_reserve(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::size_type arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:DoubleVector_reserve",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<double >::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    (arg1)->reserve(arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector_capacity(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::size_type result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:DoubleVector_capacity",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    result = ((std::vector<double > const *)arg1)->capacity();
    
    {
        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector___nonzero__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:DoubleVector___nonzero__",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    result = (bool)std_vector_Sl_double_Sg____nonzero__((std::vector<double > const *)arg1);
    
    {
        resultobj = SWIG_From_bool((bool)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector___len__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::size_type result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:DoubleVector___len__",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    result = std_vector_Sl_double_Sg____len__((std::vector<double > const *)arg1);
    
    {
        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector_pop(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::value_type result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:DoubleVector_pop",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try {
            result = (std::vector<double >::value_type)std_vector_Sl_double_Sg__pop(arg1);
        }
        catch (std::out_of_range& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }
        }
        /*@/usr/local/share/swig/1.3.24/exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
            SWIG_exception(SWIG_SystemError, e.what() );
        }
        catch (...) {
            SWIG_exception(SWIG_UnknownError, "unknown exception");
        }
        /*@@*/
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector___getslice__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::difference_type arg2 ;
    std::vector<double >::difference_type arg3 ;
    std::vector<double,std::allocator<double > > *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:DoubleVector___getslice__",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<double >::difference_type)(SWIG_As_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (std::vector<double >::difference_type)(SWIG_As_long(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try {
            result = (std::vector<double,std::allocator<double > > *)std_vector_Sl_double_Sg____getslice__(arg1,arg2,arg3);
        }
        catch (std::out_of_range& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }
        }
        /*@/usr/local/share/swig/1.3.24/exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
            SWIG_exception(SWIG_SystemError, e.what() );
        }
        catch (...) {
            SWIG_exception(SWIG_UnknownError, "unknown exception");
        }
        /*@@*/
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector___setslice__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::difference_type arg2 ;
    std::vector<double >::difference_type arg3 ;
    std::vector<double,std::allocator<double > > *arg4 = 0 ;
    int res4 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:DoubleVector___setslice__",&obj0,&obj1,&obj2,&obj3)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<double >::difference_type)(SWIG_As_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (std::vector<double >::difference_type)(SWIG_As_long(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        std::vector<double,std::allocator<double > > *ptr = (std::vector<double,std::allocator<double > > *)0;
        res4 = swig::asptr(obj3, &ptr);
        if (!res4) {
            if (!PyErr_Occurred())
            SWIG_type_error("std::vector<double,std::allocator<double > >", obj3);
        } else if (!ptr) {
            SWIG_null_ref("std::vector<double,std::allocator<double > >");
        }
        if (SWIG_arg_fail(4)) SWIG_fail;
        arg4 = ptr;
    }
    {
        try {
            std_vector_Sl_double_Sg____setslice__(arg1,arg2,arg3,(std::vector<double,std::allocator<double > > const &)*arg4);
        }
        catch (std::out_of_range& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }
        }
        catch (std::invalid_argument& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_TypeError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }      
        }
        /*@/usr/local/share/swig/1.3.24/exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
            SWIG_exception(SWIG_SystemError, e.what() );
        }
        catch (...) {
            SWIG_exception(SWIG_UnknownError, "unknown exception");
        }
        /*@@*/
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    if (res4 == SWIG_NEWOBJ) delete arg4;
    return resultobj;
    fail:
    if (res4 == SWIG_NEWOBJ) delete arg4;
    return NULL;
}


static PyObject *_wrap_DoubleVector___delslice__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::difference_type arg2 ;
    std::vector<double >::difference_type arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:DoubleVector___delslice__",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<double >::difference_type)(SWIG_As_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (std::vector<double >::difference_type)(SWIG_As_long(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try {
            std_vector_Sl_double_Sg____delslice__(arg1,arg2,arg3);
        }
        catch (std::out_of_range& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }
        }
        /*@/usr/local/share/swig/1.3.24/exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
            SWIG_exception(SWIG_SystemError, e.what() );
        }
        catch (...) {
            SWIG_exception(SWIG_UnknownError, "unknown exception");
        }
        /*@@*/
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector___delitem__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::difference_type arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:DoubleVector___delitem__",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<double >::difference_type)(SWIG_As_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try {
            std_vector_Sl_double_Sg____delitem__(arg1,arg2);
        }
        catch (std::out_of_range& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }
        }
        /*@/usr/local/share/swig/1.3.24/exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
            SWIG_exception(SWIG_SystemError, e.what() );
        }
        catch (...) {
            SWIG_exception(SWIG_UnknownError, "unknown exception");
        }
        /*@@*/
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector___getitem__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::difference_type arg2 ;
    std::vector<double >::value_type *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:DoubleVector___getitem__",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<double >::difference_type)(SWIG_As_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try {
            {
                std::vector<double >::value_type const &_result_ref = std_vector_Sl_double_Sg____getitem__((std::vector<double > const *)arg1,arg2);
                result = (std::vector<double >::value_type *) &_result_ref;
            }
        }
        catch (std::out_of_range& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }
        }
        /*@/usr/local/share/swig/1.3.24/exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
            SWIG_exception(SWIG_SystemError, e.what() );
        }
        catch (...) {
            SWIG_exception(SWIG_UnknownError, "unknown exception");
        }
        /*@@*/
    }
    {
        resultobj = SWIG_From_double((double)(*result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector___setitem__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::difference_type arg2 ;
    std::vector<double >::value_type *arg3 = 0 ;
    std::vector<double >::value_type temp3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:DoubleVector___setitem__",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<double >::difference_type)(SWIG_As_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        temp3 = (std::vector<double >::value_type)(SWIG_As_double(obj2));
        if (SWIG_arg_fail(3)) SWIG_fail;
        arg3 = &temp3;
    }
    {
        try {
            std_vector_Sl_double_Sg____setitem__(arg1,arg2,(double const &)*arg3);
        }
        catch (std::out_of_range& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }
        }
        /*@/usr/local/share/swig/1.3.24/exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
            SWIG_exception(SWIG_SystemError, e.what() );
        }
        catch (...) {
            SWIG_exception(SWIG_UnknownError, "unknown exception");
        }
        /*@@*/
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleVector_append(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    std::vector<double >::value_type *arg2 = 0 ;
    std::vector<double >::value_type temp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:DoubleVector_append",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        temp2 = (std::vector<double >::value_type)(SWIG_As_double(obj1));
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = &temp2;
    }
    std_vector_Sl_double_Sg__append(arg1,(double const &)*arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_DoubleVector(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = (std::vector<double > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_DoubleVector",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * DoubleVector_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTdouble_std__allocatorTdouble_t_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_MarkerVector__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_MarkerVector")) goto fail;
    result = (std::vector<Marker > *)new std::vector<Marker >();
    
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_MarkerVector__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = 0 ;
    std::vector<Marker > *result;
    int res1 = 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_MarkerVector",&obj0)) goto fail;
    {
        std::vector<Marker,std::allocator<Marker > > *ptr = (std::vector<Marker,std::allocator<Marker > > *)0;
        res1 = swig::asptr(obj0, &ptr);
        if (!res1) {
            if (!PyErr_Occurred())
            SWIG_type_error("std::vector<Marker >", obj0);
        } else if (!ptr) {
            SWIG_null_ref("std::vector<Marker >");
        }
        if (SWIG_arg_fail(1)) SWIG_fail;
        arg1 = ptr;
    }
    result = (std::vector<Marker > *)new std::vector<Marker >((std::vector<Marker > const &)*arg1);
    
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, 1);
    if (res1 == SWIG_NEWOBJ) delete arg1;
    return resultobj;
    fail:
    if (res1 == SWIG_NEWOBJ) delete arg1;
    return NULL;
}


static PyObject *_wrap_MarkerVector_empty(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:MarkerVector_empty",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    result = (bool)((std::vector<Marker > const *)arg1)->empty();
    
    {
        resultobj = SWIG_From_bool((bool)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector_size(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::size_type result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:MarkerVector_size",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    result = ((std::vector<Marker > const *)arg1)->size();
    
    {
        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector_clear(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:MarkerVector_clear",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    (arg1)->clear();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector_swap(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker > *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:MarkerVector_swap",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (arg2 == NULL) {
            SWIG_null_ref("std::vector<Marker >");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    (arg1)->swap(*arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector_get_allocator(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    SwigValueWrapper<std::allocator<Marker > > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:MarkerVector_get_allocator",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    result = ((std::vector<Marker > const *)arg1)->get_allocator();
    
    {
        std::vector<Marker >::allocator_type * resultptr;
        resultptr = new std::vector<Marker >::allocator_type((std::vector<Marker >::allocator_type &)(result));
        resultobj = SWIG_NewPointerObj((void *)(resultptr), SWIGTYPE_p_std__allocatorTMarker_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_MarkerVector__SWIG_2(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker >::size_type arg1 ;
    std::vector<Marker > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_MarkerVector",&obj0)) goto fail;
    {
        arg1 = (std::vector<Marker >::size_type)(SWIG_As_unsigned_SS_long(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    result = (std::vector<Marker > *)new std::vector<Marker >(arg1);
    
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector_pop_back(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:MarkerVector_pop_back",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    (arg1)->pop_back();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector_resize__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::size_type arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:MarkerVector_resize",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<Marker >::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    (arg1)->resize(arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_MarkerVector__SWIG_3(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker >::size_type arg1 ;
    std::vector<Marker >::value_type *arg2 = 0 ;
    std::vector<Marker > *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_MarkerVector",&obj0,&obj1)) goto fail;
    {
        arg1 = (std::vector<Marker >::size_type)(SWIG_As_unsigned_SS_long(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_Marker, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (arg2 == NULL) {
            SWIG_null_ref("std::vector<Marker >::value_type");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    result = (std::vector<Marker > *)new std::vector<Marker >(arg1,(Marker const &)*arg2);
    
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_MarkerVector(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_MarkerVector__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        _v = SWIG_Check_unsigned_SS_long(argv[0]);
        if (_v) {
            return _wrap_new_MarkerVector__SWIG_2(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        _v = swig::asptr(argv[0], (std::vector<Marker,std::allocator<Marker > >**)(0));
        if (_v) {
            return _wrap_new_MarkerVector__SWIG_1(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        _v = SWIG_Check_unsigned_SS_long(argv[0]);
        if (_v) {
            {
                void *ptr = 0;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Marker, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = (ptr != 0);
                }
            }
            if (_v) {
                return _wrap_new_MarkerVector__SWIG_3(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'new_MarkerVector'");
    return NULL;
}


static PyObject *_wrap_MarkerVector_push_back(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::value_type *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:MarkerVector_push_back",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_Marker, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (arg2 == NULL) {
            SWIG_null_ref("std::vector<Marker >::value_type");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    (arg1)->push_back((Marker const &)*arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector_front(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::value_type *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:MarkerVector_front",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        std::vector<Marker >::value_type const &_result_ref = ((std::vector<Marker > const *)arg1)->front();
        result = (std::vector<Marker >::value_type *) &_result_ref;
    }
    
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Marker, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector_back(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::value_type *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:MarkerVector_back",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        std::vector<Marker >::value_type const &_result_ref = ((std::vector<Marker > const *)arg1)->back();
        result = (std::vector<Marker >::value_type *) &_result_ref;
    }
    
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Marker, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector_assign(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::size_type arg2 ;
    std::vector<Marker >::value_type *arg3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:MarkerVector_assign",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<Marker >::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        SWIG_Python_ConvertPtr(obj2, (void **)&arg3, SWIGTYPE_p_Marker, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(3)) SWIG_fail;
        if (arg3 == NULL) {
            SWIG_null_ref("std::vector<Marker >::value_type");
        }
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    (arg1)->assign(arg2,(Marker const &)*arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector_resize__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::size_type arg2 ;
    std::vector<Marker >::value_type *arg3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:MarkerVector_resize",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<Marker >::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        SWIG_Python_ConvertPtr(obj2, (void **)&arg3, SWIGTYPE_p_Marker, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(3)) SWIG_fail;
        if (arg3 == NULL) {
            SWIG_null_ref("std::vector<Marker >::value_type");
        }
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    (arg1)->resize(arg2,(Marker const &)*arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector_resize(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[4];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_Check_unsigned_SS_long(argv[1]);
            if (_v) {
                return _wrap_MarkerVector_resize__SWIG_0(self,args);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_Check_unsigned_SS_long(argv[1]);
            if (_v) {
                {
                    void *ptr = 0;
                    if (SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_Marker, 0) == -1) {
                        _v = 0;
                        PyErr_Clear();
                    } else {
                        _v = (ptr != 0);
                    }
                }
                if (_v) {
                    return _wrap_MarkerVector_resize__SWIG_1(self,args);
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'MarkerVector_resize'");
    return NULL;
}


static PyObject *_wrap_MarkerVector_reserve(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::size_type arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:MarkerVector_reserve",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<Marker >::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    (arg1)->reserve(arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector_capacity(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::size_type result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:MarkerVector_capacity",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    result = ((std::vector<Marker > const *)arg1)->capacity();
    
    {
        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector___nonzero__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:MarkerVector___nonzero__",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    result = (bool)std_vector_Sl_Marker_Sg____nonzero__((std::vector<Marker > const *)arg1);
    
    {
        resultobj = SWIG_From_bool((bool)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector___len__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::size_type result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:MarkerVector___len__",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    result = std_vector_Sl_Marker_Sg____len__((std::vector<Marker > const *)arg1);
    
    {
        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector_pop(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::value_type result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:MarkerVector_pop",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try {
            result = std_vector_Sl_Marker_Sg__pop(arg1);
        }
        catch (std::out_of_range& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }
        }
        /*@/usr/local/share/swig/1.3.24/exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
            SWIG_exception(SWIG_SystemError, e.what() );
        }
        catch (...) {
            SWIG_exception(SWIG_UnknownError, "unknown exception");
        }
        /*@@*/
    }
    {
        std::vector<Marker >::value_type * resultptr;
        resultptr = new std::vector<Marker >::value_type((std::vector<Marker >::value_type &)(result));
        resultobj = SWIG_NewPointerObj((void *)(resultptr), SWIGTYPE_p_Marker, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector___getslice__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::difference_type arg2 ;
    std::vector<Marker >::difference_type arg3 ;
    std::vector<Marker,std::allocator<Marker > > *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:MarkerVector___getslice__",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<Marker >::difference_type)(SWIG_As_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (std::vector<Marker >::difference_type)(SWIG_As_long(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try {
            result = (std::vector<Marker,std::allocator<Marker > > *)std_vector_Sl_Marker_Sg____getslice__(arg1,arg2,arg3);
        }
        catch (std::out_of_range& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }
        }
        /*@/usr/local/share/swig/1.3.24/exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
            SWIG_exception(SWIG_SystemError, e.what() );
        }
        catch (...) {
            SWIG_exception(SWIG_UnknownError, "unknown exception");
        }
        /*@@*/
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector___setslice__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::difference_type arg2 ;
    std::vector<Marker >::difference_type arg3 ;
    std::vector<Marker,std::allocator<Marker > > *arg4 = 0 ;
    int res4 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:MarkerVector___setslice__",&obj0,&obj1,&obj2,&obj3)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<Marker >::difference_type)(SWIG_As_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (std::vector<Marker >::difference_type)(SWIG_As_long(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        std::vector<Marker,std::allocator<Marker > > *ptr = (std::vector<Marker,std::allocator<Marker > > *)0;
        res4 = swig::asptr(obj3, &ptr);
        if (!res4) {
            if (!PyErr_Occurred())
            SWIG_type_error("std::vector<Marker,std::allocator<Marker > >", obj3);
        } else if (!ptr) {
            SWIG_null_ref("std::vector<Marker,std::allocator<Marker > >");
        }
        if (SWIG_arg_fail(4)) SWIG_fail;
        arg4 = ptr;
    }
    {
        try {
            std_vector_Sl_Marker_Sg____setslice__(arg1,arg2,arg3,(std::vector<Marker,std::allocator<Marker > > const &)*arg4);
        }
        catch (std::out_of_range& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }
        }
        catch (std::invalid_argument& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_TypeError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }      
        }
        /*@/usr/local/share/swig/1.3.24/exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
            SWIG_exception(SWIG_SystemError, e.what() );
        }
        catch (...) {
            SWIG_exception(SWIG_UnknownError, "unknown exception");
        }
        /*@@*/
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    if (res4 == SWIG_NEWOBJ) delete arg4;
    return resultobj;
    fail:
    if (res4 == SWIG_NEWOBJ) delete arg4;
    return NULL;
}


static PyObject *_wrap_MarkerVector___delslice__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::difference_type arg2 ;
    std::vector<Marker >::difference_type arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:MarkerVector___delslice__",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<Marker >::difference_type)(SWIG_As_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (std::vector<Marker >::difference_type)(SWIG_As_long(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try {
            std_vector_Sl_Marker_Sg____delslice__(arg1,arg2,arg3);
        }
        catch (std::out_of_range& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }
        }
        /*@/usr/local/share/swig/1.3.24/exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
            SWIG_exception(SWIG_SystemError, e.what() );
        }
        catch (...) {
            SWIG_exception(SWIG_UnknownError, "unknown exception");
        }
        /*@@*/
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector___delitem__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::difference_type arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:MarkerVector___delitem__",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<Marker >::difference_type)(SWIG_As_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try {
            std_vector_Sl_Marker_Sg____delitem__(arg1,arg2);
        }
        catch (std::out_of_range& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }
        }
        /*@/usr/local/share/swig/1.3.24/exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
            SWIG_exception(SWIG_SystemError, e.what() );
        }
        catch (...) {
            SWIG_exception(SWIG_UnknownError, "unknown exception");
        }
        /*@@*/
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector___getitem__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::difference_type arg2 ;
    std::vector<Marker >::value_type *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:MarkerVector___getitem__",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<Marker >::difference_type)(SWIG_As_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try {
            {
                std::vector<Marker >::value_type const &_result_ref = std_vector_Sl_Marker_Sg____getitem__((std::vector<Marker > const *)arg1,arg2);
                result = (std::vector<Marker >::value_type *) &_result_ref;
            }
        }
        catch (std::out_of_range& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }
        }
        /*@/usr/local/share/swig/1.3.24/exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
            SWIG_exception(SWIG_SystemError, e.what() );
        }
        catch (...) {
            SWIG_exception(SWIG_UnknownError, "unknown exception");
        }
        /*@@*/
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Marker, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector___setitem__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::difference_type arg2 ;
    std::vector<Marker >::value_type *arg3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:MarkerVector___setitem__",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (std::vector<Marker >::difference_type)(SWIG_As_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        SWIG_Python_ConvertPtr(obj2, (void **)&arg3, SWIGTYPE_p_Marker, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(3)) SWIG_fail;
        if (arg3 == NULL) {
            SWIG_null_ref("std::vector<Marker >::value_type");
        }
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try {
            std_vector_Sl_Marker_Sg____setitem__(arg1,arg2,(Marker const &)*arg3);
        }
        catch (std::out_of_range& e) {
            if (!PyErr_Occurred()) {
                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
            } else {
                SWIG_fail;
            }
        }
        /*@/usr/local/share/swig/1.3.24/exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
            SWIG_exception(SWIG_SystemError, e.what() );
        }
        catch (...) {
            SWIG_exception(SWIG_UnknownError, "unknown exception");
        }
        /*@@*/
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MarkerVector_append(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    std::vector<Marker >::value_type *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:MarkerVector_append",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_Marker, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (arg2 == NULL) {
            SWIG_null_ref("std::vector<Marker >::value_type");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    std_vector_Sl_Marker_Sg__append(arg1,(Marker const &)*arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_MarkerVector(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<Marker > *arg1 = (std::vector<Marker > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_MarkerVector",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * MarkerVector_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTMarker_std__allocatorTMarker_t_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_channelize(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:channelize",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_BreakpointEnvelope, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        arg3 = (int)(SWIG_As_int(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        channelize(arg1,arg2,arg3);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createFreqReference__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    double arg3 ;
    long arg4 ;
    BreakpointEnvelope *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:createFreqReference",&obj0,&obj1,&obj2,&obj3)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        arg4 = (long)(SWIG_As_long(obj3)); 
        if (SWIG_arg_fail(4)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        result = (BreakpointEnvelope *)createFreqReference(arg1,arg2,arg3,arg4);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_BreakpointEnvelope, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createFreqReference__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    double arg3 ;
    BreakpointEnvelope *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:createFreqReference",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        result = (BreakpointEnvelope *)createFreqReference(arg1,arg2,arg3);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_BreakpointEnvelope, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createFreqReference(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[5];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    return _wrap_createFreqReference__SWIG_1(self,args);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    _v = SWIG_Check_long(argv[3]);
                    if (_v) {
                        return _wrap_createFreqReference__SWIG_0(self,args);
                    }
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'createFreqReference'");
    return NULL;
}


static PyObject *_wrap_dilate(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    std::vector<double > *arg2 = 0 ;
    std::vector<double > *arg3 = 0 ;
    int res2 = 0 ;
    int res3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:dilate",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        std::vector<double,std::allocator<double > > *ptr = (std::vector<double,std::allocator<double > > *)0;
        res2 = swig::asptr(obj1, &ptr);
        if (!res2) {
            if (!PyErr_Occurred())
            SWIG_type_error("std::vector<double >", obj1);
        } else if (!ptr) {
            SWIG_null_ref("std::vector<double >");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = ptr;
    }
    {
        std::vector<double,std::allocator<double > > *ptr = (std::vector<double,std::allocator<double > > *)0;
        res3 = swig::asptr(obj2, &ptr);
        if (!res3) {
            if (!PyErr_Occurred())
            SWIG_type_error("std::vector<double >", obj2);
        } else if (!ptr) {
            SWIG_null_ref("std::vector<double >");
        }
        if (SWIG_arg_fail(3)) SWIG_fail;
        arg3 = ptr;
    }
    SWIG_contract_assert((arg2->size()==arg3->size()), "Contract violation: require: (arg2->size()==arg3->size())");
    
    {
        char * err;
        clear_exception();
        dilate(arg1,(std::vector<double > const &)*arg2,(std::vector<double > const &)*arg3);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    if (res2 == SWIG_NEWOBJ) delete arg2;
    if (res3 == SWIG_NEWOBJ) delete arg3;
    return resultobj;
    fail:
    if (res2 == SWIG_NEWOBJ) delete arg2;
    if (res3 == SWIG_NEWOBJ) delete arg3;
    return NULL;
}


static PyObject *_wrap_distill(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:distill",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        char * err;
        clear_exception();
        distill(arg1);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_exportAiff__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    char *arg1 = (char *) 0 ;
    std::vector<double > *arg2 = 0 ;
    double arg3 ;
    int arg4 ;
    int res2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:exportAiff",&obj0,&obj1,&obj2,&obj3)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) {
        SWIG_arg_fail(1);SWIG_fail;
    }
    {
        std::vector<double,std::allocator<double > > *ptr = (std::vector<double,std::allocator<double > > *)0;
        res2 = swig::asptr(obj1, &ptr);
        if (!res2) {
            if (!PyErr_Occurred())
            SWIG_type_error("std::vector<double >", obj1);
        } else if (!ptr) {
            SWIG_null_ref("std::vector<double >");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = ptr;
    }
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        arg4 = (int)(SWIG_As_int(obj3)); 
        if (SWIG_arg_fail(4)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        exportAiff((char const *)arg1,(std::vector<double > const &)*arg2,arg3,arg4);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return resultobj;
    fail:
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return NULL;
}


static PyObject *_wrap_exportAiff__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    char *arg1 = (char *) 0 ;
    std::vector<double > *arg2 = 0 ;
    double arg3 ;
    int res2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:exportAiff",&obj0,&obj1,&obj2)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) {
        SWIG_arg_fail(1);SWIG_fail;
    }
    {
        std::vector<double,std::allocator<double > > *ptr = (std::vector<double,std::allocator<double > > *)0;
        res2 = swig::asptr(obj1, &ptr);
        if (!res2) {
            if (!PyErr_Occurred())
            SWIG_type_error("std::vector<double >", obj1);
        } else if (!ptr) {
            SWIG_null_ref("std::vector<double >");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = ptr;
    }
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        exportAiff((char const *)arg1,(std::vector<double > const &)*arg2,arg3);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return resultobj;
    fail:
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return NULL;
}


static PyObject *_wrap_exportAiff__SWIG_2(PyObject *, PyObject *args) {
    PyObject *resultobj;
    char *arg1 = (char *) 0 ;
    std::vector<double > *arg2 = 0 ;
    int res2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:exportAiff",&obj0,&obj1)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) {
        SWIG_arg_fail(1);SWIG_fail;
    }
    {
        std::vector<double,std::allocator<double > > *ptr = (std::vector<double,std::allocator<double > > *)0;
        res2 = swig::asptr(obj1, &ptr);
        if (!res2) {
            if (!PyErr_Occurred())
            SWIG_type_error("std::vector<double >", obj1);
        } else if (!ptr) {
            SWIG_null_ref("std::vector<double >");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = ptr;
    }
    {
        char * err;
        clear_exception();
        exportAiff((char const *)arg1,(std::vector<double > const &)*arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return resultobj;
    fail:
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return NULL;
}


static PyObject *_wrap_exportAiff(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[5];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        _v = SWIG_AsCharPtr(argv[0], (char **)(0));
        if (_v) {
            _v = swig::asptr(argv[1], (std::vector<double,std::allocator<double > >**)(0));
            if (_v) {
                return _wrap_exportAiff__SWIG_2(self,args);
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = SWIG_AsCharPtr(argv[0], (char **)(0));
        if (_v) {
            _v = swig::asptr(argv[1], (std::vector<double,std::allocator<double > >**)(0));
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    return _wrap_exportAiff__SWIG_1(self,args);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = SWIG_AsCharPtr(argv[0], (char **)(0));
        if (_v) {
            _v = swig::asptr(argv[1], (std::vector<double,std::allocator<double > >**)(0));
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    _v = SWIG_Check_int(argv[3]);
                    if (_v) {
                        return _wrap_exportAiff__SWIG_0(self,args);
                    }
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'exportAiff'");
    return NULL;
}


static PyObject *_wrap_exportSdif(PyObject *, PyObject *args) {
    PyObject *resultobj;
    char *arg1 = (char *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:exportSdif",&obj0,&obj1)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) {
        SWIG_arg_fail(1);SWIG_fail;
    }
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        char * err;
        clear_exception();
        exportSdif((char const *)arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_exportSpc__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    char *arg1 = (char *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    double arg3 ;
    int arg4 ;
    double arg5 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:exportSpc",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) {
        SWIG_arg_fail(1);SWIG_fail;
    }
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        arg4 = (int)(SWIG_As_int(obj3)); 
        if (SWIG_arg_fail(4)) SWIG_fail;
    }
    {
        arg5 = (double)(SWIG_As_double(obj4)); 
        if (SWIG_arg_fail(5)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        exportSpc((char const *)arg1,arg2,arg3,arg4,arg5);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_exportSpc__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    char *arg1 = (char *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    double arg3 ;
    int arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:exportSpc",&obj0,&obj1,&obj2,&obj3)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) {
        SWIG_arg_fail(1);SWIG_fail;
    }
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        arg4 = (int)(SWIG_As_int(obj3)); 
        if (SWIG_arg_fail(4)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        exportSpc((char const *)arg1,arg2,arg3,arg4);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_exportSpc__SWIG_2(PyObject *, PyObject *args) {
    PyObject *resultobj;
    char *arg1 = (char *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    double arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:exportSpc",&obj0,&obj1,&obj2)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) {
        SWIG_arg_fail(1);SWIG_fail;
    }
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        exportSpc((char const *)arg1,arg2,arg3);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_exportSpc(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[6];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 3) {
        int _v;
        _v = SWIG_AsCharPtr(argv[0], (char **)(0));
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    return _wrap_exportSpc__SWIG_2(self,args);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = SWIG_AsCharPtr(argv[0], (char **)(0));
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    _v = SWIG_Check_int(argv[3]);
                    if (_v) {
                        return _wrap_exportSpc__SWIG_1(self,args);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        _v = SWIG_AsCharPtr(argv[0], (char **)(0));
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    _v = SWIG_Check_int(argv[3]);
                    if (_v) {
                        _v = SWIG_Check_double(argv[4]);
                        if (_v) {
                            return _wrap_exportSpc__SWIG_0(self,args);
                        }
                    }
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'exportSpc'");
    return NULL;
}


static PyObject *_wrap_importSdif(PyObject *, PyObject *args) {
    PyObject *resultobj;
    char *arg1 = (char *) 0 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:importSdif",&obj0)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) {
        SWIG_arg_fail(1);SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        result = (PartialList *)importSdif((char const *)arg1);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_importSpc(PyObject *, PyObject *args) {
    PyObject *resultobj;
    char *arg1 = (char *) 0 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:importSpc",&obj0)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) {
        SWIG_arg_fail(1);SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        result = (PartialList *)importSpc((char const *)arg1);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_morph__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    BreakpointEnvelope *arg3 = (BreakpointEnvelope *) 0 ;
    BreakpointEnvelope *arg4 = (BreakpointEnvelope *) 0 ;
    BreakpointEnvelope *arg5 = (BreakpointEnvelope *) 0 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:morph",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj2, (void **)&arg3, SWIGTYPE_p_BreakpointEnvelope, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(3)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj3, (void **)&arg4, SWIGTYPE_p_BreakpointEnvelope, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(4)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj4, (void **)&arg5, SWIGTYPE_p_BreakpointEnvelope, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(5)) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (PartialList *)morph((PartialList const *)arg1,(PartialList const *)arg2,(BreakpointEnvelope const *)arg3,(BreakpointEnvelope const *)arg4,(BreakpointEnvelope const *)arg5);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_morph__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    double arg3 ;
    double arg4 ;
    double arg5 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:morph",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        arg4 = (double)(SWIG_As_double(obj3)); 
        if (SWIG_arg_fail(4)) SWIG_fail;
    }
    {
        arg5 = (double)(SWIG_As_double(obj4)); 
        if (SWIG_arg_fail(5)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        result = (PartialList *)morph((PartialList const *)arg1,(PartialList const *)arg2,arg3,arg4,arg5);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_morph(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[6];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                        _v = 0;
                        PyErr_Clear();
                    } else {
                        _v = 1;
                    }
                }
                if (_v) {
                    {
                        void *ptr;
                        if (SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                            _v = 0;
                            PyErr_Clear();
                        } else {
                            _v = 1;
                        }
                    }
                    if (_v) {
                        {
                            void *ptr;
                            if (SWIG_ConvertPtr(argv[4], &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                                _v = 0;
                                PyErr_Clear();
                            } else {
                                _v = 1;
                            }
                        }
                        if (_v) {
                            return _wrap_morph__SWIG_0(self,args);
                        }
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    _v = SWIG_Check_double(argv[3]);
                    if (_v) {
                        _v = SWIG_Check_double(argv[4]);
                        if (_v) {
                            return _wrap_morph__SWIG_1(self,args);
                        }
                    }
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'morph'");
    return NULL;
}


static PyObject *_wrap_synthesize__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    std::vector<double > result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:synthesize",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        result = synthesize((PartialList const *)arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    {
        resultobj = swig::from((std::vector<double,std::allocator<double > >)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_synthesize__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    std::vector<double > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:synthesize",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = synthesize((PartialList const *)arg1);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    {
        resultobj = swig::from((std::vector<double,std::allocator<double > >)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_synthesize(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_synthesize__SWIG_1(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                return _wrap_synthesize__SWIG_0(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'synthesize'");
    return NULL;
}


static PyObject *_wrap_crop(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    double arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:crop",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        crop(arg1,arg2,arg3);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_copyLabeled(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    long arg2 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:copyLabeled",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (long)(SWIG_As_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        result = (PartialList *)copyLabeled(arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_extractLabeled(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    long arg2 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:extractLabeled",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (long)(SWIG_As_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        result = (PartialList *)extractLabeled(arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_removeLabeled(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    long arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:removeLabeled",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (long)(SWIG_As_long(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        removeLabeled(arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_resample(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:resample",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        resample(arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleAmp__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleAmp",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_BreakpointEnvelope, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        char * err;
        clear_exception();
        scaleAmp(arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleBandwidth__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleBandwidth",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_BreakpointEnvelope, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        char * err;
        clear_exception();
        scaleBandwidth(arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleFrequency__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleFrequency",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_BreakpointEnvelope, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        char * err;
        clear_exception();
        scaleFrequency(arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleNoiseRatio__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleNoiseRatio",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_BreakpointEnvelope, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        char * err;
        clear_exception();
        scaleNoiseRatio(arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_shiftPitch__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:shiftPitch",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_BreakpointEnvelope, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        char * err;
        clear_exception();
        shiftPitch(arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleAmp__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleAmp",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        scaleAmp(arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleAmp(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_scaleAmp__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                return _wrap_scaleAmp__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'scaleAmp'");
    return NULL;
}


static PyObject *_wrap_scaleBandwidth__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleBandwidth",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        scaleBandwidth(arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleBandwidth(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_scaleBandwidth__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                return _wrap_scaleBandwidth__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'scaleBandwidth'");
    return NULL;
}


static PyObject *_wrap_scaleFrequency__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleFrequency",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        scaleFrequency(arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleFrequency(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_scaleFrequency__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                return _wrap_scaleFrequency__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'scaleFrequency'");
    return NULL;
}


static PyObject *_wrap_scaleNoiseRatio__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleNoiseRatio",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        scaleNoiseRatio(arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleNoiseRatio(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_scaleNoiseRatio__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                return _wrap_scaleNoiseRatio__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'scaleNoiseRatio'");
    return NULL;
}


static PyObject *_wrap_shiftPitch__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:shiftPitch",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        shiftPitch(arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_shiftPitch(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_shiftPitch__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                return _wrap_shiftPitch__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'shiftPitch'");
    return NULL;
}


static PyObject *_wrap_shiftTime(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:shiftTime",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        char * err;
        clear_exception();
        shiftTime(arg1,arg2);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_sift(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:sift",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        char * err;
        clear_exception();
        sift(arg1);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_sortByLabel(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:sortByLabel",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        char * err;
        clear_exception();
        sortByLabel(arg1);
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_version(PyObject *, PyObject *args) {
    PyObject *resultobj;
    char *result;
    
    if(!PyArg_ParseTuple(args,(char *)":version")) goto fail;
    {
        char * err;
        clear_exception();
        result = (char *)version();
        
        if ( 0 != (err = check_exception()) )
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_FromCharPtr(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Marker__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Marker *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_Marker")) goto fail;
    {
        try
        {
            result = (Marker *)new Marker();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Marker, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Marker__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    char *arg2 = (char *) 0 ;
    Marker *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_Marker",&obj0,&obj1)) goto fail;
    {
        arg1 = (double)(SWIG_As_double(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    if (!SWIG_AsCharPtr(obj1, (char**)&arg2)) {
        SWIG_arg_fail(2);SWIG_fail;
    }
    {
        try
        {
            result = (Marker *)new Marker(arg1,(char const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Marker, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Marker__SWIG_2(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Marker *arg1 = 0 ;
    Marker *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_Marker",&obj0)) goto fail;
    {
        SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Marker, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(1)) SWIG_fail;
        if (arg1 == NULL) {
            SWIG_null_ref("Marker");
        }
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        try
        {
            result = (Marker *)new Marker((Marker const &)*arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Marker, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Marker(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_Marker__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr = 0;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Marker, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = (ptr != 0);
            }
        }
        if (_v) {
            return _wrap_new_Marker__SWIG_2(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        _v = SWIG_Check_double(argv[0]);
        if (_v) {
            _v = SWIG_AsCharPtr(argv[1], (char **)(0));
            if (_v) {
                return _wrap_new_Marker__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'new_Marker'");
    return NULL;
}


static PyObject *_wrap_Marker_name(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Marker *arg1 = (Marker *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Marker_name",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Marker, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (char *)Marker_name(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_FromCharPtr(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Marker_time(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Marker *arg1 = (Marker *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Marker_time",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Marker, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->time();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Marker_setName(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Marker *arg1 = (Marker *) 0 ;
    char *arg2 = (char *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Marker_setName",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Marker, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj1, (char**)&arg2)) {
        SWIG_arg_fail(2);SWIG_fail;
    }
    {
        try
        {
            (arg1)->setName((char const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Marker_setTime(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Marker *arg1 = (Marker *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Marker_setTime",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Marker, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setTime(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_Marker(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Marker *arg1 = (Marker *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Marker",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Marker, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * Marker_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_Marker, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_AiffFile__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    char *arg1 = (char *) 0 ;
    AiffFile *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_AiffFile",&obj0)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) {
        SWIG_arg_fail(1);SWIG_fail;
    }
    {
        try
        {
            result = (AiffFile *)new AiffFile((char const *)arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_AiffFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_AiffFile__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    std::vector<double > *arg1 = 0 ;
    double arg2 ;
    AiffFile *result;
    int res1 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_AiffFile",&obj0,&obj1)) goto fail;
    {
        std::vector<double,std::allocator<double > > *ptr = (std::vector<double,std::allocator<double > > *)0;
        res1 = swig::asptr(obj0, &ptr);
        if (!res1) {
            if (!PyErr_Occurred())
            SWIG_type_error("std::vector<double >", obj0);
        } else if (!ptr) {
            SWIG_null_ref("std::vector<double >");
        }
        if (SWIG_arg_fail(1)) SWIG_fail;
        arg1 = ptr;
    }
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            result = (AiffFile *)new AiffFile((std::vector<double > const &)*arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_AiffFile, 1);
    if (res1 == SWIG_NEWOBJ) delete arg1;
    return resultobj;
    fail:
    if (res1 == SWIG_NEWOBJ) delete arg1;
    return NULL;
}


static PyObject *_wrap_delete_AiffFile(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_AiffFile",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_sampleRate(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_sampleRate",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)((AiffFile const *)arg1)->sampleRate();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_midiNoteNumber(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_midiNoteNumber",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)((AiffFile const *)arg1)->midiNoteNumber();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_sampleFrames(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    unsigned long result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_sampleFrames",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (unsigned long)((AiffFile const *)arg1)->numFrames();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_addPartial__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    Loris::Partial *arg2 = 0 ;
    double arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:AiffFile_addPartial",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_Loris__Partial, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (arg2 == NULL) {
            SWIG_null_ref("Loris::Partial");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->addPartial((Loris::Partial const &)*arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_addPartial__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    Loris::Partial *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:AiffFile_addPartial",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_Loris__Partial, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (arg2 == NULL) {
            SWIG_null_ref("Loris::Partial");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->addPartial((Loris::Partial const &)*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_addPartial(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[4];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AiffFile, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr = 0;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Loris__Partial, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = (ptr != 0);
                }
            }
            if (_v) {
                return _wrap_AiffFile_addPartial__SWIG_1(self,args);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AiffFile, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr = 0;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Loris__Partial, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = (ptr != 0);
                }
            }
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    return _wrap_AiffFile_addPartial__SWIG_0(self,args);
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'AiffFile_addPartial'");
    return NULL;
}


static PyObject *_wrap_AiffFile_setMidiNoteNumber(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:AiffFile_setMidiNoteNumber",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setMidiNoteNumber(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_write__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    char *arg2 = (char *) 0 ;
    unsigned int arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:AiffFile_write",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj1, (char**)&arg2)) {
        SWIG_arg_fail(2);SWIG_fail;
    }
    {
        arg3 = (unsigned int)(SWIG_As_unsigned_SS_int(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->write((char const *)arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_write__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    char *arg2 = (char *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:AiffFile_write",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj1, (char**)&arg2)) {
        SWIG_arg_fail(2);SWIG_fail;
    }
    {
        try
        {
            (arg1)->write((char const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_write(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[4];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AiffFile, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_AsCharPtr(argv[1], (char **)(0));
            if (_v) {
                return _wrap_AiffFile_write__SWIG_1(self,args);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AiffFile, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_AsCharPtr(argv[1], (char **)(0));
            if (_v) {
                _v = SWIG_Check_unsigned_SS_int(argv[2]);
                if (_v) {
                    return _wrap_AiffFile_write__SWIG_0(self,args);
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'AiffFile_write'");
    return NULL;
}


static PyObject *_wrap_new_AiffFile__SWIG_2(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    double arg3 ;
    AiffFile *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:new_AiffFile",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try
        {
            result = (AiffFile *)new_AiffFile__SWIG_2(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_AiffFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_AiffFile__SWIG_3(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    AiffFile *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_AiffFile",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            result = (AiffFile *)new_AiffFile__SWIG_2(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_AiffFile, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_AiffFile__SWIG_4(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    AiffFile *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_AiffFile",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (AiffFile *)new_AiffFile__SWIG_2(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_AiffFile, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_AiffFile(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[4];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_AiffFile__SWIG_4(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        _v = SWIG_AsCharPtr(argv[0], (char **)(0));
        if (_v) {
            return _wrap_new_AiffFile__SWIG_0(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                return _wrap_new_AiffFile__SWIG_3(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        _v = swig::asptr(argv[0], (std::vector<double,std::allocator<double > >**)(0));
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                return _wrap_new_AiffFile__SWIG_1(self,args);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    return _wrap_new_AiffFile__SWIG_2(self,args);
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'new_AiffFile'");
    return NULL;
}


static PyObject *_wrap_AiffFile_samples(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    std::vector<double > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_samples",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = AiffFile_samples(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = swig::from((std::vector<double,std::allocator<double > >)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_channels(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_channels",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (int)AiffFile_channels(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_int((int)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_addPartials__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    double arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:AiffFile_addPartials",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try
        {
            AiffFile_addPartials__SWIG_0(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_addPartials__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:AiffFile_addPartials",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        try
        {
            AiffFile_addPartials__SWIG_0(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_addPartials(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[4];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AiffFile, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_AiffFile_addPartials__SWIG_1(self,args);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AiffFile, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    return _wrap_AiffFile_addPartials__SWIG_0(self,args);
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'AiffFile_addPartials'");
    return NULL;
}


static PyObject *_wrap_AiffFile_numMarkers(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_numMarkers",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (int)AiffFile_numMarkers(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_int((int)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_getMarker(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    int arg2 ;
    Marker *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:AiffFile_getMarker",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (int)(SWIG_As_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            result = (Marker *)AiffFile_getMarker(arg1,arg2);
            
        }
        catch ( InvalidArgument & ex )
        {
            SWIG_exception(SWIG_ValueError, (char *)ex.what() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Marker, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_removeMarker(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:AiffFile_removeMarker",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (int)(SWIG_As_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            AiffFile_removeMarker(arg1,arg2);
            
        }
        catch ( InvalidArgument & ex )
        {
            SWIG_exception(SWIG_ValueError, (char *)ex.what() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_addMarker(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    Marker arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:AiffFile_addMarker",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        Marker * argp;
        SWIG_Python_ConvertPtr(obj1, (void **)&argp, SWIGTYPE_p_Marker, SWIG_POINTER_EXCEPTION);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (argp == NULL) {
            SWIG_null_ref("Marker");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = *argp;
    }
    {
        try
        {
            AiffFile_addMarker(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_clearMarkers(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_clearMarkers",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            AiffFile_clearMarkers(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_markers(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    std::vector<Marker > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_markers",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = AiffFile_markers(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = swig::from((std::vector<Marker,std::allocator<Marker > >)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_addMarkers(PyObject *, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    std::vector<Marker > *arg2 = 0 ;
    int res2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:AiffFile_addMarkers",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_AiffFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        std::vector<Marker,std::allocator<Marker > > *ptr = (std::vector<Marker,std::allocator<Marker > > *)0;
        res2 = swig::asptr(obj1, &ptr);
        if (!res2) {
            if (!PyErr_Occurred())
            SWIG_type_error("std::vector<Marker >", obj1);
        } else if (!ptr) {
            SWIG_null_ref("std::vector<Marker >");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = ptr;
    }
    {
        try
        {
            AiffFile_addMarkers(arg1,(std::vector<Marker > const &)*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return resultobj;
    fail:
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return NULL;
}


static PyObject * AiffFile_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_AiffFile, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_Analyzer__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    Analyzer *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_Analyzer",&obj0,&obj1)) goto fail;
    {
        arg1 = (double)(SWIG_As_double(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            result = (Analyzer *)new_Analyzer__SWIG_0(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Analyzer, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Analyzer__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    Analyzer *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_Analyzer",&obj0)) goto fail;
    {
        arg1 = (double)(SWIG_As_double(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        try
        {
            result = (Analyzer *)new_Analyzer__SWIG_0(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Analyzer, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Analyzer(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 1) {
        int _v;
        _v = SWIG_Check_double(argv[0]);
        if (_v) {
            return _wrap_new_Analyzer__SWIG_1(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        _v = SWIG_Check_double(argv[0]);
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                return _wrap_new_Analyzer__SWIG_0(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'new_Analyzer'");
    return NULL;
}


static PyObject *_wrap_Analyzer_copy(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    Analyzer *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_copy",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (Analyzer *)Analyzer_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Analyzer, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_analyze__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    std::vector<double > *arg2 = 0 ;
    double arg3 ;
    PartialList *result;
    int res2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:Analyzer_analyze",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        std::vector<double,std::allocator<double > > *ptr = (std::vector<double,std::allocator<double > > *)0;
        res2 = swig::asptr(obj1, &ptr);
        if (!res2) {
            if (!PyErr_Occurred())
            SWIG_type_error("std::vector<double >", obj1);
        } else if (!ptr) {
            SWIG_null_ref("std::vector<double >");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = ptr;
    }
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try
        {
            result = (PartialList *)Analyzer_analyze__SWIG_0(arg1,(std::vector<double > const &)*arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialList, 1);
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return resultobj;
    fail:
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return NULL;
}


static PyObject *_wrap_Analyzer_analyze__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    std::vector<double > *arg2 = 0 ;
    double arg3 ;
    BreakpointEnvelope *arg4 = (BreakpointEnvelope *) 0 ;
    PartialList *result;
    int res2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:Analyzer_analyze",&obj0,&obj1,&obj2,&obj3)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        std::vector<double,std::allocator<double > > *ptr = (std::vector<double,std::allocator<double > > *)0;
        res2 = swig::asptr(obj1, &ptr);
        if (!res2) {
            if (!PyErr_Occurred())
            SWIG_type_error("std::vector<double >", obj1);
        } else if (!ptr) {
            SWIG_null_ref("std::vector<double >");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = ptr;
    }
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    SWIG_Python_ConvertPtr(obj3, (void **)&arg4, SWIGTYPE_p_BreakpointEnvelope, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(4)) SWIG_fail;
    {
        try
        {
            result = (PartialList *)Analyzer_analyze__SWIG_1(arg1,(std::vector<double > const &)*arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialList, 1);
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return resultobj;
    fail:
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return NULL;
}


static PyObject *_wrap_Analyzer_analyze(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[5];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Analyzer, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = swig::asptr(argv[1], (std::vector<double,std::allocator<double > >**)(0));
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    return _wrap_Analyzer_analyze__SWIG_0(self,args);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Analyzer, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = swig::asptr(argv[1], (std::vector<double,std::allocator<double > >**)(0));
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    {
                        void *ptr;
                        if (SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                            _v = 0;
                            PyErr_Clear();
                        } else {
                            _v = 1;
                        }
                    }
                    if (_v) {
                        return _wrap_Analyzer_analyze__SWIG_1(self,args);
                    }
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'Analyzer_analyze'");
    return NULL;
}


static PyObject *_wrap_Analyzer_freqResolution(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_freqResolution",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->freqResolution();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_ampFloor(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_ampFloor",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->ampFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_windowWidth(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_windowWidth",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->windowWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_sidelobeLevel(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_sidelobeLevel",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->sidelobeLevel();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_freqFloor(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_freqFloor",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->freqFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_hopTime(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_hopTime",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->hopTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_freqDrift(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_freqDrift",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->freqDrift();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_cropTime(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_cropTime",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->cropTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_bwRegionWidth(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_bwRegionWidth",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->bwRegionWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setFreqResolution(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Analyzer_setFreqResolution",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setFreqResolution(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setAmpFloor(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Analyzer_setAmpFloor",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setAmpFloor(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setWindowWidth(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Analyzer_setWindowWidth",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setWindowWidth(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setSidelobeLevel(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Analyzer_setSidelobeLevel",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setSidelobeLevel(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setFreqFloor(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Analyzer_setFreqFloor",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setFreqFloor(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setFreqDrift(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Analyzer_setFreqDrift",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setFreqDrift(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setHopTime(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Analyzer_setHopTime",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setHopTime(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setCropTime(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Analyzer_setCropTime",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setCropTime(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setBwRegionWidth(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Analyzer_setBwRegionWidth",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setBwRegionWidth(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_Analyzer(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Analyzer",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Analyzer, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * Analyzer_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_Analyzer, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_BreakpointEnvelope__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_BreakpointEnvelope")) goto fail;
    {
        try
        {
            result = (BreakpointEnvelope *)new BreakpointEnvelope();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_BreakpointEnvelope, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_BreakpointEnvelope__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    BreakpointEnvelope *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_BreakpointEnvelope",&obj0)) goto fail;
    {
        arg1 = (double)(SWIG_As_double(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        try
        {
            result = (BreakpointEnvelope *)new BreakpointEnvelope(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_BreakpointEnvelope, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_BreakpointEnvelope(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[2];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_BreakpointEnvelope__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        _v = SWIG_Check_double(argv[0]);
        if (_v) {
            return _wrap_new_BreakpointEnvelope__SWIG_1(self,args);
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'new_BreakpointEnvelope'");
    return NULL;
}


static PyObject *_wrap_delete_BreakpointEnvelope(PyObject *, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_BreakpointEnvelope",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_BreakpointEnvelope, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointEnvelope_copy(PyObject *, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
    BreakpointEnvelope *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointEnvelope_copy",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_BreakpointEnvelope, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelope_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_BreakpointEnvelope, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointEnvelope_insertBreakpoint(PyObject *, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
    double arg2 ;
    double arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:BreakpointEnvelope_insertBreakpoint",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_BreakpointEnvelope, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->insertBreakpoint(arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointEnvelope_valueAt(PyObject *, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
    double arg2 ;
    double result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:BreakpointEnvelope_valueAt",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_BreakpointEnvelope, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            result = (double)((BreakpointEnvelope const *)arg1)->valueAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject * BreakpointEnvelope_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_BreakpointEnvelope, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_BreakpointEnvelopeWithValue(PyObject *, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    BreakpointEnvelope *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointEnvelopeWithValue",&obj0)) goto fail;
    {
        arg1 = (double)(SWIG_As_double(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelopeWithValue(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_BreakpointEnvelope, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_SdifFile__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    char *arg1 = (char *) 0 ;
    SdifFile *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_SdifFile",&obj0)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) {
        SWIG_arg_fail(1);SWIG_fail;
    }
    {
        try
        {
            result = (SdifFile *)new SdifFile((char const *)arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SdifFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_SdifFile__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SdifFile *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_SdifFile")) goto fail;
    {
        try
        {
            result = (SdifFile *)new SdifFile();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SdifFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_SdifFile(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_SdifFile",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SdifFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_write(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    char *arg2 = (char *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SdifFile_write",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SdifFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj1, (char**)&arg2)) {
        SWIG_arg_fail(2);SWIG_fail;
    }
    {
        try
        {
            (arg1)->write((char const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_write1TRC(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    char *arg2 = (char *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SdifFile_write1TRC",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SdifFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj1, (char**)&arg2)) {
        SWIG_arg_fail(2);SWIG_fail;
    }
    {
        try
        {
            (arg1)->write1TRC((char const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_SdifFile__SWIG_2(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    SdifFile *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_SdifFile",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (SdifFile *)new_SdifFile__SWIG_2(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SdifFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_SdifFile(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[2];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_SdifFile__SWIG_1(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_SdifFile__SWIG_2(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        _v = SWIG_AsCharPtr(argv[0], (char **)(0));
        if (_v) {
            return _wrap_new_SdifFile__SWIG_0(self,args);
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'new_SdifFile'");
    return NULL;
}


static PyObject *_wrap_SdifFile_partials(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SdifFile_partials",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SdifFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (PartialList *)SdifFile_partials(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_addPartials(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SdifFile_addPartials",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SdifFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        try
        {
            SdifFile_addPartials(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_numMarkers(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SdifFile_numMarkers",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SdifFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (int)SdifFile_numMarkers(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_int((int)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_getMarker(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    int arg2 ;
    Marker *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SdifFile_getMarker",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SdifFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (int)(SWIG_As_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            result = (Marker *)SdifFile_getMarker(arg1,arg2);
            
        }
        catch ( InvalidArgument & ex )
        {
            SWIG_exception(SWIG_ValueError, (char *)ex.what() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Marker, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_removeMarker(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SdifFile_removeMarker",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SdifFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (int)(SWIG_As_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            SdifFile_removeMarker(arg1,arg2);
            
        }
        catch ( InvalidArgument & ex )
        {
            SWIG_exception(SWIG_ValueError, (char *)ex.what() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_addMarker(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    Marker arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SdifFile_addMarker",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SdifFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        Marker * argp;
        SWIG_Python_ConvertPtr(obj1, (void **)&argp, SWIGTYPE_p_Marker, SWIG_POINTER_EXCEPTION);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (argp == NULL) {
            SWIG_null_ref("Marker");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = *argp;
    }
    {
        try
        {
            SdifFile_addMarker(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_clearMarkers(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SdifFile_clearMarkers",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SdifFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            SdifFile_clearMarkers(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_markers(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    std::vector<Marker > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SdifFile_markers",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SdifFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = SdifFile_markers(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = swig::from((std::vector<Marker,std::allocator<Marker > >)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_addMarkers(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    std::vector<Marker > *arg2 = 0 ;
    int res2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SdifFile_addMarkers",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SdifFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        std::vector<Marker,std::allocator<Marker > > *ptr = (std::vector<Marker,std::allocator<Marker > > *)0;
        res2 = swig::asptr(obj1, &ptr);
        if (!res2) {
            if (!PyErr_Occurred())
            SWIG_type_error("std::vector<Marker >", obj1);
        } else if (!ptr) {
            SWIG_null_ref("std::vector<Marker >");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = ptr;
    }
    {
        try
        {
            SdifFile_addMarkers(arg1,(std::vector<Marker > const &)*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return resultobj;
    fail:
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return NULL;
}


static PyObject * SdifFile_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_SdifFile, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_SpcFile__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    char *arg1 = (char *) 0 ;
    SpcFile *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_SpcFile",&obj0)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) {
        SWIG_arg_fail(1);SWIG_fail;
    }
    {
        try
        {
            result = (SpcFile *)new SpcFile((char const *)arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SpcFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_SpcFile__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    SpcFile *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_SpcFile",&obj0)) goto fail;
    {
        arg1 = (double)(SWIG_As_double(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        try
        {
            result = (SpcFile *)new SpcFile(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SpcFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_SpcFile__SWIG_2(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_SpcFile")) goto fail;
    {
        try
        {
            result = (SpcFile *)new SpcFile();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SpcFile, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_SpcFile(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_SpcFile",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_sampleRate(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SpcFile_sampleRate",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)((SpcFile const *)arg1)->sampleRate();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_midiNoteNumber(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SpcFile_midiNoteNumber",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)((SpcFile const *)arg1)->midiNoteNumber();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_addPartial__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    Loris::Partial *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SpcFile_addPartial",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_Loris__Partial, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (arg2 == NULL) {
            SWIG_null_ref("Loris::Partial");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->addPartial((Loris::Partial const &)*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_addPartial__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    Loris::Partial *arg2 = 0 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:SpcFile_addPartial",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_Loris__Partial, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (arg2 == NULL) {
            SWIG_null_ref("Loris::Partial");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (int)(SWIG_As_int(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->addPartial((Loris::Partial const &)*arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_addPartial(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[4];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_SpcFile, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr = 0;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Loris__Partial, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = (ptr != 0);
                }
            }
            if (_v) {
                return _wrap_SpcFile_addPartial__SWIG_0(self,args);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_SpcFile, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr = 0;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Loris__Partial, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = (ptr != 0);
                }
            }
            if (_v) {
                _v = SWIG_Check_int(argv[2]);
                if (_v) {
                    return _wrap_SpcFile_addPartial__SWIG_1(self,args);
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'SpcFile_addPartial'");
    return NULL;
}


static PyObject *_wrap_SpcFile_setMidiNoteNumber(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SpcFile_setMidiNoteNumber",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setMidiNoteNumber(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_setSampleRate(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SpcFile_setSampleRate",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setSampleRate(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_write__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    char *arg2 = (char *) 0 ;
    bool arg3 ;
    double arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:SpcFile_write",&obj0,&obj1,&obj2,&obj3)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj1, (char**)&arg2)) {
        SWIG_arg_fail(2);SWIG_fail;
    }
    {
        arg3 = (bool)(SWIG_As_bool(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        arg4 = (double)(SWIG_As_double(obj3)); 
        if (SWIG_arg_fail(4)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->write((char const *)arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_write__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    char *arg2 = (char *) 0 ;
    bool arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:SpcFile_write",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj1, (char**)&arg2)) {
        SWIG_arg_fail(2);SWIG_fail;
    }
    {
        arg3 = (bool)(SWIG_As_bool(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->write((char const *)arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_write__SWIG_2(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    char *arg2 = (char *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SpcFile_write",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj1, (char**)&arg2)) {
        SWIG_arg_fail(2);SWIG_fail;
    }
    {
        try
        {
            (arg1)->write((char const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_write(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[5];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_SpcFile, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_AsCharPtr(argv[1], (char **)(0));
            if (_v) {
                return _wrap_SpcFile_write__SWIG_2(self,args);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_SpcFile, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_AsCharPtr(argv[1], (char **)(0));
            if (_v) {
                _v = SWIG_Check_bool(argv[2]);
                if (_v) {
                    return _wrap_SpcFile_write__SWIG_1(self,args);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_SpcFile, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_AsCharPtr(argv[1], (char **)(0));
            if (_v) {
                _v = SWIG_Check_bool(argv[2]);
                if (_v) {
                    _v = SWIG_Check_double(argv[3]);
                    if (_v) {
                        return _wrap_SpcFile_write__SWIG_0(self,args);
                    }
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'SpcFile_write'");
    return NULL;
}


static PyObject *_wrap_new_SpcFile__SWIG_3(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    SpcFile *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_SpcFile",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            result = (SpcFile *)new_SpcFile__SWIG_3(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SpcFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_SpcFile__SWIG_4(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    SpcFile *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_SpcFile",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (SpcFile *)new_SpcFile__SWIG_3(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SpcFile, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_SpcFile(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_SpcFile__SWIG_2(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_SpcFile__SWIG_4(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        _v = SWIG_Check_double(argv[0]);
        if (_v) {
            return _wrap_new_SpcFile__SWIG_1(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        _v = SWIG_AsCharPtr(argv[0], (char **)(0));
        if (_v) {
            return _wrap_new_SpcFile__SWIG_0(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                return _wrap_new_SpcFile__SWIG_3(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'new_SpcFile'");
    return NULL;
}


static PyObject *_wrap_SpcFile_partials(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SpcFile_partials",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (PartialList *)SpcFile_partials(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_addPartials(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SpcFile_addPartials",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        try
        {
            SpcFile_addPartials(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_numMarkers(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SpcFile_numMarkers",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (int)SpcFile_numMarkers(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_int((int)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_getMarker(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    int arg2 ;
    Marker *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SpcFile_getMarker",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (int)(SWIG_As_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            result = (Marker *)SpcFile_getMarker(arg1,arg2);
            
        }
        catch ( InvalidArgument & ex )
        {
            SWIG_exception(SWIG_ValueError, (char *)ex.what() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Marker, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_removeMarker(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SpcFile_removeMarker",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (int)(SWIG_As_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            SpcFile_removeMarker(arg1,arg2);
            
        }
        catch ( InvalidArgument & ex )
        {
            SWIG_exception(SWIG_ValueError, (char *)ex.what() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_addMarker(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    Marker arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SpcFile_addMarker",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        Marker * argp;
        SWIG_Python_ConvertPtr(obj1, (void **)&argp, SWIGTYPE_p_Marker, SWIG_POINTER_EXCEPTION);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (argp == NULL) {
            SWIG_null_ref("Marker");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = *argp;
    }
    {
        try
        {
            SpcFile_addMarker(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_clearMarkers(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SpcFile_clearMarkers",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            SpcFile_clearMarkers(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_markers(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    std::vector<Marker > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SpcFile_markers",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = SpcFile_markers(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = swig::from((std::vector<Marker,std::allocator<Marker > >)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_addMarkers(PyObject *, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    std::vector<Marker > *arg2 = 0 ;
    int res2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SpcFile_addMarkers",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SpcFile, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        std::vector<Marker,std::allocator<Marker > > *ptr = (std::vector<Marker,std::allocator<Marker > > *)0;
        res2 = swig::asptr(obj1, &ptr);
        if (!res2) {
            if (!PyErr_Occurred())
            SWIG_type_error("std::vector<Marker >", obj1);
        } else if (!ptr) {
            SWIG_null_ref("std::vector<Marker >");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = ptr;
    }
    {
        try
        {
            SpcFile_addMarkers(arg1,(std::vector<Marker > const &)*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return resultobj;
    fail:
    if (res2 == SWIG_NEWOBJ) delete arg2;
    return NULL;
}


static PyObject * SpcFile_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_SpcFile, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_NewPlistIterator_atEnd(PyObject *, PyObject *args) {
    PyObject *resultobj;
    NewPlistIterator *arg1 = (NewPlistIterator *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NewPlistIterator_atEnd",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_NewPlistIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (bool)(arg1)->atEnd();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_bool((bool)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NewPlistIterator_next(PyObject *, PyObject *args) {
    PyObject *resultobj;
    NewPlistIterator *arg1 = (NewPlistIterator *) 0 ;
    Partial *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NewPlistIterator_next",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_NewPlistIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (Partial *)(arg1)->next();
        
        if ((err = check_exception()))
        {
#ifndef NO_PYTHON_EXC_STOPITER
            PyErr_SetString( PyExc_StopIteration, err );
            return NULL;
#else
            SWIG_exception( SWIG_ValueError, err );
#endif
            
            
            
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Partial, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NewPlistIterator_partial(PyObject *, PyObject *args) {
    PyObject *resultobj;
    NewPlistIterator *arg1 = (NewPlistIterator *) 0 ;
    Partial *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NewPlistIterator_partial",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_NewPlistIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (Partial *)NewPlistIterator_partial(arg1);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Partial, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * NewPlistIterator_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_NewPlistIterator, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_NewPartialIterator_atEnd(PyObject *, PyObject *args) {
    PyObject *resultobj;
    NewPartialIterator *arg1 = (NewPartialIterator *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NewPartialIterator_atEnd",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_NewPartialIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (bool)(arg1)->atEnd();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_bool((bool)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NewPartialIterator_hasNext(PyObject *, PyObject *args) {
    PyObject *resultobj;
    NewPartialIterator *arg1 = (NewPartialIterator *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NewPartialIterator_hasNext",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_NewPartialIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (bool)(arg1)->hasNext();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_bool((bool)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NewPartialIterator_next(PyObject *, PyObject *args) {
    PyObject *resultobj;
    NewPartialIterator *arg1 = (NewPartialIterator *) 0 ;
    BreakpointPosition *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NewPartialIterator_next",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_NewPartialIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (BreakpointPosition *)(arg1)->next();
        
        if ((err = check_exception()))
        {
#ifndef NO_PYTHON_EXC_STOPITER
            PyErr_SetString( PyExc_StopIteration, err );
            return NULL;
#else
            SWIG_exception( SWIG_ValueError, err );
#endif
            
            
            
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_BreakpointPosition, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * NewPartialIterator_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_NewPartialIterator, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_PartialList__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_PartialList")) goto fail;
    {
        try
        {
            result = (PartialList *)new PartialList();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PartialList__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = 0 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_PartialList",&obj0)) goto fail;
    {
        SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(1)) SWIG_fail;
        if (arg1 == NULL) {
            SWIG_null_ref("PartialList");
        }
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        try
        {
            result = (PartialList *)new PartialList((PartialList const &)*arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PartialList(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[2];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_PartialList__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr = 0;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = (ptr != 0);
            }
        }
        if (_v) {
            return _wrap_new_PartialList__SWIG_1(self,args);
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'new_PartialList'");
    return NULL;
}


static PyObject *_wrap_delete_PartialList(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PartialList",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_clear(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_clear",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            (arg1)->clear();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_size(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    unsigned long result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_size",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (unsigned long)(arg1)->size();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_timeSpan(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double *arg2 = (double *) 0 ;
    double *arg3 = (double *) 0 ;
    double temp2 ;
    int res2 = 0 ;
    double temp3 ;
    int res3 = 0 ;
    PyObject * obj0 = 0 ;
    
    arg2 = &temp2; res2 = SWIG_NEWOBJ;
    arg3 = &temp3; res3 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_timeSpan",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            PartialList_timeSpan(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res2 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg2)) : SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, 0)));
    resultobj = t_output_helper(resultobj, ((res3 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg3)) : SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, 0)));
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_iterator(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    NewPlistIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_iterator",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (NewPlistIterator *)PartialList_iterator(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_NewPlistIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList___iter__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    NewPlistIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList___iter__",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (NewPlistIterator *)PartialList___iter__(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_NewPlistIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_append(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    Partial *arg2 = (Partial *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialList_append",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        try
        {
            PartialList_append(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_insert__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    NewPlistIterator *arg2 = (NewPlistIterator *) 0 ;
    Partial *arg3 = (Partial *) 0 ;
    NewPlistIterator *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialList_insert",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_NewPlistIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj2, (void **)&arg3, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(3)) SWIG_fail;
    {
        try
        {
            result = (NewPlistIterator *)PartialList_insert__SWIG_0(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_NewPlistIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_erase__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    Partial *arg2 = (Partial *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialList_erase",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        char * err;
        clear_exception();
        PartialList_erase__SWIG_0(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_splice__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialList_splice",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        try
        {
            PartialList_splice__SWIG_0(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_first(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    Partial *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_first",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (Partial *)PartialList_first(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Partial, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_last(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    Partial *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_last",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (Partial *)PartialList_last(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Partial, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_begin(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialListIterator result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_begin",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (arg1)->begin();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultptr;
        resultptr = new PartialListIterator((PartialListIterator &)(result));
        resultobj = SWIG_NewPointerObj((void *)(resultptr), SWIGTYPE_p_PartialListIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_end(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialListIterator result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_end",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (arg1)->end();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultptr;
        resultptr = new PartialListIterator((PartialListIterator &)(result));
        resultobj = SWIG_NewPointerObj((void *)(resultptr), SWIGTYPE_p_PartialListIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_insert__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialListIterator arg2 ;
    Partial *arg3 = 0 ;
    PartialListIterator result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialList_insert",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        PartialListIterator * argp;
        SWIG_Python_ConvertPtr(obj1, (void **)&argp, SWIGTYPE_p_PartialListIterator, SWIG_POINTER_EXCEPTION);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (argp == NULL) {
            SWIG_null_ref("PartialListIterator");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = *argp;
    }
    {
        SWIG_Python_ConvertPtr(obj2, (void **)&arg3, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(3)) SWIG_fail;
        if (arg3 == NULL) {
            SWIG_null_ref("Partial");
        }
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try
        {
            result = (arg1)->insert(arg2,(Partial const &)*arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultptr;
        resultptr = new PartialListIterator((PartialListIterator &)(result));
        resultobj = SWIG_NewPointerObj((void *)(resultptr), SWIGTYPE_p_PartialListIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_erase__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialListIterator arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialList_erase",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        PartialListIterator * argp;
        SWIG_Python_ConvertPtr(obj1, (void **)&argp, SWIGTYPE_p_PartialListIterator, SWIG_POINTER_EXCEPTION);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (argp == NULL) {
            SWIG_null_ref("PartialListIterator");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = *argp;
    }
    {
        char * err;
        clear_exception();
        (arg1)->erase(arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_erase(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Partial, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_PartialList_erase__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr = 0;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_PartialListIterator, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = (ptr != 0);
                }
            }
            if (_v) {
                return _wrap_PartialList_erase__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'PartialList_erase'");
    return NULL;
}


static PyObject *_wrap_PartialList_splice__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialListIterator arg2 ;
    PartialList *arg3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialList_splice",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        PartialListIterator * argp;
        SWIG_Python_ConvertPtr(obj1, (void **)&argp, SWIGTYPE_p_PartialListIterator, SWIG_POINTER_EXCEPTION);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (argp == NULL) {
            SWIG_null_ref("PartialListIterator");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
        arg2 = *argp;
    }
    {
        SWIG_Python_ConvertPtr(obj2, (void **)&arg3, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(3)) SWIG_fail;
        if (arg3 == NULL) {
            SWIG_null_ref("PartialList");
        }
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->splice(arg2,*arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_splice(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[4];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_PartialList_splice__SWIG_0(self,args);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr = 0;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_PartialListIterator, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = (ptr != 0);
                }
            }
            if (_v) {
                {
                    void *ptr = 0;
                    if (SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                        _v = 0;
                        PyErr_Clear();
                    } else {
                        _v = (ptr != 0);
                    }
                }
                if (_v) {
                    return _wrap_PartialList_splice__SWIG_1(self,args);
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'PartialList_splice'");
    return NULL;
}


static PyObject *_wrap_PartialList_insert__SWIG_2(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    Partial *arg2 = 0 ;
    PartialListIterator result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialList_insert",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (arg2 == NULL) {
            SWIG_null_ref("Partial");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            result = PartialList_insert__SWIG_2(arg1,(Partial const &)*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultptr;
        resultptr = new PartialListIterator((PartialListIterator &)(result));
        resultobj = SWIG_NewPointerObj((void *)(resultptr), SWIGTYPE_p_PartialListIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_insert(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[4];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr = 0;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Partial, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = (ptr != 0);
                }
            }
            if (_v) {
                return _wrap_PartialList_insert__SWIG_2(self,args);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr = 0;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_PartialListIterator, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = (ptr != 0);
                }
            }
            if (_v) {
                {
                    void *ptr = 0;
                    if (SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_Partial, 0) == -1) {
                        _v = 0;
                        PyErr_Clear();
                    } else {
                        _v = (ptr != 0);
                    }
                }
                if (_v) {
                    return _wrap_PartialList_insert__SWIG_1(self,args);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_NewPlistIterator, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_Partial, 0) == -1) {
                        _v = 0;
                        PyErr_Clear();
                    } else {
                        _v = 1;
                    }
                }
                if (_v) {
                    return _wrap_PartialList_insert__SWIG_0(self,args);
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'PartialList_insert'");
    return NULL;
}


static PyObject *_wrap_PartialList_copy(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_copy",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialList, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (PartialList *)PartialList_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * PartialList_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_PartialList, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_Partial__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_Partial")) goto fail;
    {
        try
        {
            result = (Partial *)new Partial();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Partial, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Partial__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = 0 ;
    Partial *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_Partial",&obj0)) goto fail;
    {
        SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(1)) SWIG_fail;
        if (arg1 == NULL) {
            SWIG_null_ref("Partial");
        }
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        try
        {
            result = (Partial *)new Partial((Partial const &)*arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Partial, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Partial(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[2];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_Partial__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr = 0;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Partial, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = (ptr != 0);
            }
        }
        if (_v) {
            return _wrap_new_Partial__SWIG_1(self,args);
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'new_Partial'");
    return NULL;
}


static PyObject *_wrap_delete_Partial(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Partial",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_label(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_label",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (int)(arg1)->label();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_int((int)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_initialPhase(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_initialPhase",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->initialPhase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_startTime(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_startTime",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->startTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_endTime(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_endTime",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->endTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_duration(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_duration",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->duration();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_numBreakpoints(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    long result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_numBreakpoints",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (long)(arg1)->numBreakpoints();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_long((long)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_setLabel(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_setLabel",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (int)(SWIG_As_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setLabel(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_frequencyAt(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    double result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_frequencyAt",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            result = (double)(arg1)->frequencyAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_amplitudeAt(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    double result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_amplitudeAt",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            result = (double)(arg1)->amplitudeAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_bandwidthAt(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    double result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_bandwidthAt",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            result = (double)(arg1)->bandwidthAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_phaseAt(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    double result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_phaseAt",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            result = (double)(arg1)->phaseAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_iterator(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    NewPartialIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_iterator",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (NewPartialIterator *)Partial_iterator(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_NewPartialIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial___iter__(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    NewPartialIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial___iter__",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (NewPartialIterator *)Partial___iter__(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_NewPartialIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_erase__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    BreakpointPosition *arg2 = (BreakpointPosition *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_erase",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_BreakpointPosition, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        try
        {
            Partial_erase__SWIG_0(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_first(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    Breakpoint *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_first",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (Breakpoint *)Partial_first(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Breakpoint, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_last(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    Breakpoint *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_last",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (Breakpoint *)Partial_last(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Breakpoint, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_begin(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    PartialIterator result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_begin",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (arg1)->begin();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator((PartialIterator &)(result));
        resultobj = SWIG_NewPointerObj((void *)(resultptr), SWIGTYPE_p_PartialIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_end(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    PartialIterator result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_end",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (arg1)->end();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator((PartialIterator &)(result));
        resultobj = SWIG_NewPointerObj((void *)(resultptr), SWIGTYPE_p_PartialIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_erase__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    PartialIterator *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_erase",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialIterator, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(2)) SWIG_fail;
        if (arg2 == NULL) {
            SWIG_null_ref("PartialIterator");
        }
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->erase(*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_erase(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Partial, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_BreakpointPosition, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_Partial_erase__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Partial, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr = 0;
                if (SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_PartialIterator, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = (ptr != 0);
                }
            }
            if (_v) {
                return _wrap_Partial_erase__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'Partial_erase'");
    return NULL;
}


static PyObject *_wrap_Partial_insert(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    Breakpoint *arg3 = 0 ;
    PartialIterator result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:Partial_insert",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        SWIG_Python_ConvertPtr(obj2, (void **)&arg3, SWIGTYPE_p_Breakpoint, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(3)) SWIG_fail;
        if (arg3 == NULL) {
            SWIG_null_ref("Breakpoint");
        }
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try
        {
            result = (arg1)->insert(arg2,(Breakpoint const &)*arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator((PartialIterator &)(result));
        resultobj = SWIG_NewPointerObj((void *)(resultptr), SWIGTYPE_p_PartialIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_findAfter(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    PartialIterator result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_findAfter",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            result = (arg1)->findAfter(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator((PartialIterator &)(result));
        resultobj = SWIG_NewPointerObj((void *)(resultptr), SWIGTYPE_p_PartialIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_findNearest(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    PartialIterator result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_findNearest",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            result = (arg1)->findNearest(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator((PartialIterator &)(result));
        resultobj = SWIG_NewPointerObj((void *)(resultptr), SWIGTYPE_p_PartialIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_copy(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    Partial *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_copy",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Partial, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (Partial *)Partial_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Partial, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * Partial_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_Partial, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_Breakpoint__SWIG_0(PyObject *, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double arg3 ;
    double arg4 ;
    Breakpoint *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:new_Breakpoint",&obj0,&obj1,&obj2,&obj3)) goto fail;
    {
        arg1 = (double)(SWIG_As_double(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        arg4 = (double)(SWIG_As_double(obj3)); 
        if (SWIG_arg_fail(4)) SWIG_fail;
    }
    {
        try
        {
            result = (Breakpoint *)new Breakpoint(arg1,arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Breakpoint, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Breakpoint__SWIG_1(PyObject *, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double arg3 ;
    Breakpoint *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:new_Breakpoint",&obj0,&obj1,&obj2)) goto fail;
    {
        arg1 = (double)(SWIG_As_double(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (double)(SWIG_As_double(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        try
        {
            result = (Breakpoint *)new Breakpoint(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Breakpoint, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Breakpoint__SWIG_2(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = 0 ;
    Breakpoint *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_Breakpoint",&obj0)) goto fail;
    {
        SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Breakpoint, SWIG_POINTER_EXCEPTION | 0);
        if (SWIG_arg_fail(1)) SWIG_fail;
        if (arg1 == NULL) {
            SWIG_null_ref("Breakpoint");
        }
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        try
        {
            result = (Breakpoint *)new Breakpoint((Breakpoint const &)*arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Breakpoint, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Breakpoint(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[5];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr = 0;
            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Breakpoint, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = (ptr != 0);
            }
        }
        if (_v) {
            return _wrap_new_Breakpoint__SWIG_2(self,args);
        }
    }
    if (argc == 3) {
        int _v;
        _v = SWIG_Check_double(argv[0]);
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    return _wrap_new_Breakpoint__SWIG_1(self,args);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = SWIG_Check_double(argv[0]);
        if (_v) {
            _v = SWIG_Check_double(argv[1]);
            if (_v) {
                _v = SWIG_Check_double(argv[2]);
                if (_v) {
                    _v = SWIG_Check_double(argv[3]);
                    if (_v) {
                        return _wrap_new_Breakpoint__SWIG_0(self,args);
                    }
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'new_Breakpoint'");
    return NULL;
}


static PyObject *_wrap_delete_Breakpoint(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Breakpoint",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Breakpoint, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_frequency(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_frequency",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Breakpoint, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->frequency();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_amplitude(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_amplitude",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Breakpoint, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->amplitude();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_bandwidth(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_bandwidth",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Breakpoint, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->bandwidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_phase(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_phase",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Breakpoint, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->phase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_setFrequency(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Breakpoint_setFrequency",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Breakpoint, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setFrequency(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_setAmplitude(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Breakpoint_setAmplitude",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Breakpoint, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setAmplitude(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_setBandwidth(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Breakpoint_setBandwidth",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Breakpoint, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setBandwidth(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_setPhase(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Breakpoint_setPhase",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Breakpoint, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            (arg1)->setPhase(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_copy(PyObject *, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    Breakpoint *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_copy",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_Breakpoint, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (Breakpoint *)Breakpoint_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Breakpoint, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * Breakpoint_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_Breakpoint, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_BreakpointPosition_time(PyObject *, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointPosition_time",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_BreakpointPosition, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)BreakpointPosition_time(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_breakpoint(PyObject *, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    Breakpoint *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointPosition_breakpoint",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_BreakpointPosition, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (Breakpoint *)BreakpointPosition_breakpoint(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Breakpoint, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_frequency(PyObject *, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointPosition_frequency",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_BreakpointPosition, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)BreakpointPosition_frequency(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_amplitude(PyObject *, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointPosition_amplitude",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_BreakpointPosition, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)BreakpointPosition_amplitude(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_bandwidth(PyObject *, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointPosition_bandwidth",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_BreakpointPosition, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)BreakpointPosition_bandwidth(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_phase(PyObject *, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointPosition_phase",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_BreakpointPosition, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)BreakpointPosition_phase(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_setFrequency(PyObject *, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:BreakpointPosition_setFrequency",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_BreakpointPosition, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            BreakpointPosition_setFrequency(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_setAmplitude(PyObject *, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:BreakpointPosition_setAmplitude",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_BreakpointPosition, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            BreakpointPosition_setAmplitude(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_setBandwidth(PyObject *, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:BreakpointPosition_setBandwidth",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_BreakpointPosition, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            BreakpointPosition_setBandwidth(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_setPhase(PyObject *, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:BreakpointPosition_setPhase",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_BreakpointPosition, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        arg2 = (double)(SWIG_As_double(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        try
        {
            BreakpointPosition_setPhase(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * BreakpointPosition_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_BreakpointPosition, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_PartialIterator_time(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_time",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (double)((PartialIterator const *)arg1)->time();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_double((double)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialIterator_breakpoint(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    Breakpoint *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_breakpoint",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (Breakpoint *)PartialIterator_breakpoint(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Breakpoint, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialIterator_copy(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PartialIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_copy",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialIterator_next(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PartialIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_next",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (PartialIterator *)PartialIterator_next(arg1);
        
        if ((err = check_exception()))
        {
#ifndef NO_PYTHON_EXC_STOPITER
            PyErr_SetString( PyExc_StopIteration, err );
            return NULL;
#else
            SWIG_exception( SWIG_ValueError, err );
#endif
            
            
            
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialIterator_prev(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PartialIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_prev",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_prev(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialIterator_equals(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PartialIterator *arg2 = (PartialIterator *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialIterator_equals",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        try
        {
            result = (int)PartialIterator_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_int((int)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialIterator_isInRange(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PartialIterator *arg2 = (PartialIterator *) 0 ;
    PartialIterator *arg3 = (PartialIterator *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialIterator_isInRange",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj2, (void **)&arg3, SWIGTYPE_p_PartialIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(3)) SWIG_fail;
    {
        try
        {
            result = (int)PartialIterator_isInRange(arg1,(PartialIterator const *)arg2,(PartialIterator const *)arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_int((int)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PartialIterator(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_PartialIterator")) goto fail;
    {
        try
        {
            result = (PartialIterator *)new PartialIterator();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_PartialIterator(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PartialIterator",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * PartialIterator_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_PartialIterator, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_PartialListIterator_copy(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PartialListIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_copy",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialListIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialListIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialListIterator_next(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PartialListIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_next",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialListIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (PartialListIterator *)PartialListIterator_next(arg1);
        
        if ((err = check_exception()))
        {
#ifndef NO_PYTHON_EXC_STOPITER
            PyErr_SetString( PyExc_StopIteration, err );
            return NULL;
#else
            SWIG_exception( SWIG_ValueError, err );
#endif
            
            
            
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialListIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialListIterator_prev(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PartialListIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_prev",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialListIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_prev(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialListIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialListIterator_partial(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    Partial *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_partial",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialListIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            result = (Partial *)PartialListIterator_partial(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_Partial, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialListIterator_equals(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PartialListIterator *arg2 = (PartialListIterator *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialListIterator_equals",&obj0,&obj1)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialListIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialListIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    {
        try
        {
            result = (int)PartialListIterator_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_int((int)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialListIterator_isInRange(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PartialListIterator *arg2 = (PartialListIterator *) 0 ;
    PartialListIterator *arg3 = (PartialListIterator *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialListIterator_isInRange",&obj0,&obj1,&obj2)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialListIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_PartialListIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(2)) SWIG_fail;
    SWIG_Python_ConvertPtr(obj2, (void **)&arg3, SWIGTYPE_p_PartialListIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(3)) SWIG_fail;
    {
        try
        {
            result = (int)PartialListIterator_isInRange(arg1,(PartialListIterator const *)arg2,(PartialListIterator const *)arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        resultobj = SWIG_From_int((int)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PartialListIterator(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_PartialListIterator")) goto fail;
    {
        try
        {
            result = (PartialListIterator *)new PartialListIterator();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_PartialListIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_PartialListIterator(PyObject *, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PartialListIterator",&obj0)) goto fail;
    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_PartialListIterator, SWIG_POINTER_EXCEPTION | 0);
    if (SWIG_arg_fail(1)) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * PartialListIterator_swigregister(PyObject *, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_PartialListIterator, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyMethodDef SwigMethods[] = {
	 { (char *)"DoubleVector_empty", _wrap_DoubleVector_empty, METH_VARARGS, NULL},
	 { (char *)"DoubleVector_size", _wrap_DoubleVector_size, METH_VARARGS, NULL},
	 { (char *)"DoubleVector_clear", _wrap_DoubleVector_clear, METH_VARARGS, NULL},
	 { (char *)"DoubleVector_swap", _wrap_DoubleVector_swap, METH_VARARGS, NULL},
	 { (char *)"DoubleVector_get_allocator", _wrap_DoubleVector_get_allocator, METH_VARARGS, NULL},
	 { (char *)"DoubleVector_pop_back", _wrap_DoubleVector_pop_back, METH_VARARGS, NULL},
	 { (char *)"new_DoubleVector", _wrap_new_DoubleVector, METH_VARARGS, NULL},
	 { (char *)"DoubleVector_push_back", _wrap_DoubleVector_push_back, METH_VARARGS, NULL},
	 { (char *)"DoubleVector_front", _wrap_DoubleVector_front, METH_VARARGS, NULL},
	 { (char *)"DoubleVector_back", _wrap_DoubleVector_back, METH_VARARGS, NULL},
	 { (char *)"DoubleVector_assign", _wrap_DoubleVector_assign, METH_VARARGS, NULL},
	 { (char *)"DoubleVector_resize", _wrap_DoubleVector_resize, METH_VARARGS, NULL},
	 { (char *)"DoubleVector_reserve", _wrap_DoubleVector_reserve, METH_VARARGS, NULL},
	 { (char *)"DoubleVector_capacity", _wrap_DoubleVector_capacity, METH_VARARGS, NULL},
	 { (char *)"DoubleVector___nonzero__", _wrap_DoubleVector___nonzero__, METH_VARARGS, NULL},
	 { (char *)"DoubleVector___len__", _wrap_DoubleVector___len__, METH_VARARGS, NULL},
	 { (char *)"DoubleVector_pop", _wrap_DoubleVector_pop, METH_VARARGS, NULL},
	 { (char *)"DoubleVector___getslice__", _wrap_DoubleVector___getslice__, METH_VARARGS, NULL},
	 { (char *)"DoubleVector___setslice__", _wrap_DoubleVector___setslice__, METH_VARARGS, NULL},
	 { (char *)"DoubleVector___delslice__", _wrap_DoubleVector___delslice__, METH_VARARGS, NULL},
	 { (char *)"DoubleVector___delitem__", _wrap_DoubleVector___delitem__, METH_VARARGS, NULL},
	 { (char *)"DoubleVector___getitem__", _wrap_DoubleVector___getitem__, METH_VARARGS, NULL},
	 { (char *)"DoubleVector___setitem__", _wrap_DoubleVector___setitem__, METH_VARARGS, NULL},
	 { (char *)"DoubleVector_append", _wrap_DoubleVector_append, METH_VARARGS, NULL},
	 { (char *)"delete_DoubleVector", _wrap_delete_DoubleVector, METH_VARARGS, NULL},
	 { (char *)"DoubleVector_swigregister", DoubleVector_swigregister, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_empty", _wrap_MarkerVector_empty, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_size", _wrap_MarkerVector_size, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_clear", _wrap_MarkerVector_clear, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_swap", _wrap_MarkerVector_swap, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_get_allocator", _wrap_MarkerVector_get_allocator, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_pop_back", _wrap_MarkerVector_pop_back, METH_VARARGS, NULL},
	 { (char *)"new_MarkerVector", _wrap_new_MarkerVector, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_push_back", _wrap_MarkerVector_push_back, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_front", _wrap_MarkerVector_front, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_back", _wrap_MarkerVector_back, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_assign", _wrap_MarkerVector_assign, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_resize", _wrap_MarkerVector_resize, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_reserve", _wrap_MarkerVector_reserve, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_capacity", _wrap_MarkerVector_capacity, METH_VARARGS, NULL},
	 { (char *)"MarkerVector___nonzero__", _wrap_MarkerVector___nonzero__, METH_VARARGS, NULL},
	 { (char *)"MarkerVector___len__", _wrap_MarkerVector___len__, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_pop", _wrap_MarkerVector_pop, METH_VARARGS, NULL},
	 { (char *)"MarkerVector___getslice__", _wrap_MarkerVector___getslice__, METH_VARARGS, NULL},
	 { (char *)"MarkerVector___setslice__", _wrap_MarkerVector___setslice__, METH_VARARGS, NULL},
	 { (char *)"MarkerVector___delslice__", _wrap_MarkerVector___delslice__, METH_VARARGS, NULL},
	 { (char *)"MarkerVector___delitem__", _wrap_MarkerVector___delitem__, METH_VARARGS, NULL},
	 { (char *)"MarkerVector___getitem__", _wrap_MarkerVector___getitem__, METH_VARARGS, NULL},
	 { (char *)"MarkerVector___setitem__", _wrap_MarkerVector___setitem__, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_append", _wrap_MarkerVector_append, METH_VARARGS, NULL},
	 { (char *)"delete_MarkerVector", _wrap_delete_MarkerVector, METH_VARARGS, NULL},
	 { (char *)"MarkerVector_swigregister", MarkerVector_swigregister, METH_VARARGS, NULL},
	 { (char *)"channelize", _wrap_channelize, METH_VARARGS, NULL},
	 { (char *)"createFreqReference", _wrap_createFreqReference, METH_VARARGS, NULL},
	 { (char *)"dilate", _wrap_dilate, METH_VARARGS, NULL},
	 { (char *)"distill", _wrap_distill, METH_VARARGS, NULL},
	 { (char *)"exportAiff", _wrap_exportAiff, METH_VARARGS, NULL},
	 { (char *)"exportSdif", _wrap_exportSdif, METH_VARARGS, NULL},
	 { (char *)"exportSpc", _wrap_exportSpc, METH_VARARGS, NULL},
	 { (char *)"importSdif", _wrap_importSdif, METH_VARARGS, NULL},
	 { (char *)"importSpc", _wrap_importSpc, METH_VARARGS, NULL},
	 { (char *)"morph", _wrap_morph, METH_VARARGS, NULL},
	 { (char *)"synthesize", _wrap_synthesize, METH_VARARGS, NULL},
	 { (char *)"crop", _wrap_crop, METH_VARARGS, NULL},
	 { (char *)"copyLabeled", _wrap_copyLabeled, METH_VARARGS, NULL},
	 { (char *)"extractLabeled", _wrap_extractLabeled, METH_VARARGS, NULL},
	 { (char *)"removeLabeled", _wrap_removeLabeled, METH_VARARGS, NULL},
	 { (char *)"resample", _wrap_resample, METH_VARARGS, NULL},
	 { (char *)"scaleAmp", _wrap_scaleAmp, METH_VARARGS, NULL},
	 { (char *)"scaleBandwidth", _wrap_scaleBandwidth, METH_VARARGS, NULL},
	 { (char *)"scaleFrequency", _wrap_scaleFrequency, METH_VARARGS, NULL},
	 { (char *)"scaleNoiseRatio", _wrap_scaleNoiseRatio, METH_VARARGS, NULL},
	 { (char *)"shiftPitch", _wrap_shiftPitch, METH_VARARGS, NULL},
	 { (char *)"shiftTime", _wrap_shiftTime, METH_VARARGS, NULL},
	 { (char *)"sift", _wrap_sift, METH_VARARGS, NULL},
	 { (char *)"sortByLabel", _wrap_sortByLabel, METH_VARARGS, NULL},
	 { (char *)"version", _wrap_version, METH_VARARGS, NULL},
	 { (char *)"new_Marker", _wrap_new_Marker, METH_VARARGS, NULL},
	 { (char *)"Marker_name", _wrap_Marker_name, METH_VARARGS, NULL},
	 { (char *)"Marker_time", _wrap_Marker_time, METH_VARARGS, NULL},
	 { (char *)"Marker_setName", _wrap_Marker_setName, METH_VARARGS, NULL},
	 { (char *)"Marker_setTime", _wrap_Marker_setTime, METH_VARARGS, NULL},
	 { (char *)"delete_Marker", _wrap_delete_Marker, METH_VARARGS, NULL},
	 { (char *)"Marker_swigregister", Marker_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_AiffFile", _wrap_delete_AiffFile, METH_VARARGS, NULL},
	 { (char *)"AiffFile_sampleRate", _wrap_AiffFile_sampleRate, METH_VARARGS, NULL},
	 { (char *)"AiffFile_midiNoteNumber", _wrap_AiffFile_midiNoteNumber, METH_VARARGS, NULL},
	 { (char *)"AiffFile_sampleFrames", _wrap_AiffFile_sampleFrames, METH_VARARGS, NULL},
	 { (char *)"AiffFile_addPartial", _wrap_AiffFile_addPartial, METH_VARARGS, NULL},
	 { (char *)"AiffFile_setMidiNoteNumber", _wrap_AiffFile_setMidiNoteNumber, METH_VARARGS, NULL},
	 { (char *)"AiffFile_write", _wrap_AiffFile_write, METH_VARARGS, NULL},
	 { (char *)"new_AiffFile", _wrap_new_AiffFile, METH_VARARGS, NULL},
	 { (char *)"AiffFile_samples", _wrap_AiffFile_samples, METH_VARARGS, NULL},
	 { (char *)"AiffFile_channels", _wrap_AiffFile_channels, METH_VARARGS, NULL},
	 { (char *)"AiffFile_addPartials", _wrap_AiffFile_addPartials, METH_VARARGS, NULL},
	 { (char *)"AiffFile_numMarkers", _wrap_AiffFile_numMarkers, METH_VARARGS, NULL},
	 { (char *)"AiffFile_getMarker", _wrap_AiffFile_getMarker, METH_VARARGS, NULL},
	 { (char *)"AiffFile_removeMarker", _wrap_AiffFile_removeMarker, METH_VARARGS, NULL},
	 { (char *)"AiffFile_addMarker", _wrap_AiffFile_addMarker, METH_VARARGS, NULL},
	 { (char *)"AiffFile_clearMarkers", _wrap_AiffFile_clearMarkers, METH_VARARGS, NULL},
	 { (char *)"AiffFile_markers", _wrap_AiffFile_markers, METH_VARARGS, NULL},
	 { (char *)"AiffFile_addMarkers", _wrap_AiffFile_addMarkers, METH_VARARGS, NULL},
	 { (char *)"AiffFile_swigregister", AiffFile_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_Analyzer", _wrap_new_Analyzer, METH_VARARGS, NULL},
	 { (char *)"Analyzer_copy", _wrap_Analyzer_copy, METH_VARARGS, NULL},
	 { (char *)"Analyzer_analyze", _wrap_Analyzer_analyze, METH_VARARGS, NULL},
	 { (char *)"Analyzer_freqResolution", _wrap_Analyzer_freqResolution, METH_VARARGS, NULL},
	 { (char *)"Analyzer_ampFloor", _wrap_Analyzer_ampFloor, METH_VARARGS, NULL},
	 { (char *)"Analyzer_windowWidth", _wrap_Analyzer_windowWidth, METH_VARARGS, NULL},
	 { (char *)"Analyzer_sidelobeLevel", _wrap_Analyzer_sidelobeLevel, METH_VARARGS, NULL},
	 { (char *)"Analyzer_freqFloor", _wrap_Analyzer_freqFloor, METH_VARARGS, NULL},
	 { (char *)"Analyzer_hopTime", _wrap_Analyzer_hopTime, METH_VARARGS, NULL},
	 { (char *)"Analyzer_freqDrift", _wrap_Analyzer_freqDrift, METH_VARARGS, NULL},
	 { (char *)"Analyzer_cropTime", _wrap_Analyzer_cropTime, METH_VARARGS, NULL},
	 { (char *)"Analyzer_bwRegionWidth", _wrap_Analyzer_bwRegionWidth, METH_VARARGS, NULL},
	 { (char *)"Analyzer_setFreqResolution", _wrap_Analyzer_setFreqResolution, METH_VARARGS, NULL},
	 { (char *)"Analyzer_setAmpFloor", _wrap_Analyzer_setAmpFloor, METH_VARARGS, NULL},
	 { (char *)"Analyzer_setWindowWidth", _wrap_Analyzer_setWindowWidth, METH_VARARGS, NULL},
	 { (char *)"Analyzer_setSidelobeLevel", _wrap_Analyzer_setSidelobeLevel, METH_VARARGS, NULL},
	 { (char *)"Analyzer_setFreqFloor", _wrap_Analyzer_setFreqFloor, METH_VARARGS, NULL},
	 { (char *)"Analyzer_setFreqDrift", _wrap_Analyzer_setFreqDrift, METH_VARARGS, NULL},
	 { (char *)"Analyzer_setHopTime", _wrap_Analyzer_setHopTime, METH_VARARGS, NULL},
	 { (char *)"Analyzer_setCropTime", _wrap_Analyzer_setCropTime, METH_VARARGS, NULL},
	 { (char *)"Analyzer_setBwRegionWidth", _wrap_Analyzer_setBwRegionWidth, METH_VARARGS, NULL},
	 { (char *)"delete_Analyzer", _wrap_delete_Analyzer, METH_VARARGS, NULL},
	 { (char *)"Analyzer_swigregister", Analyzer_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_BreakpointEnvelope", _wrap_new_BreakpointEnvelope, METH_VARARGS, NULL},
	 { (char *)"delete_BreakpointEnvelope", _wrap_delete_BreakpointEnvelope, METH_VARARGS, NULL},
	 { (char *)"BreakpointEnvelope_copy", _wrap_BreakpointEnvelope_copy, METH_VARARGS, NULL},
	 { (char *)"BreakpointEnvelope_insertBreakpoint", _wrap_BreakpointEnvelope_insertBreakpoint, METH_VARARGS, NULL},
	 { (char *)"BreakpointEnvelope_valueAt", _wrap_BreakpointEnvelope_valueAt, METH_VARARGS, NULL},
	 { (char *)"BreakpointEnvelope_swigregister", BreakpointEnvelope_swigregister, METH_VARARGS, NULL},
	 { (char *)"BreakpointEnvelopeWithValue", _wrap_BreakpointEnvelopeWithValue, METH_VARARGS, NULL},
	 { (char *)"delete_SdifFile", _wrap_delete_SdifFile, METH_VARARGS, NULL},
	 { (char *)"SdifFile_write", _wrap_SdifFile_write, METH_VARARGS, NULL},
	 { (char *)"SdifFile_write1TRC", _wrap_SdifFile_write1TRC, METH_VARARGS, NULL},
	 { (char *)"new_SdifFile", _wrap_new_SdifFile, METH_VARARGS, NULL},
	 { (char *)"SdifFile_partials", _wrap_SdifFile_partials, METH_VARARGS, NULL},
	 { (char *)"SdifFile_addPartials", _wrap_SdifFile_addPartials, METH_VARARGS, NULL},
	 { (char *)"SdifFile_numMarkers", _wrap_SdifFile_numMarkers, METH_VARARGS, NULL},
	 { (char *)"SdifFile_getMarker", _wrap_SdifFile_getMarker, METH_VARARGS, NULL},
	 { (char *)"SdifFile_removeMarker", _wrap_SdifFile_removeMarker, METH_VARARGS, NULL},
	 { (char *)"SdifFile_addMarker", _wrap_SdifFile_addMarker, METH_VARARGS, NULL},
	 { (char *)"SdifFile_clearMarkers", _wrap_SdifFile_clearMarkers, METH_VARARGS, NULL},
	 { (char *)"SdifFile_markers", _wrap_SdifFile_markers, METH_VARARGS, NULL},
	 { (char *)"SdifFile_addMarkers", _wrap_SdifFile_addMarkers, METH_VARARGS, NULL},
	 { (char *)"SdifFile_swigregister", SdifFile_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_SpcFile", _wrap_delete_SpcFile, METH_VARARGS, NULL},
	 { (char *)"SpcFile_sampleRate", _wrap_SpcFile_sampleRate, METH_VARARGS, NULL},
	 { (char *)"SpcFile_midiNoteNumber", _wrap_SpcFile_midiNoteNumber, METH_VARARGS, NULL},
	 { (char *)"SpcFile_addPartial", _wrap_SpcFile_addPartial, METH_VARARGS, NULL},
	 { (char *)"SpcFile_setMidiNoteNumber", _wrap_SpcFile_setMidiNoteNumber, METH_VARARGS, NULL},
	 { (char *)"SpcFile_setSampleRate", _wrap_SpcFile_setSampleRate, METH_VARARGS, NULL},
	 { (char *)"SpcFile_write", _wrap_SpcFile_write, METH_VARARGS, NULL},
	 { (char *)"new_SpcFile", _wrap_new_SpcFile, METH_VARARGS, NULL},
	 { (char *)"SpcFile_partials", _wrap_SpcFile_partials, METH_VARARGS, NULL},
	 { (char *)"SpcFile_addPartials", _wrap_SpcFile_addPartials, METH_VARARGS, NULL},
	 { (char *)"SpcFile_numMarkers", _wrap_SpcFile_numMarkers, METH_VARARGS, NULL},
	 { (char *)"SpcFile_getMarker", _wrap_SpcFile_getMarker, METH_VARARGS, NULL},
	 { (char *)"SpcFile_removeMarker", _wrap_SpcFile_removeMarker, METH_VARARGS, NULL},
	 { (char *)"SpcFile_addMarker", _wrap_SpcFile_addMarker, METH_VARARGS, NULL},
	 { (char *)"SpcFile_clearMarkers", _wrap_SpcFile_clearMarkers, METH_VARARGS, NULL},
	 { (char *)"SpcFile_markers", _wrap_SpcFile_markers, METH_VARARGS, NULL},
	 { (char *)"SpcFile_addMarkers", _wrap_SpcFile_addMarkers, METH_VARARGS, NULL},
	 { (char *)"SpcFile_swigregister", SpcFile_swigregister, METH_VARARGS, NULL},
	 { (char *)"NewPlistIterator_atEnd", _wrap_NewPlistIterator_atEnd, METH_VARARGS, NULL},
	 { (char *)"NewPlistIterator_next", _wrap_NewPlistIterator_next, METH_VARARGS, NULL},
	 { (char *)"NewPlistIterator_partial", _wrap_NewPlistIterator_partial, METH_VARARGS, NULL},
	 { (char *)"NewPlistIterator_swigregister", NewPlistIterator_swigregister, METH_VARARGS, NULL},
	 { (char *)"NewPartialIterator_atEnd", _wrap_NewPartialIterator_atEnd, METH_VARARGS, NULL},
	 { (char *)"NewPartialIterator_hasNext", _wrap_NewPartialIterator_hasNext, METH_VARARGS, NULL},
	 { (char *)"NewPartialIterator_next", _wrap_NewPartialIterator_next, METH_VARARGS, NULL},
	 { (char *)"NewPartialIterator_swigregister", NewPartialIterator_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_PartialList", _wrap_new_PartialList, METH_VARARGS, NULL},
	 { (char *)"delete_PartialList", _wrap_delete_PartialList, METH_VARARGS, NULL},
	 { (char *)"PartialList_clear", _wrap_PartialList_clear, METH_VARARGS, NULL},
	 { (char *)"PartialList_size", _wrap_PartialList_size, METH_VARARGS, NULL},
	 { (char *)"PartialList_timeSpan", _wrap_PartialList_timeSpan, METH_VARARGS, NULL},
	 { (char *)"PartialList_iterator", _wrap_PartialList_iterator, METH_VARARGS, NULL},
	 { (char *)"PartialList___iter__", _wrap_PartialList___iter__, METH_VARARGS, NULL},
	 { (char *)"PartialList_append", _wrap_PartialList_append, METH_VARARGS, NULL},
	 { (char *)"PartialList_first", _wrap_PartialList_first, METH_VARARGS, NULL},
	 { (char *)"PartialList_last", _wrap_PartialList_last, METH_VARARGS, NULL},
	 { (char *)"PartialList_begin", _wrap_PartialList_begin, METH_VARARGS, NULL},
	 { (char *)"PartialList_end", _wrap_PartialList_end, METH_VARARGS, NULL},
	 { (char *)"PartialList_erase", _wrap_PartialList_erase, METH_VARARGS, NULL},
	 { (char *)"PartialList_splice", _wrap_PartialList_splice, METH_VARARGS, NULL},
	 { (char *)"PartialList_insert", _wrap_PartialList_insert, METH_VARARGS, NULL},
	 { (char *)"PartialList_copy", _wrap_PartialList_copy, METH_VARARGS, NULL},
	 { (char *)"PartialList_swigregister", PartialList_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_Partial", _wrap_new_Partial, METH_VARARGS, NULL},
	 { (char *)"delete_Partial", _wrap_delete_Partial, METH_VARARGS, NULL},
	 { (char *)"Partial_label", _wrap_Partial_label, METH_VARARGS, NULL},
	 { (char *)"Partial_initialPhase", _wrap_Partial_initialPhase, METH_VARARGS, NULL},
	 { (char *)"Partial_startTime", _wrap_Partial_startTime, METH_VARARGS, NULL},
	 { (char *)"Partial_endTime", _wrap_Partial_endTime, METH_VARARGS, NULL},
	 { (char *)"Partial_duration", _wrap_Partial_duration, METH_VARARGS, NULL},
	 { (char *)"Partial_numBreakpoints", _wrap_Partial_numBreakpoints, METH_VARARGS, NULL},
	 { (char *)"Partial_setLabel", _wrap_Partial_setLabel, METH_VARARGS, NULL},
	 { (char *)"Partial_frequencyAt", _wrap_Partial_frequencyAt, METH_VARARGS, NULL},
	 { (char *)"Partial_amplitudeAt", _wrap_Partial_amplitudeAt, METH_VARARGS, NULL},
	 { (char *)"Partial_bandwidthAt", _wrap_Partial_bandwidthAt, METH_VARARGS, NULL},
	 { (char *)"Partial_phaseAt", _wrap_Partial_phaseAt, METH_VARARGS, NULL},
	 { (char *)"Partial_iterator", _wrap_Partial_iterator, METH_VARARGS, NULL},
	 { (char *)"Partial___iter__", _wrap_Partial___iter__, METH_VARARGS, NULL},
	 { (char *)"Partial_first", _wrap_Partial_first, METH_VARARGS, NULL},
	 { (char *)"Partial_last", _wrap_Partial_last, METH_VARARGS, NULL},
	 { (char *)"Partial_begin", _wrap_Partial_begin, METH_VARARGS, NULL},
	 { (char *)"Partial_end", _wrap_Partial_end, METH_VARARGS, NULL},
	 { (char *)"Partial_erase", _wrap_Partial_erase, METH_VARARGS, NULL},
	 { (char *)"Partial_insert", _wrap_Partial_insert, METH_VARARGS, NULL},
	 { (char *)"Partial_findAfter", _wrap_Partial_findAfter, METH_VARARGS, NULL},
	 { (char *)"Partial_findNearest", _wrap_Partial_findNearest, METH_VARARGS, NULL},
	 { (char *)"Partial_copy", _wrap_Partial_copy, METH_VARARGS, NULL},
	 { (char *)"Partial_swigregister", Partial_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_Breakpoint", _wrap_new_Breakpoint, METH_VARARGS, NULL},
	 { (char *)"delete_Breakpoint", _wrap_delete_Breakpoint, METH_VARARGS, NULL},
	 { (char *)"Breakpoint_frequency", _wrap_Breakpoint_frequency, METH_VARARGS, NULL},
	 { (char *)"Breakpoint_amplitude", _wrap_Breakpoint_amplitude, METH_VARARGS, NULL},
	 { (char *)"Breakpoint_bandwidth", _wrap_Breakpoint_bandwidth, METH_VARARGS, NULL},
	 { (char *)"Breakpoint_phase", _wrap_Breakpoint_phase, METH_VARARGS, NULL},
	 { (char *)"Breakpoint_setFrequency", _wrap_Breakpoint_setFrequency, METH_VARARGS, NULL},
	 { (char *)"Breakpoint_setAmplitude", _wrap_Breakpoint_setAmplitude, METH_VARARGS, NULL},
	 { (char *)"Breakpoint_setBandwidth", _wrap_Breakpoint_setBandwidth, METH_VARARGS, NULL},
	 { (char *)"Breakpoint_setPhase", _wrap_Breakpoint_setPhase, METH_VARARGS, NULL},
	 { (char *)"Breakpoint_copy", _wrap_Breakpoint_copy, METH_VARARGS, NULL},
	 { (char *)"Breakpoint_swigregister", Breakpoint_swigregister, METH_VARARGS, NULL},
	 { (char *)"BreakpointPosition_time", _wrap_BreakpointPosition_time, METH_VARARGS, NULL},
	 { (char *)"BreakpointPosition_breakpoint", _wrap_BreakpointPosition_breakpoint, METH_VARARGS, NULL},
	 { (char *)"BreakpointPosition_frequency", _wrap_BreakpointPosition_frequency, METH_VARARGS, NULL},
	 { (char *)"BreakpointPosition_amplitude", _wrap_BreakpointPosition_amplitude, METH_VARARGS, NULL},
	 { (char *)"BreakpointPosition_bandwidth", _wrap_BreakpointPosition_bandwidth, METH_VARARGS, NULL},
	 { (char *)"BreakpointPosition_phase", _wrap_BreakpointPosition_phase, METH_VARARGS, NULL},
	 { (char *)"BreakpointPosition_setFrequency", _wrap_BreakpointPosition_setFrequency, METH_VARARGS, NULL},
	 { (char *)"BreakpointPosition_setAmplitude", _wrap_BreakpointPosition_setAmplitude, METH_VARARGS, NULL},
	 { (char *)"BreakpointPosition_setBandwidth", _wrap_BreakpointPosition_setBandwidth, METH_VARARGS, NULL},
	 { (char *)"BreakpointPosition_setPhase", _wrap_BreakpointPosition_setPhase, METH_VARARGS, NULL},
	 { (char *)"BreakpointPosition_swigregister", BreakpointPosition_swigregister, METH_VARARGS, NULL},
	 { (char *)"PartialIterator_time", _wrap_PartialIterator_time, METH_VARARGS, NULL},
	 { (char *)"PartialIterator_breakpoint", _wrap_PartialIterator_breakpoint, METH_VARARGS, NULL},
	 { (char *)"PartialIterator_copy", _wrap_PartialIterator_copy, METH_VARARGS, NULL},
	 { (char *)"PartialIterator_next", _wrap_PartialIterator_next, METH_VARARGS, NULL},
	 { (char *)"PartialIterator_prev", _wrap_PartialIterator_prev, METH_VARARGS, NULL},
	 { (char *)"PartialIterator_equals", _wrap_PartialIterator_equals, METH_VARARGS, NULL},
	 { (char *)"PartialIterator_isInRange", _wrap_PartialIterator_isInRange, METH_VARARGS, NULL},
	 { (char *)"new_PartialIterator", _wrap_new_PartialIterator, METH_VARARGS, NULL},
	 { (char *)"delete_PartialIterator", _wrap_delete_PartialIterator, METH_VARARGS, NULL},
	 { (char *)"PartialIterator_swigregister", PartialIterator_swigregister, METH_VARARGS, NULL},
	 { (char *)"PartialListIterator_copy", _wrap_PartialListIterator_copy, METH_VARARGS, NULL},
	 { (char *)"PartialListIterator_next", _wrap_PartialListIterator_next, METH_VARARGS, NULL},
	 { (char *)"PartialListIterator_prev", _wrap_PartialListIterator_prev, METH_VARARGS, NULL},
	 { (char *)"PartialListIterator_partial", _wrap_PartialListIterator_partial, METH_VARARGS, NULL},
	 { (char *)"PartialListIterator_equals", _wrap_PartialListIterator_equals, METH_VARARGS, NULL},
	 { (char *)"PartialListIterator_isInRange", _wrap_PartialListIterator_isInRange, METH_VARARGS, NULL},
	 { (char *)"new_PartialListIterator", _wrap_new_PartialListIterator, METH_VARARGS, NULL},
	 { (char *)"delete_PartialListIterator", _wrap_delete_PartialListIterator, METH_VARARGS, NULL},
	 { (char *)"PartialListIterator_swigregister", PartialListIterator_swigregister, METH_VARARGS, NULL},
	 { NULL, NULL, 0, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_PartialList[] = {{"_p_PartialList", 0, "PartialList *", 0, 0, 0, 0},{"_p_PartialList", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__std__size_t[] = {{"_std__size_t", 0, "std::size_t", 0, 0, 0, 0},{"_std__size_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__size_t[] = {{"_size_t", 0, "size_t", 0, 0, 0, 0},{"_size_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_SpcFile[] = {{"_p_SpcFile", 0, "SpcFile *", 0, 0, 0, 0},{"_p_SpcFile", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Breakpoint[] = {{"_p_Breakpoint", 0, "Breakpoint *", 0, 0, 0, 0},{"_p_Breakpoint", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__vectorTMarker_std__allocatorTMarker_t_t[] = {{"_p_std__vectorTMarker_std__allocatorTMarker_t_t", 0, "std::vector<Marker > *", 0, 0, 0, 0},{"_p_std__vectorTMarker_std__allocatorTMarker_t_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Analyzer[] = {{"_p_Analyzer", 0, "Analyzer *", 0, 0, 0, 0},{"_p_Analyzer", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_allocator_type[] = {{"_p_allocator_type", 0, "allocator_type *", 0, 0, 0, 0},{"_p_allocator_type", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_double[] = {{"_p_double", 0, "double *", 0, 0, 0, 0},{"_p_double", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Loris__Partial[] = {{"_p_Loris__Partial", 0, "Loris::Partial *", 0, 0, 0, 0},{"_p_Loris__Partial", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Partial[] = {{"_p_Partial", 0, "Partial *", 0, 0, 0, 0},{"_p_Partial", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__allocatorTdouble_t[] = {{"_p_std__allocatorTdouble_t", 0, "std::allocator<double > *|std::vector<double >::allocator_type *", 0, 0, 0, 0},{"_p_std__allocatorTdouble_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_size_type[] = {{"_p_size_type", 0, "size_type *", 0, 0, 0, 0},{"_p_size_type", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__vectorTdouble_std__allocatorTdouble_t_t[] = {{"_p_std__vectorTdouble_std__allocatorTdouble_t_t", 0, "std::vector<double > *", 0, 0, 0, 0},{"_p_std__vectorTdouble_std__allocatorTdouble_t_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_char[] = {{"_p_char", 0, "char *", 0, 0, 0, 0},{"_p_char", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_BreakpointEnvelope[] = {{"_p_BreakpointEnvelope", 0, "BreakpointEnvelope *", 0, 0, 0, 0},{"_p_BreakpointEnvelope", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_BreakpointPosition[] = {{"_p_BreakpointPosition", 0, "BreakpointPosition *", 0, 0, 0, 0},{"_p_BreakpointPosition", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_value_type[] = {{"_p_value_type", 0, "value_type *", 0, 0, 0, 0},{"_p_value_type", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_difference_type[] = {{"_p_difference_type", 0, "difference_type *", 0, 0, 0, 0},{"_p_difference_type", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__std__ptrdiff_t[] = {{"_std__ptrdiff_t", 0, "std::ptrdiff_t", 0, 0, 0, 0},{"_std__ptrdiff_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__ptrdiff_t[] = {{"_ptrdiff_t", 0, "ptrdiff_t", 0, 0, 0, 0},{"_ptrdiff_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AiffFile[] = {{"_p_AiffFile", 0, "AiffFile *", 0, 0, 0, 0},{"_p_AiffFile", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__allocatorTMarker_t[] = {{"_p_std__allocatorTMarker_t", 0, "std::allocator<Marker > *|std::vector<Marker >::allocator_type *", 0, 0, 0, 0},{"_p_std__allocatorTMarker_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_SdifFile[] = {{"_p_SdifFile", 0, "SdifFile *", 0, 0, 0, 0},{"_p_SdifFile", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Marker[] = {{"_p_Marker", 0, "Marker *", 0, 0, 0, 0},{"_p_Marker", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_NewPlistIterator[] = {{"_p_NewPlistIterator", 0, "NewPlistIterator *", 0, 0, 0, 0},{"_p_NewPlistIterator", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_NewPartialIterator[] = {{"_p_NewPartialIterator", 0, "NewPartialIterator *", 0, 0, 0, 0},{"_p_NewPartialIterator", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_PartialListIterator[] = {{"_p_PartialListIterator", 0, "PartialListIterator *", 0, 0, 0, 0},{"_p_PartialListIterator", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_PartialIterator[] = {{"_p_PartialIterator", 0, "PartialIterator *", 0, 0, 0, 0},{"_p_PartialIterator", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_PartialList, 
_swigt__std__size_t, 
_swigt__size_t, 
_swigt__p_SpcFile, 
_swigt__p_Breakpoint, 
_swigt__p_std__vectorTMarker_std__allocatorTMarker_t_t, 
_swigt__p_Analyzer, 
_swigt__p_allocator_type, 
_swigt__p_double, 
_swigt__p_Loris__Partial, 
_swigt__p_Partial, 
_swigt__p_std__allocatorTdouble_t, 
_swigt__p_size_type, 
_swigt__p_std__vectorTdouble_std__allocatorTdouble_t_t, 
_swigt__p_char, 
_swigt__p_BreakpointEnvelope, 
_swigt__p_BreakpointPosition, 
_swigt__p_value_type, 
_swigt__p_difference_type, 
_swigt__std__ptrdiff_t, 
_swigt__ptrdiff_t, 
_swigt__p_AiffFile, 
_swigt__p_std__allocatorTMarker_t, 
_swigt__p_SdifFile, 
_swigt__p_Marker, 
_swigt__p_NewPlistIterator, 
_swigt__p_NewPartialIterator, 
_swigt__p_PartialListIterator, 
_swigt__p_PartialIterator, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
extern "C" {
#endif
    
    /* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
    
    /* -----------------------------------------------------------------------------
     * global variable support code.
     * ----------------------------------------------------------------------------- */
    
    typedef struct swig_globalvar {
        char       *name;                  /* Name of global variable */
        PyObject *(*get_attr)();           /* Return the current value */
        int       (*set_attr)(PyObject *); /* Set the value */
        struct swig_globalvar *next;
    } swig_globalvar;
    
    typedef struct swig_varlinkobject {
        PyObject_HEAD
        swig_globalvar *vars;
    } swig_varlinkobject;
    
    static PyObject *
    swig_varlink_repr(swig_varlinkobject *v) {
        v = v;
        return PyString_FromString("<Swig global variables>");
    }
    
    static int
    swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
        swig_globalvar  *var;
        flags = flags;
        fprintf(fp,"Swig global variables { ");
        for (var = v->vars; var; var=var->next) {
            fprintf(fp,"%s", var->name);
            if (var->next) fprintf(fp,", ");
        }
        fprintf(fp," }\n");
        return 0;
    }
    
    static PyObject *
    swig_varlink_getattr(swig_varlinkobject *v, char *n) {
        swig_globalvar *var = v->vars;
        while (var) {
            if (strcmp(var->name,n) == 0) {
                return (*var->get_attr)();
            }
            var = var->next;
        }
        PyErr_SetString(PyExc_NameError,"Unknown C global variable");
        return NULL;
    }
    
    static int
    swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
        swig_globalvar *var = v->vars;
        while (var) {
            if (strcmp(var->name,n) == 0) {
                return (*var->set_attr)(p);
            }
            var = var->next;
        }
        PyErr_SetString(PyExc_NameError,"Unknown C global variable");
        return 1;
    }
    
    static PyTypeObject varlinktype = {
        PyObject_HEAD_INIT(0)              
        0,                                  /* Number of items in variable part (ob_size) */
        (char *)"swigvarlink",              /* Type name (tp_name) */
        sizeof(swig_varlinkobject),         /* Basic size (tp_basicsize) */
        0,                                  /* Itemsize (tp_itemsize) */
        0,                                  /* Deallocator (tp_dealloc) */ 
        (printfunc) swig_varlink_print,     /* Print (tp_print) */
        (getattrfunc) swig_varlink_getattr, /* get attr (tp_getattr) */
        (setattrfunc) swig_varlink_setattr, /* Set attr (tp_setattr) */
        0,                                  /* tp_compare */
        (reprfunc) swig_varlink_repr,       /* tp_repr */
        0,                                  /* tp_as_number */
        0,                                  /* tp_as_sequence */
        0,                                  /* tp_as_mapping */
        0,                                  /* tp_hash */
        0,                                  /* tp_call */
        0,                                  /* tp_str */
        0,                                  /* tp_getattro */
        0,                                  /* tp_setattro */
        0,                                  /* tp_as_buffer */
        0,                                  /* tp_flags */
        0,                                  /* tp_doc */
#if PY_VERSION_HEX >= 0x02000000
        0,                                  /* tp_traverse */
        0,                                  /* tp_clear */
#endif
#if PY_VERSION_HEX >= 0x02010000
        0,                                  /* tp_richcompare */
        0,                                  /* tp_weaklistoffset */
#endif
#if PY_VERSION_HEX >= 0x02020000
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
        0,                                  /* tp_del */
#endif
#ifdef COUNT_ALLOCS
        0,0,0,0                             /* tp_alloc -> tp_next */
#endif
    };
    
    /* Create a variable linking object for use later */
    static PyObject *
    SWIG_Python_newvarlink(void) {
        swig_varlinkobject *result = 0;
        result = PyMem_NEW(swig_varlinkobject,1);
        varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
        result->ob_type = &varlinktype;
        result->vars = 0;
        result->ob_refcnt = 0;
        Py_XINCREF((PyObject *) result);
        return ((PyObject*) result);
    }
    
    static void
    SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
        swig_varlinkobject *v;
        swig_globalvar *gv;
        v= (swig_varlinkobject *) p;
        gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
        gv->name = (char *) malloc(strlen(name)+1);
        strcpy(gv->name,name);
        gv->get_attr = get_attr;
        gv->set_attr = set_attr;
        gv->next = v->vars;
        v->vars = gv;
    }
    
    /* -----------------------------------------------------------------------------
     * constants/methods manipulation
     * ----------------------------------------------------------------------------- */
    
    /* Install Constants */
    static void
    SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
        PyObject *obj = 0;
        size_t i;
        for (i = 0; constants[i].type; i++) {
            switch(constants[i].type) {
                case SWIG_PY_INT:
                obj = PyInt_FromLong(constants[i].lvalue);
                break;
                case SWIG_PY_FLOAT:
                obj = PyFloat_FromDouble(constants[i].dvalue);
                break;
                case SWIG_PY_STRING:
                if (constants[i].pvalue) {
                    obj = PyString_FromString((char *) constants[i].pvalue);
                } else {
                    Py_INCREF(Py_None);
                    obj = Py_None;
                }
                break;
                case SWIG_PY_POINTER:
                obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
                break;
                case SWIG_PY_BINARY:
                obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
                break;
                default:
                obj = 0;
                break;
            }
            if (obj) {
                PyDict_SetItemString(d,constants[i].name,obj);
                Py_DECREF(obj);
            }
        }
    }
    
    /* -----------------------------------------------------------------------------*/
    /* Fix SwigMethods to carry the callback ptrs when needed */
    /* -----------------------------------------------------------------------------*/
    
    static void
    SWIG_Python_FixMethods(PyMethodDef *methods,
    swig_const_info *const_table,
    swig_type_info **types,
    swig_type_info **types_initial) {
        size_t i;
        for (i = 0; methods[i].ml_name; ++i) {
            char *c = methods[i].ml_doc;
            if (c && (c = strstr(c, "swig_ptr: "))) {
                int j;
                swig_const_info *ci = 0;
                char *name = c + 10;
                for (j = 0; const_table[j].type; j++) {
                    if (strncmp(const_table[j].name, name, 
                    strlen(const_table[j].name)) == 0) {
                        ci = &(const_table[j]);
                        break;
                    }
                }
                if (ci) {
                    size_t shift = (ci->ptype) - types;
                    swig_type_info *ty = types_initial[shift];
                    size_t ldoc = (c - methods[i].ml_doc);
                    size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
                    char *ndoc = (char*)malloc(ldoc + lptr + 10);
                    char *buff = ndoc;
                    void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue: (void *)(ci->lvalue);
                    strncpy(buff, methods[i].ml_doc, ldoc);
                    buff += ldoc;
                    strncpy(buff, "swig_ptr: ", 10);
                    buff += 10;
                    SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
                    methods[i].ml_doc = ndoc;
                }
            }
        }
    }
    
    /* -----------------------------------------------------------------------------*
     *  Initialize type list
     * -----------------------------------------------------------------------------*/
    
#if PY_MAJOR_VERSION < 2
    /* PyModule_AddObject function was introduced in Python 2.0.  The following function
    is copied out of Python/modsupport.c in python version 2.3.4 */
    static int
    PyModule_AddObject(PyObject *m, char *name, PyObject *o)
    {
        PyObject *dict;
        if (!PyModule_Check(m)) {
            PyErr_SetString(PyExc_TypeError,
            "PyModule_AddObject() needs module as first arg");
            return -1;
        }
        if (!o) {
            PyErr_SetString(PyExc_TypeError,
            "PyModule_AddObject() needs non-NULL value");
            return -1;
        }
        
        dict = PyModule_GetDict(m);
        if (dict == NULL) {
            /* Internal error -- modules must have a dict! */
            PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
            PyModule_GetName(m));
            return -1;
        }
        if (PyDict_SetItemString(dict, name, o))
        return -1;
        Py_DECREF(o);
        return 0;
    }
#endif
    
    static swig_type_info **
    SWIG_Python_SetTypeListHandle(swig_type_info **type_list_handle) {
        static PyMethodDef swig_empty_runtime_method_table[] = {
            {
                NULL, NULL, 0, NULL
            } 
        };/* Sentinel */
        
        PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
        swig_empty_runtime_method_table);
        PyObject *pointer = PyCObject_FromVoidPtr((void *) type_list_handle, NULL);
        if (pointer && module) {
            PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
        }
        return type_list_handle;
    } 
    
    static swig_type_info **
    SWIG_Python_LookupTypePointer(swig_type_info **type_list_handle) {
        swig_type_info **type_pointer;
        
        /* first check if module already created */
        type_pointer = SWIG_Python_GetTypeListHandle();
        if (type_pointer) {
            return type_pointer;
        } else {
            /* create a new module and variable */
            return SWIG_Python_SetTypeListHandle(type_list_handle);
        }
    }
    
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void *) SWIG_ReturnGlobalTypeList(void *);
#endif

#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void) SWIG_init(void) {
    static PyObject *SWIG_globals = 0; 
    static int       typeinit = 0;
    PyObject *m, *d;
    int       i;
    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
    
    /* Fix SwigMethods to carry the callback ptrs when needed */
    SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_types_initial);
    
    m = Py_InitModule((char *) SWIG_name, SwigMethods);
    d = PyModule_GetDict(m);
    
    if (!typeinit) {
#ifdef SWIG_LINK_RUNTIME
        swig_type_list_handle = (swig_type_info **) SWIG_ReturnGlobalTypeList(swig_type_list_handle);
#else
#  ifndef SWIG_STATIC_RUNTIME
        swig_type_list_handle = SWIG_Python_LookupTypePointer(swig_type_list_handle);
#  endif
#endif
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }
        typeinit = 1;
    }
    SWIG_InstallConstants(d,swig_const_table);
    
    
    Loris::setNotifier( printf_notifier );
    Loris::setExceptionHandler( throw_exception );
    
}

