/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.9
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON
/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#       endif
#endif
#else
#       define SWIGEXPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

typedef void *(*swig_converter_func)(void *);

#ifdef __cplusplus
extern "C" {
#endif

typedef struct swig_type_info {
  const char  *name;                 
  swig_converter_func converter;
  const char  *str;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE
SWIGEXPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGEXPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGEXPORT(void *) SWIG_TypeCast(swig_type_info *, void *);
SWIGEXPORT(swig_type_info *) SWIG_TypeQuery(const char *);
#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  while (s) {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  }
  return 0;
}

/* Cast a pointer (needed for C++ inheritance */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

#endif

#ifdef __cplusplus
}
#endif



/***********************************************************************
 * python.swg
 *
 *     This file contains the runtime support for Python modules
 *     and includes code for managing global variables and pointer
 *     type checking.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 ************************************************************************/

#include <stdlib.h>
#include "Python.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_PY_INT     1
#define SWIG_PY_FLOAT   2
#define SWIG_PY_STRING  3
#define SWIG_PY_POINTER 4

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

#ifdef SWIG_NOINCLUDE

SWIGEXPORT(PyObject *)        SWIG_newvarlink();
SWIGEXPORT(void)              SWIG_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
SWIGEXPORT(int)               SWIG_ConvertPtr(PyObject *, void **, swig_type_info *, int);
SWIGEXPORT(int)               SWIG_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
SWIGEXPORT(char *)            SWIG_PackData(char *c, void *, int);
SWIGEXPORT(char *)            SWIG_UnpackData(char *c, void *, int);
SWIGEXPORT(PyObject *)        SWIG_NewPointerObj(void *, swig_type_info *);
SWIGEXPORT(PyObject *)        SWIG_NewPackedObj(void *, int sz, swig_type_info *);
SWIGEXPORT(void)              SWIG_InstallConstants(PyObject *d, swig_const_info constants[]);

#else

/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */

typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

static PyObject *
swig_varlink_repr(swig_varlinkobject *v) {
  v = v;
  return PyString_FromString("<Global variables>");
}

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
  swig_globalvar  *var;
  flags = flags;
  fprintf(fp,"Global variables { ");
  for (var = v->vars; var; var=var->next) {
    fprintf(fp,"%s", var->name);
    if (var->next) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->get_attr)();
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return NULL;
}

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->set_attr)(p);
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return 1;
}

statichere PyTypeObject varlinktype = {
  PyObject_HEAD_INIT(0)              
  0,
  (char *)"swigvarlink",                      /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */
SWIGRUNTIME(PyObject *)
SWIG_newvarlink(void) {
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  result->vars = 0;
  result->ob_refcnt = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGRUNTIME(void)
SWIG_addvarlink(PyObject *p, char *name,
	   PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v;
  swig_globalvar *gv;
  v= (swig_varlinkobject *) p;
  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  gv->name = (char *) malloc(strlen(name)+1);
  strcpy(gv->name,name);
  gv->get_attr = get_attr;
  gv->set_attr = set_attr;
  gv->next = v->vars;
  v->vars = gv;
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  int i;
  unsigned char *u = (unsigned char *) ptr;
  register unsigned char uu;
  for (i = 0; i < sz; i++,u++) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  int i;
  for (i = 0; i < sz; i++, u++) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;
  static PyObject *SWIG_this = 0;
  int    newref = 0;

  if (!obj) return 0;
  if (obj == Py_None) {
    *ptr = 0;
    return 0;
  }
#ifdef SWIG_COBJECT_TYPES
  if (!(PyCObject_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_InternFromString("this");
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyCObject_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  *ptr = PyCObject_AsVoidPtr(obj);
  c = (char *) PyCObject_GetDesc(obj);
  if (newref) Py_DECREF(obj);
  goto cobject;
#else
  if (!(PyString_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_InternFromString("this");
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyString_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) {
      if (newref) Py_DECREF(obj);
      return 0;
    } else {
      if (newref) Py_DECREF(obj);
      goto type_error;
    }
  }
  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (newref) Py_DECREF(obj);
#endif

#ifdef SWIG_COBJECT_TYPES
cobject:
#endif

  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
  }
  return 0;

type_error:
  if (flags) {
    if (ty) {
      char *temp = (char *) malloc(64+strlen(ty->name));
      sprintf(temp,"Type error. Expected %s", ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Convert a packed value value */
SWIGRUNTIME(int)
SWIG_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;

  if ((!obj) || (!PyString_Check(obj))) goto type_error;
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return 0;

type_error:

  if (flags) {
    if (ty) {
      char *temp = (char *) malloc(64+strlen(ty->name));
      sprintf(temp,"Type error. Expected %s", ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Create a new pointer object */
SWIGRUNTIME(PyObject *)
SWIG_NewPointerObj(void *ptr, swig_type_info *type) {
  PyObject *robj;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#ifdef SWIG_COBJECT_TYPES
  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type->name, NULL);
#else
  {
    char result[512];
    char *r = result;
    *(r++) = '_';
    r = SWIG_PackData(r,&ptr,sizeof(void *));
    strcpy(r,type->name);
    robj = PyString_FromString(result);
  }
#endif
  return robj;
}

SWIGRUNTIME(PyObject *)
SWIG_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  return PyString_FromString(result);
}

/* Install Constants */
SWIGRUNTIME(void)
SWIG_InstallConstants(PyObject *d, swig_const_info constants[]) {
  int i;
  PyObject *obj;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_PY_INT:
      obj = PyInt_FromLong(constants[i].lvalue);
      break;
    case SWIG_PY_FLOAT:
      obj = PyFloat_FromDouble(constants[i].dvalue);
      break;
    case SWIG_PY_STRING:
      obj = PyString_FromString((char *) constants[i].pvalue);
      break;
    case SWIG_PY_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype);
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d,constants[i].name,obj);
      Py_DECREF(obj);
    }
  }
}

#endif

#ifdef __cplusplus
}
#endif







/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_Partial swig_types[0] 
#define  SWIGTYPE_p_PartialList swig_types[1] 
#define  SWIGTYPE_p_SampleVector swig_types[2] 
#define  SWIGTYPE_p_AiffFile swig_types[3] 
#define  SWIGTYPE_p_Analyzer swig_types[4] 
#define  SWIGTYPE_p_PartialListIterator swig_types[5] 
#define  SWIGTYPE_p_PartialIterator swig_types[6] 
#define  SWIGTYPE_p_Breakpoint swig_types[7] 
#define  SWIGTYPE_p_BreakpointEnvelope swig_types[8] 
static swig_type_info *swig_types[10];

/* -------- TYPES TABLE (END) -------- */


/*-----------------------------------------------
              @(target):= lorisc.so
  ------------------------------------------------*/
#define SWIG_init    initlorisc

#define SWIG_name    "lorisc"

	#include<Notifier.h>
	#include<Exception.h>
	#include <string>
	
	//	notification function for Loris debugging
	//	and notifications, installed in initialization
	//	block below:
	static void printf_notifier( const char * s )
	{
		printf("*\t%s\n", s);
	}	
	
	//	class NullPointer
	//
	//	Define a Loris::Exception subclass for catching NULL pointers.
	//	This is copied from lorisException_pi.h. It could be in Loris,
	//	but probably was never needed because Loris doesn't make much 
	//	use of pointers.
	//
	class NullPointer : public Loris::Exception
	{
	public: 
		NullPointer( const std::string & str, const std::string & where = "" ) : 
			Exception( std::string("NULL pointer exception -- ").append( str ), where ) {}
	};	//	end of class NullPointer
	
	//	define a macro for testing and throwing:
	#define ThrowIfNull(ptr) if ((ptr)==NULL) Throw( NullPointer, #ptr );	


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


static void _SWIG_exception(int code, char *msg) {
  switch(code) {
  case SWIG_MemoryError:
    PyErr_SetString(PyExc_MemoryError,msg);
    break;
  case SWIG_IOError:
    PyErr_SetString(PyExc_IOError,msg);
    break;
  case SWIG_RuntimeError:
    PyErr_SetString(PyExc_RuntimeError,msg);
    break;
  case SWIG_IndexError:
    PyErr_SetString(PyExc_IndexError,msg);
    break;
  case SWIG_TypeError:
    PyErr_SetString(PyExc_TypeError,msg);
    break;
  case SWIG_DivisionByZero:
    PyErr_SetString(PyExc_ZeroDivisionError,msg);
    break;
  case SWIG_OverflowError:
    PyErr_SetString(PyExc_OverflowError,msg);
    break;
  case SWIG_SyntaxError:
    PyErr_SetString(PyExc_SyntaxError,msg);
    break;
  case SWIG_ValueError:
    PyErr_SetString(PyExc_ValueError,msg);
    break;
  case SWIG_SystemError:
    PyErr_SetString(PyExc_SystemError,msg);
    break;
  default:
    PyErr_SetString(PyExc_RuntimeError,msg);
    break;
  }
}

#define SWIG_exception(a,b) { _SWIG_exception(a,b); return NULL; }


#include<Partial.h>
#include<Notifier.h>
#include <list>

using Loris::debugger;
using Loris::Partial;
using Loris::Breakpoint;

//	define the names of the classes that are 
//	wrapped by this interface file:
//	(additionally Partial and Breakpoint)
typedef std::list< Loris::Partial > PartialList;
typedef std::list< Loris::Partial >::iterator PartialListIterator;
typedef Loris::Partial::iterator PartialIterator;



#include<Analyzer.h>
#include<Partial.h>

using Loris::Analyzer;


#include<BreakpointEnvelope.h>
using Loris::BreakpointEnvelope;


BreakpointEnvelope * BreakpointEnvelopeWithValue_( double initialValue )
{
	return new BreakpointEnvelope( initialValue );
}


#include <stdexcept>
#include <vector>
typedef std::vector< double > SampleVector;


#include<AiffFile.h>
using Loris::AiffFile;


	#include<Channelizer.h>


	void channelize( PartialList * partials, 
					 BreakpointEnvelope * refFreqEnvelope, int refLabel )
	{
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((BreakpointEnvelope *) refFreqEnvelope);
	
		if ( refLabel <= 0 )
			Throw( Loris::InvalidArgument, "Channelization reference label must be positive." );
		
		Loris::notifier << "channelizing " << partials->size() << " Partials" << Loris::endl;
	
		Loris::Channelizer chan( *refFreqEnvelope, refLabel );
		chan.channelize( partials->begin(), partials->end() );		
	
	}
	/*	Label Partials in a PartialList with the integer nearest to
		the amplitude-weighted average ratio of their frequency envelope
		to a reference frequency envelope. The frequency spectrum is 
		partitioned into non-overlapping channels whose time-varying 
		center frequencies track the reference frequency envelope. 
		The reference label indicates which channel's center frequency
		is exactly equal to the reference envelope frequency, and other
		channels' center frequencies are multiples of the reference 
		envelope frequency divided by the reference label. Each Partial 
		in the PartialList is labeled with the number of the channel
		that best fits its frequency envelope. The quality of the fit
		is evaluated at the breakpoints in the Partial envelope and
		weighted by the amplitude at each breakpoint, so that high-
		amplitude breakpoints contribute more to the channel decision.
		Partials are labeled, but otherwise unmodified. In particular, 
		their frequencies are not modified in any way.
	 */


	#include<Dilator.h>
	#include <string>
	#include <vector>
	
	//	Helper function for dilate: 
	//
	//	convert a string into a vector of doubles,
	//	ignore any extraneous characters:
	static std::vector<double> strtovec( const std::string & s )
	{
		std::vector<double> v;
		std::string::size_type beg, end;
		const std::string numparts("1234567890+-.");
		beg = s.find_first_of( numparts );
		while ( beg != std::string::npos )
		{
			end = s.find_first_not_of( numparts, beg );
			if ( end == std::string::npos )
				end = s.length();
	
			double x = atof( s.c_str() + beg );
			v.push_back(x);
	
			beg = s.find_first_of( numparts, end );
		}
		return v;
	}


	void dilate( PartialList * partials, 
				 char * initial_times, char * target_times )
	{
		std::vector<double> ivec = strtovec( initial_times );
		std::vector<double> tvec = strtovec( target_times );
		
		Loris::debugger << ivec.size() << " initial points, " 
						<< tvec.size() << " target points" << Loris::endl;
			
		if ( ivec.size() != tvec.size() )
			Throw( Loris::InvalidArgument, "Invalid arguments to dilate(): there must be as many target points as initial points" );
				
		double * initial = ivec.begin();
		double * target = tvec.begin();
		int npts = ivec.size();
	
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((double *) initial);
		ThrowIfNull((double *) target);
	
		Loris::notifier << "dilating " << partials->size() << " Partials" << Loris::endl;
		Loris::Dilator dil( initial, target, npts );
		dil.dilate( partials->begin(), partials->end() );
	}
	/*	Dilate Partials in a PartialList according to the given 
		initial and target time points. Partial envelopes are 
		stretched and compressed so that temporal features at
		the initial time points are aligned with the final time
		points. Time points are sorted, so Partial envelopes are 
		are only stretched and compressed, but breakpoints are not
		reordered. Duplicate time points are allowed. There must be
		the same number of initial and target time points.
		
		The time points are passed as strings; convert any native
		collection to a string representation, numerical elements
		will be extracted, other characters will be ignored.
	 */


	#include<Distiller.h>


void distill( PartialList * partials )
	{
		ThrowIfNull((PartialList *) partials);
	
		Loris::notifier << "distilling " << partials->size() << " Partials" << Loris::endl;
		Loris::Distiller still;
		still.distill( *partials );
		
	}
	/*	Distill labeled (channelized)  Partials in a PartialList into a 
		PartialList containing a single (labeled) Partial per label. 
		The distilled PartialList will contain as many Partials as
		there were non-zero labels in the original PartialList. Unlabeled 
		(label 0) Partials are eliminated.
	 */


	#include<AiffFile.h>


	void exportAiff( const char * path,
					 SampleVector * samples,
					 double samplerate, int nchannels, int bitsPerSamp )
	{		
		Loris::AiffFile::Export( path, samplerate, nchannels, bitsPerSamp, 
								 samples->begin(), samples->end() );
	}
	/*	Export audio samples stored in a SampleVector to an AIFF file
		having the specified number of channels and sample rate at the 
		given file path (or name). The floating point samples in the 
		SampleVector are clamped to the range (-1.,1.) and converted 
		to integers having bitsPerSamp bits.
	 */
				 


	//	stupid name for sdif file header, name collision
	#include<SdifFile.h>


	void exportSdif( const char * path, PartialList * partials )
	{
		ThrowIfNull((PartialList *) partials);

		if ( partials->size() == 0 ) 
			Throw( Loris::InvalidObject, "No Partials in PartialList to export to sdif file." );
	
		Loris::notifier << "exporting sdif partial data to " << path << Loris::endl;		
		Loris::SdifFile::Export( path, *partials );
		
	}
	/*	Export Partials in a PartialList to a SDIF file at the specified
		file path (or name). SDIF data is written in the 1TRC format.  
		For more information about SDIF, see the SDIF website at:
			www.ircam.fr/equipes/analyse-synthese/sdif/  
	 */


	#include<SpcFile.h>


	void exportSpc( const char * path, PartialList * partials, double midiPitch, 
					int enhanced = true, double endApproachTime = 0. )
	{
		ThrowIfNull((PartialList *) partials);

		if ( partials->size() == 0 )
			Throw( Loris::InvalidObject, "No Partials in PartialList to export to Spc file." );

		Loris::notifier << "exporting Spc partial data to " << path << Loris::endl;
		Loris::SpcFile::Export( path, *partials, midiPitch, enhanced, endApproachTime );
	}
	/*	Export Partials in a PartialList to a Spc file at the specified file
		path (or name). The fractional MIDI pitch must be specified. The optional
		enhanced parameter defaults to true (for bandwidth-enhanced spc files), 
		but an be specified false for pure-sines spc files. The optional 
		endApproachTime parameter is in seconds; its default value is zero (and 
		has no effect). A nonzero endApproachTime indicates that the plist does 
		not include a release, but rather ends in a static spectrum corresponding 
		to the final breakpoint values of the partials. The endApproachTime
		specifies how long before the end of the sound the amplitude, frequency, 
		and bandwidth values are to be modified to make a gradual transition to 
		the static spectrum.
	 */


	#include<SdifFile.h>
	PartialList * importSdif( const char * path )
	{
		Loris::notifier << "importing Partials from " << path << Loris::endl;
		Loris::SdifFile imp( path );

		PartialList * partials = new PartialList();
		//	splice() can't throw, can it???
		partials->splice( partials->end(), imp.partials() );

		return partials;
	}


	#include<SpcFile.h>
	PartialList * importSpc( const char * path )
	{
		Loris::notifier << "importing Partials from " << path << Loris::endl;
		Loris::SpcFile imp( path );

		PartialList * partials = new PartialList();
		//	splice() can't throw, can it???
		partials->splice( partials->end(), imp.partials() );

		return partials;
	}


	#include<Morpher.h>
	PartialList * morph( const PartialList * src0, const PartialList * src1, 
						 const BreakpointEnvelope * ffreq, 
						 const BreakpointEnvelope * famp, 
						 const BreakpointEnvelope * fbw )
	{
		ThrowIfNull((PartialList *) src0);
		ThrowIfNull((PartialList *) src1);
		ThrowIfNull((BreakpointEnvelope *) ffreq);
		ThrowIfNull((BreakpointEnvelope *) famp);
		ThrowIfNull((BreakpointEnvelope *) fbw);

		Loris::notifier << "morphing " << src0->size() << " Partials with "
						<< src1->size() << " Partials" << Loris::endl;
					
		//	make a Morpher object and do it:
		Loris::Morpher m( *ffreq, *famp, *fbw );
		m.morph( src0->begin(), src0->end(), src1->begin(), src1->end() );
				
		//	splice the morphed Partials into a new PartialList:
		PartialList * dst = new PartialList();
		//	splice() can't throw, can it???
		dst->splice( dst->end(), m.partials() );
		return dst;
	}


	#include<Synthesizer.h>
	SampleVector * synthesize( const PartialList * partials, double srate )
	{
		ThrowIfNull((PartialList *) partials);

		Loris::notifier << "synthesizing " << partials->size() 
						<< " Partials at " << srate << " Hz" << Loris::endl;

		//	compute the duration:
		debugger << "computing duration..." << Loris::endl;
		double maxtime = 0.;
		PartialList::const_iterator it;
		for ( it = partials->begin(); it != partials->end(); ++it ) 
		{
			maxtime = std::max( maxtime, it->endTime() );
		}
		debugger << maxtime << " seconds" << Loris::endl;
		
		//	allocate a SampleVector to accomodate the fade-out at 
		//	the end of the latest Partial:
		const long nsamps = long( srate * ( maxtime + Partial::FadeTime() ) );	
		SampleVector * samples = new SampleVector( nsamps, 0. );
		
		//	synthesize:
		try
		{
			Loris::Synthesizer synth( srate, samples->begin(), samples->end() );
			for ( it = partials->begin(); it != partials->end(); ++it ) 
			{
				synth.synthesize( *it );
			}
		}
		catch(...)
		{
			delete samples;
			throw;
		}
		
		return samples;
	}


	#include<Sieve.h>


	void sift( PartialList * partials )
	{		
		
		ThrowIfNull((PartialList *) partials);

		Loris::notifier << "sifting " << partials->size() << " Partials" << Loris::endl;
		
		Loris::Sieve sieve( 0.0001 );
		sieve.sift( *partials );
	}
	/*	Lippold's wacky experimental sifting thingie: 
		If any two partials with same label overlap in time,
		keep only the longer of the two partials.
		Set the label of the shorter duration partial to zero.
		
		This used to be "experimental," and is now just 
		"transitional."
	 */


	#include <memory> 	//	 for auto_ptr
	
	BreakpointEnvelope * 
	createFreqReference( PartialList * partials, int numSamples,
						 double minFreq, double maxFreq )
	{
		ThrowIfNull((PartialList *) partials);
		
		if ( numSamples <= 0 )
			Throw( Loris::InvalidArgument, "number of samples in frequency reference must be positive." );
		
		if ( maxFreq < minFreq )
			std::swap( minFreq, maxFreq );
			
		//	find the longest Partial in the given frequency range:
		PartialList::iterator longest = partials->end();
		for ( PartialList::iterator it = partials->begin(); 
			  it != partials->end(); 
			  ++it ) 
		{
			//	evaluate the Partial's frequency at its loudest
			//	(highest sinusoidal amplitude) Breakpoint:
			Partial::const_iterator partialIter = it->begin();
			double maxAmp = 
				partialIter.breakpoint().amplitude() * std::sqrt( 1. - partialIter.breakpoint().bandwidth() );
			double time = partialIter.time();
			
			for ( ++partialIter; partialIter != it->end(); ++partialIter ) 
			{
				double a = partialIter.breakpoint().amplitude() * 
							std::sqrt( 1. - partialIter.breakpoint().bandwidth() );
				if ( a > maxAmp ) 
				{
					maxAmp = a;
					time = partialIter.time();
				}
			}			
			double compareFreq = it->frequencyAt( time );
			
			
			if ( compareFreq < minFreq || compareFreq > maxFreq )
				continue;
				
			if ( longest == partials->end() || it->duration() > longest->duration() ) 
			{
				longest = it;
			}
		}	
		
		if ( longest == partials->end() ) 
		{
			Throw( Loris::InvalidArgument, "no partials found in the specified frequency range" );
		}
	
		//	use auto_ptr to manage memory in case 
		//	an exception is generated (hard to imagine):
		std::auto_ptr< BreakpointEnvelope > env_ptr( new BreakpointEnvelope() );

		//	find n samples, ignoring the end points:
		double dt = longest->duration() / (numSamples + 1.);
		for ( int i = 0; i < numSamples; ++i ) 
		{
			double t = longest->startTime() + ((i+1) * dt);
			double f = longest->frequencyAt(t);
			env_ptr->insertBreakpoint( t, f );
		}
		
		return env_ptr.release();
	}


	#include <cmath>


	void scaleAmp( PartialList * partials, BreakpointEnvelope * ampEnv )
	{
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((BreakpointEnvelope *) ampEnv);

		Loris::notifier << "scaling amplitude of " << partials->size() << " Partials" << Loris::endl;

		PartialList::iterator listPos;
		for ( listPos = partials->begin(); listPos != partials->end(); ++listPos ) 
		{
			PartialIterator envPos;
			for ( envPos = listPos->begin(); envPos != listPos->end(); ++envPos ) 
			{		
				envPos.breakpoint().setAmplitude( envPos.breakpoint().amplitude() * ampEnv->valueAt(envPos.time()) );
			}
		}	
	}
	/*	Scale the amplitude of the Partials in a PartialList according 
		to an envelope representing a time-varying amplitude scale value.
	 */


	void scaleNoiseRatio( PartialList * partials, BreakpointEnvelope * noiseEnv )
	{
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((BreakpointEnvelope *) noiseEnv);

		Loris::notifier << "scaling noise ratio of " << partials->size() << " Partials" << Loris::endl;

		PartialList::iterator listPos;
		for ( listPos = partials->begin(); listPos != partials->end(); ++listPos ) 
		{
			PartialIterator envPos;
			for ( envPos = listPos->begin(); envPos != listPos->end(); ++envPos ) 
			{		
				//	compute new bandwidth value:
				double bw = envPos.breakpoint().bandwidth();
				if ( bw < 1. ) 
				{
					double ratio = bw  / (1. - bw);
					ratio *= noiseEnv->valueAt(envPos.time());
					bw = ratio / (1. + ratio);
				}
				else 
				{
					bw = 1.;
				}
				
				envPos.breakpoint().setBandwidth( bw );
			}
		}	
	}
	/*	Scale the relative noise content of the Partials in a PartialList 
		according to an envelope representing a (time-varying) noise energy 
		scale value.
	 */


	void shiftPitch( PartialList * partials, BreakpointEnvelope * pitchEnv )
	{
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((BreakpointEnvelope *) pitchEnv);

		Loris::notifier << "shifting pitch of " << partials->size() << " Partials" << Loris::endl;
		
		PartialList::iterator listPos;
		for ( listPos = partials->begin(); listPos != partials->end(); ++listPos ) 
		{
			PartialIterator envPos;
			for ( envPos = listPos->begin(); envPos != listPos->end(); ++envPos ) 
			{		
				//	compute frequency scale:
				double scale = 
					std::pow(2., (0.01 * pitchEnv->valueAt(envPos.time())) /12.);				
				envPos.breakpoint().setFrequency( envPos.breakpoint().frequency() * scale );
			}
		}	
	}
	/*	Shift the pitch of all Partials in a PartialList according to 
		the given pitch envelope. The pitch envelope is assumed to have 
		units of cents (1/100 of a halfstep).
	 */

#ifdef __cplusplus
extern "C" {
#endif
PartialList *PartialList_copy(PartialList *self) {
    {
        return new PartialList( *self );
    }
}


static PyObject *_wrap_PartialList_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    PyObject * argo0 =0 ;
    PartialList *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_copy",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialList *)PartialList_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList);
    return resultobj;
}


PartialList * new_PartialList() {
    {
        debugger << "creating an empty list of Partials" << Loris::endl;
        return new PartialList();
    }
}


static PyObject *_wrap_new_PartialList(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *result ;
    
    if(!PyArg_ParseTuple(args,(char *)":new_PartialList")) return NULL;
    {
        try
        {
            result = (PartialList *)new_PartialList();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList);
    return resultobj;
}


void  delete_PartialList(PartialList *self) {
    {
        debugger << "destroying  a list of " << self->size() << " Partials" << Loris::endl;
        delete self;
    }
}


static PyObject *_wrap_delete_PartialList(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PartialList",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            delete_PartialList(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_PartialList_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_clear",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            arg0->clear();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_PartialList_size(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    PyObject * argo0 =0 ;
    unsigned long result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_size",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            result = (unsigned long )arg0->size();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_PartialList_begin(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    PyObject * argo0 =0 ;
    PartialListIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_begin",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            result = new PartialListIterator (arg0->begin());
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *)result, SWIGTYPE_p_PartialListIterator);
    return resultobj;
}


static PyObject *_wrap_PartialList_end(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    PyObject * argo0 =0 ;
    PartialListIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_end",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            result = new PartialListIterator (arg0->end());
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *)result, SWIGTYPE_p_PartialListIterator);
    return resultobj;
}


static PyObject *_wrap_PartialList_insert(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    PartialListIterator *arg1 ;
    Partial *arg2 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    PyObject * argo2 =0 ;
    PartialListIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialList_insert",&argo0,&argo1,&argo2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo2,(void **) &arg2,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = new PartialListIterator (arg0->insert(*arg1,(Partial const &)*arg2));
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *)result, SWIGTYPE_p_PartialListIterator);
    return resultobj;
}


static PyObject *_wrap_PartialList_erase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    PartialListIterator *arg1 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialList_erase",&argo0,&argo1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    {
        try
        {
            arg0->erase(*arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_PartialList_splice(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    PartialListIterator *arg1 ;
    PartialList *arg2 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    PyObject * argo2 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialList_splice",&argo0,&argo1,&argo2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo2,(void **) &arg2,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            arg0->splice(*arg1,*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


PartialListIterator *PartialListIterator_copy(PartialListIterator *self) {
    {
        return new PartialListIterator( *self );
    }
}


static PyObject *_wrap_PartialListIterator_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg0 ;
    PyObject * argo0 =0 ;
    PartialListIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_copy",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListIterator);
    return resultobj;
}


PartialListIterator *PartialListIterator_next(PartialListIterator *self) {
    {
        ++(*self);
        return self;
    }
}


static PyObject *_wrap_PartialListIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg0 ;
    PyObject * argo0 =0 ;
    PartialListIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_next",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_next(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListIterator);
    return resultobj;
}


PartialListIterator *PartialListIterator_prev(PartialListIterator *self) {
    {
        --(*self);
        return self;
    }
}


static PyObject *_wrap_PartialListIterator_prev(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg0 ;
    PyObject * argo0 =0 ;
    PartialListIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_prev",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_prev(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListIterator);
    return resultobj;
}


Partial *PartialListIterator_partial(PartialListIterator *self) {
    {
        Partial & current = **self;
        return &current;
    }
}


static PyObject *_wrap_PartialListIterator_partial(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg0 ;
    PyObject * argo0 =0 ;
    Partial *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_partial",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (Partial *)PartialListIterator_partial(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Partial);
    return resultobj;
}


int PartialListIterator_equals(PartialListIterator *self,PartialListIterator *other) {
    {
        return *self == *other;
    }
}


static PyObject *_wrap_PartialListIterator_equals(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg0 ;
    PartialListIterator *arg1 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    int result ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialListIterator_equals",&argo0,&argo1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (int )PartialListIterator_equals(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


int PartialListIterator_isInRange(PartialListIterator *self,PartialListIterator const *begin,PartialListIterator const *end) {
    {
        PartialListIterator it;
        for ( it = *begin; it != *end; ++it )
        {
            if ( it == *self )
            return true;
        }
        return false;
    }
}


static PyObject *_wrap_PartialListIterator_isInRange(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg0 ;
    PartialListIterator *arg1 ;
    PartialListIterator *arg2 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    PyObject * argo2 =0 ;
    int result ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialListIterator_isInRange",&argo0,&argo1,&argo2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo2,(void **) &arg2,SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (int )PartialListIterator_isInRange(arg0,(PartialListIterator const *)arg1,(PartialListIterator const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_new_PartialListIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)":new_PartialListIterator")) return NULL;
    {
        try
        {
            result = (PartialListIterator *)new PartialListIterator();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListIterator);
    return resultobj;
}


static PyObject *_wrap_delete_PartialListIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PartialListIterator",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListIterator,1)) == -1) return NULL;
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_new_Partial(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *result ;
    
    if(!PyArg_ParseTuple(args,(char *)":new_Partial")) return NULL;
    {
        try
        {
            result = (Partial *)new Partial();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Partial);
    return resultobj;
}


static PyObject *_wrap_delete_Partial(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Partial",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Partial_label(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    PyObject * argo0 =0 ;
    int result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_label",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (int )arg0->label();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_Partial_initialPhase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_initialPhase",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->initialPhase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Partial_startTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_startTime",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->startTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Partial_endTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_endTime",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->endTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Partial_duration(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_duration",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->duration();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Partial_numBreakpoints(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    PyObject * argo0 =0 ;
    long result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_numBreakpoints",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (long )arg0->numBreakpoints();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_Partial_setLabel(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:Partial_setLabel",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            arg0->setLabel(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Partial_begin(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    PyObject * argo0 =0 ;
    PartialIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_begin",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = new PartialIterator (arg0->begin());
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *)result, SWIGTYPE_p_PartialIterator);
    return resultobj;
}


static PyObject *_wrap_Partial_end(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    PyObject * argo0 =0 ;
    PartialIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_end",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = new PartialIterator (arg0->end());
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *)result, SWIGTYPE_p_PartialIterator);
    return resultobj;
}


static PyObject *_wrap_Partial_insert(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    double arg1 ;
    Breakpoint *arg2 ;
    PyObject * argo0 =0 ;
    PyObject * argo2 =0 ;
    PartialIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"OdO:Partial_insert",&argo0,&arg1,&argo2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo2,(void **) &arg2,SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            result = new PartialIterator (arg0->insert(arg1,(Breakpoint const &)*arg2));
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *)result, SWIGTYPE_p_PartialIterator);
    return resultobj;
}


static PyObject *_wrap_Partial_findAfter(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    PartialIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_findAfter",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = new PartialIterator (arg0->findAfter(arg1));
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *)result, SWIGTYPE_p_PartialIterator);
    return resultobj;
}


static PyObject *_wrap_Partial_findNearest(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    PartialIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_findNearest",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = new PartialIterator (arg0->findNearest(arg1));
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *)result, SWIGTYPE_p_PartialIterator);
    return resultobj;
}


static PyObject *_wrap_Partial_erase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    PartialIterator *arg1 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_erase",&argo0,&argo1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            arg0->erase(*arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Partial_frequencyAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_frequencyAt",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->frequencyAt(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Partial_amplitudeAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_amplitudeAt",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->amplitudeAt(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Partial_bandwidthAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_bandwidthAt",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->bandwidthAt(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Partial_phaseAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_phaseAt",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->phaseAt(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


Partial *Partial_copy(Partial *self) {
    {
        return new Partial( *self );
    }
}


static PyObject *_wrap_Partial_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    PyObject * argo0 =0 ;
    Partial *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_copy",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (Partial *)Partial_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Partial);
    return resultobj;
}


int Partial_equals(Partial *self,Partial *other) {
    {
        return *self == *other;
    }
}


static PyObject *_wrap_Partial_equals(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg0 ;
    Partial *arg1 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    int result ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_equals",&argo0,&argo1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_Partial,1)) == -1) return NULL;
    {
        try
        {
            result = (int )Partial_equals(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_PartialIterator_time(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_time",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->time();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


Breakpoint *PartialIterator_breakpoint(PartialIterator *self) {
    {
        return &(self->breakpoint());
    }
}


static PyObject *_wrap_PartialIterator_breakpoint(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg0 ;
    PyObject * argo0 =0 ;
    Breakpoint *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_breakpoint",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (Breakpoint *)PartialIterator_breakpoint(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Breakpoint);
    return resultobj;
}


PartialIterator *PartialIterator_copy(PartialIterator *self) {
    {
        return new PartialIterator( *self );
    }
}


static PyObject *_wrap_PartialIterator_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg0 ;
    PyObject * argo0 =0 ;
    PartialIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_copy",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialIterator);
    return resultobj;
}


PartialIterator *PartialIterator_next(PartialIterator *self) {
    {
        ++(*self);
        return self;
    }
}


static PyObject *_wrap_PartialIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg0 ;
    PyObject * argo0 =0 ;
    PartialIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_next",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_next(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialIterator);
    return resultobj;
}


PartialIterator *PartialIterator_prev(PartialIterator *self) {
    {
        --(*self);
        return self;
    }
}


static PyObject *_wrap_PartialIterator_prev(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg0 ;
    PyObject * argo0 =0 ;
    PartialIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_prev",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_prev(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialIterator);
    return resultobj;
}


int PartialIterator_equals(PartialIterator *self,PartialIterator *other) {
    {
        return *self == *other;
    }
}


static PyObject *_wrap_PartialIterator_equals(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg0 ;
    PartialIterator *arg1 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    int result ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialIterator_equals",&argo0,&argo1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (int )PartialIterator_equals(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


int PartialIterator_isInRange(PartialIterator *self,PartialIterator const *begin,PartialIterator const *end) {
    {
        PartialIterator it;
        for ( it = *begin; it != *end; ++it )
        {
            if ( it == *self )
            return true;
        }
        return false;
    }
}


static PyObject *_wrap_PartialIterator_isInRange(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg0 ;
    PartialIterator *arg1 ;
    PartialIterator *arg2 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    PyObject * argo2 =0 ;
    int result ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialIterator_isInRange",&argo0,&argo1,&argo2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo2,(void **) &arg2,SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            result = (int )PartialIterator_isInRange(arg0,(PartialIterator const *)arg1,(PartialIterator const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_new_PartialIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *result ;
    
    if(!PyArg_ParseTuple(args,(char *)":new_PartialIterator")) return NULL;
    {
        try
        {
            result = (PartialIterator *)new PartialIterator();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialIterator);
    return resultobj;
}


static PyObject *_wrap_delete_PartialIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PartialIterator",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialIterator,1)) == -1) return NULL;
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_new_Breakpoint(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg0 ;
    double arg1 ;
    double arg2 ;
    double arg3 = 0. ;
    Breakpoint *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"ddd|d:new_Breakpoint",&arg0,&arg1,&arg2,&arg3)) return NULL;
    {
        try
        {
            result = (Breakpoint *)new Breakpoint(arg0,arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Breakpoint);
    return resultobj;
}


static PyObject *_wrap_delete_Breakpoint(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Breakpoint",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Breakpoint_frequency(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_frequency",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->frequency();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Breakpoint_amplitude(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_amplitude",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->amplitude();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Breakpoint_bandwidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_bandwidth",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->bandwidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Breakpoint_phase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_phase",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->phase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Breakpoint_setFrequency(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Breakpoint_setFrequency",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            arg0->setFrequency(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Breakpoint_setAmplitude(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Breakpoint_setAmplitude",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            arg0->setAmplitude(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Breakpoint_setBandwidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Breakpoint_setBandwidth",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            arg0->setBandwidth(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Breakpoint_setPhase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Breakpoint_setPhase",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            arg0->setPhase(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


Breakpoint *Breakpoint_copy(Breakpoint *self) {
    {
        return new Breakpoint( *self );
    }
}


static PyObject *_wrap_Breakpoint_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg0 ;
    PyObject * argo0 =0 ;
    Breakpoint *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_copy",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            result = (Breakpoint *)Breakpoint_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Breakpoint);
    return resultobj;
}


int Breakpoint_equals(Breakpoint *self,Breakpoint *other) {
    {
        return *self == *other;
    }
}


static PyObject *_wrap_Breakpoint_equals(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg0 ;
    Breakpoint *arg1 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    int result ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Breakpoint_equals",&argo0,&argo1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_Breakpoint,1)) == -1) return NULL;
    {
        try
        {
            result = (int )Breakpoint_equals(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_new_Analyzer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg0 ;
    Analyzer *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"d:new_Analyzer",&arg0)) return NULL;
    {
        try
        {
            result = (Analyzer *)new Analyzer(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Analyzer);
    return resultobj;
}


static PyObject *_wrap_delete_Analyzer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Analyzer",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


Analyzer *Analyzer_copy(Analyzer *self) {
    {
        return new Analyzer( self->freqResolution() );
    }
}


static PyObject *_wrap_Analyzer_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    Analyzer *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_copy",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (Analyzer *)Analyzer_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Analyzer);
    return resultobj;
}


PartialList *Analyzer_analyze(Analyzer *self,SampleVector const *vec,double srate) {
    {
        PartialList * partials = new PartialList();
        self->analyze( vec->begin(), vec->end(), srate );
        partials->splice( partials->end(), self->partials() );
        return partials;
    }
}


static PyObject *_wrap_Analyzer_analyze(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    SampleVector *arg1 ;
    double arg2 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    PartialList *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOd:Analyzer_analyze",&argo0,&argo1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialList *)Analyzer_analyze(arg0,(SampleVector const *)arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList);
    return resultobj;
}


static PyObject *_wrap_Analyzer_configure(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_configure",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            arg0->configure(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_freqResolution(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_freqResolution",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->freqResolution();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_ampFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_ampFloor",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->ampFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_windowWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_windowWidth",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->windowWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_freqFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_freqFloor",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->freqFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_hopTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_hopTime",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->hopTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_freqDrift(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_freqDrift",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->freqDrift();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_cropTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_cropTime",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->cropTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_bwRegionWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_bwRegionWidth",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->bwRegionWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_setFreqResolution(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setFreqResolution",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            arg0->setFreqResolution(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setAmpFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setAmpFloor",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            arg0->setAmpFloor(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setWindowWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setWindowWidth",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            arg0->setWindowWidth(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setFreqFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setFreqFloor",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            arg0->setFreqFloor(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setFreqDrift(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setFreqDrift",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            arg0->setFreqDrift(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setHopTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setHopTime",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            arg0->setHopTime(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setCropTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setCropTime",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            arg0->setCropTime(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setBwRegionWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setBwRegionWidth",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            arg0->setBwRegionWidth(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_new_BreakpointEnvelope(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *result ;
    
    if(!PyArg_ParseTuple(args,(char *)":new_BreakpointEnvelope")) return NULL;
    {
        try
        {
            result = (BreakpointEnvelope *)new BreakpointEnvelope();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope);
    return resultobj;
}


static PyObject *_wrap_delete_BreakpointEnvelope(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_BreakpointEnvelope",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


BreakpointEnvelope *BreakpointEnvelope_copy(BreakpointEnvelope *self) {
    {
        return new BreakpointEnvelope( *self );
    }
}


static PyObject *_wrap_BreakpointEnvelope_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg0 ;
    PyObject * argo0 =0 ;
    BreakpointEnvelope *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointEnvelope_copy",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelope_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope);
    return resultobj;
}


static PyObject *_wrap_BreakpointEnvelope_valueAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:BreakpointEnvelope_valueAt",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->valueAt(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_BreakpointEnvelope_insertBreakpoint(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg0 ;
    double arg1 ;
    double arg2 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Odd:BreakpointEnvelope_insertBreakpoint",&argo0,&arg1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            arg0->insertBreakpoint(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_BreakpointEnvelopeWithValue(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg0 ;
    BreakpointEnvelope *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"d:BreakpointEnvelopeWithValue",&arg0)) return NULL;
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelopeWithValue_(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope);
    return resultobj;
}


static PyObject *_wrap_new_SampleVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned long arg0 = 0 ;
    SampleVector *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"|l:new_SampleVector",&arg0)) return NULL;
    {
        try
        {
            result = (SampleVector *)new SampleVector(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector);
    return resultobj;
}


static PyObject *_wrap_delete_SampleVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_SampleVector",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_SampleVector_size(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg0 ;
    PyObject * argo0 =0 ;
    unsigned long result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SampleVector_size",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            result = (unsigned long )arg0->size();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_SampleVector_resize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg0 ;
    unsigned long arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Ol:SampleVector_resize",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            arg0->resize(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_SampleVector_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SampleVector_clear",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            arg0->clear();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


SampleVector *SampleVector_copy(SampleVector *self) {
    {
        return new SampleVector( *self );
    }
}


static PyObject *_wrap_SampleVector_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg0 ;
    PyObject * argo0 =0 ;
    SampleVector *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SampleVector_copy",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            result = (SampleVector *)SampleVector_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector);
    return resultobj;
}


double SampleVector_getAt(SampleVector *self,unsigned long idx) {
    {
        // return self->at(idx);	//	g++ doesn't implement at()?
        if ( idx >= self->size() )
        throw std::out_of_range("vector::at index out of range");
        return (*self)[idx];
    }
}


static PyObject *_wrap_SampleVector_getAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg0 ;
    unsigned long arg1 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"Ol:SampleVector_getAt",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            result = (double )SampleVector_getAt(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


void SampleVector_setAt(SampleVector *self,unsigned long idx,double x) {
    {
        // self->at(idx) = x;	//	g++ doesn't implement at()?
        if ( idx >= self->size() )
        throw std::out_of_range("vector::at index out of range");
        (*self)[idx] = x;
    }
}


static PyObject *_wrap_SampleVector_setAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg0 ;
    unsigned long arg1 ;
    double arg2 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Old:SampleVector_setAt",&argo0,&arg1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            SampleVector_setAt(arg0,arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_new_AiffFile(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg0 ;
    AiffFile *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"s:new_AiffFile",&arg0)) return NULL;
    {
        try
        {
            result = (AiffFile *)new AiffFile((char const *)arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AiffFile);
    return resultobj;
}


static PyObject *_wrap_delete_AiffFile(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_AiffFile",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_AiffFile_channels(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg0 ;
    PyObject * argo0 =0 ;
    int result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_channels",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            result = (int )arg0->channels();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_AiffFile_sampleFrames(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg0 ;
    PyObject * argo0 =0 ;
    unsigned long result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_sampleFrames",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            result = (unsigned long )arg0->sampleFrames();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_AiffFile_sampleRate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_sampleRate",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            result = (double )arg0->sampleRate();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_AiffFile_sampleSize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg0 ;
    PyObject * argo0 =0 ;
    int result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_sampleSize",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            result = (int )arg0->sampleSize();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


SampleVector *AiffFile_samples(AiffFile *self) {
    {
        SampleVector * vec = new SampleVector( self->sampleFrames(), 0. );
        self->getSamples( vec->begin(), vec->end() );
        return vec;
    }
}


static PyObject *_wrap_AiffFile_samples(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg0 ;
    PyObject * argo0 =0 ;
    SampleVector *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_samples",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            result = (SampleVector *)AiffFile_samples(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector);
    return resultobj;
}


static PyObject *_wrap_channelize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    BreakpointEnvelope *arg1 ;
    int arg2 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOi:channelize",&argo0,&argo1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            channelize(arg0,arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_dilate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    char *arg1 ;
    char *arg2 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oss:dilate",&argo0,&arg1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            dilate(arg0,arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_distill(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:distill",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            distill(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_exportAiff(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg0 ;
    SampleVector *arg1 ;
    double arg2 ;
    int arg3 ;
    int arg4 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sOdii:exportAiff",&arg0,&argo1,&arg2,&arg3,&arg4)) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            exportAiff((char const *)arg0,arg1,arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_exportSdif(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg0 ;
    PartialList *arg1 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sO:exportSdif",&arg0,&argo1)) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            exportSdif((char const *)arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_exportSpc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg0 ;
    PartialList *arg1 ;
    double arg2 ;
    int arg3 = true ;
    double arg4 = 0. ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sOd|id:exportSpc",&arg0,&argo1,&arg2,&arg3,&arg4)) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            exportSpc((char const *)arg0,arg1,arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_importSdif(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg0 ;
    PartialList *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"s:importSdif",&arg0)) return NULL;
    {
        try
        {
            result = (PartialList *)importSdif((char const *)arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList);
    return resultobj;
}


static PyObject *_wrap_importSpc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg0 ;
    PartialList *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"s:importSpc",&arg0)) return NULL;
    {
        try
        {
            result = (PartialList *)importSpc((char const *)arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList);
    return resultobj;
}


static PyObject *_wrap_morph(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    PartialList *arg1 ;
    BreakpointEnvelope *arg2 ;
    BreakpointEnvelope *arg3 ;
    BreakpointEnvelope *arg4 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    PyObject * argo2 =0 ;
    PyObject * argo3 =0 ;
    PyObject * argo4 =0 ;
    PartialList *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:morph",&argo0,&argo1,&argo2,&argo3,&argo4)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo2,(void **) &arg2,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo3,(void **) &arg3,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo4,(void **) &arg4,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            result = (PartialList *)morph((PartialList const *)arg0,(PartialList const *)arg1,(BreakpointEnvelope const *)arg2,(BreakpointEnvelope const *)arg3,(BreakpointEnvelope const *)arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList);
    return resultobj;
}


static PyObject *_wrap_synthesize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    SampleVector *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:synthesize",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            result = (SampleVector *)synthesize((PartialList const *)arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector);
    return resultobj;
}


static PyObject *_wrap_sift(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:sift",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            sift(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_createFreqReference(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    int arg1 ;
    double arg2 ;
    double arg3 ;
    PyObject * argo0 =0 ;
    BreakpointEnvelope *result ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oidd:createFreqReference",&argo0,&arg1,&arg2,&arg3)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    {
        try
        {
            result = (BreakpointEnvelope *)createFreqReference(arg0,arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope);
    return resultobj;
}


static PyObject *_wrap_scaleAmp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    BreakpointEnvelope *arg1 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleAmp",&argo0,&argo1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            scaleAmp(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_scaleNoiseRatio(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    BreakpointEnvelope *arg1 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleNoiseRatio",&argo0,&argo1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            scaleNoiseRatio(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_shiftPitch(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg0 ;
    BreakpointEnvelope *arg1 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:shiftPitch",&argo0,&argo1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialList,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            shiftPitch(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyMethodDef loriscMethods[] = {
	 { (char *)"PartialList_copy", _wrap_PartialList_copy, METH_VARARGS },
	 { (char *)"new_PartialList", _wrap_new_PartialList, METH_VARARGS },
	 { (char *)"delete_PartialList", _wrap_delete_PartialList, METH_VARARGS },
	 { (char *)"PartialList_clear", _wrap_PartialList_clear, METH_VARARGS },
	 { (char *)"PartialList_size", _wrap_PartialList_size, METH_VARARGS },
	 { (char *)"PartialList_begin", _wrap_PartialList_begin, METH_VARARGS },
	 { (char *)"PartialList_end", _wrap_PartialList_end, METH_VARARGS },
	 { (char *)"PartialList_insert", _wrap_PartialList_insert, METH_VARARGS },
	 { (char *)"PartialList_erase", _wrap_PartialList_erase, METH_VARARGS },
	 { (char *)"PartialList_splice", _wrap_PartialList_splice, METH_VARARGS },
	 { (char *)"PartialListIterator_copy", _wrap_PartialListIterator_copy, METH_VARARGS },
	 { (char *)"PartialListIterator_next", _wrap_PartialListIterator_next, METH_VARARGS },
	 { (char *)"PartialListIterator_prev", _wrap_PartialListIterator_prev, METH_VARARGS },
	 { (char *)"PartialListIterator_partial", _wrap_PartialListIterator_partial, METH_VARARGS },
	 { (char *)"PartialListIterator_equals", _wrap_PartialListIterator_equals, METH_VARARGS },
	 { (char *)"PartialListIterator_isInRange", _wrap_PartialListIterator_isInRange, METH_VARARGS },
	 { (char *)"new_PartialListIterator", _wrap_new_PartialListIterator, METH_VARARGS },
	 { (char *)"delete_PartialListIterator", _wrap_delete_PartialListIterator, METH_VARARGS },
	 { (char *)"new_Partial", _wrap_new_Partial, METH_VARARGS },
	 { (char *)"delete_Partial", _wrap_delete_Partial, METH_VARARGS },
	 { (char *)"Partial_label", _wrap_Partial_label, METH_VARARGS },
	 { (char *)"Partial_initialPhase", _wrap_Partial_initialPhase, METH_VARARGS },
	 { (char *)"Partial_startTime", _wrap_Partial_startTime, METH_VARARGS },
	 { (char *)"Partial_endTime", _wrap_Partial_endTime, METH_VARARGS },
	 { (char *)"Partial_duration", _wrap_Partial_duration, METH_VARARGS },
	 { (char *)"Partial_numBreakpoints", _wrap_Partial_numBreakpoints, METH_VARARGS },
	 { (char *)"Partial_setLabel", _wrap_Partial_setLabel, METH_VARARGS },
	 { (char *)"Partial_begin", _wrap_Partial_begin, METH_VARARGS },
	 { (char *)"Partial_end", _wrap_Partial_end, METH_VARARGS },
	 { (char *)"Partial_insert", _wrap_Partial_insert, METH_VARARGS },
	 { (char *)"Partial_findAfter", _wrap_Partial_findAfter, METH_VARARGS },
	 { (char *)"Partial_findNearest", _wrap_Partial_findNearest, METH_VARARGS },
	 { (char *)"Partial_erase", _wrap_Partial_erase, METH_VARARGS },
	 { (char *)"Partial_frequencyAt", _wrap_Partial_frequencyAt, METH_VARARGS },
	 { (char *)"Partial_amplitudeAt", _wrap_Partial_amplitudeAt, METH_VARARGS },
	 { (char *)"Partial_bandwidthAt", _wrap_Partial_bandwidthAt, METH_VARARGS },
	 { (char *)"Partial_phaseAt", _wrap_Partial_phaseAt, METH_VARARGS },
	 { (char *)"Partial_copy", _wrap_Partial_copy, METH_VARARGS },
	 { (char *)"Partial_equals", _wrap_Partial_equals, METH_VARARGS },
	 { (char *)"PartialIterator_time", _wrap_PartialIterator_time, METH_VARARGS },
	 { (char *)"PartialIterator_breakpoint", _wrap_PartialIterator_breakpoint, METH_VARARGS },
	 { (char *)"PartialIterator_copy", _wrap_PartialIterator_copy, METH_VARARGS },
	 { (char *)"PartialIterator_next", _wrap_PartialIterator_next, METH_VARARGS },
	 { (char *)"PartialIterator_prev", _wrap_PartialIterator_prev, METH_VARARGS },
	 { (char *)"PartialIterator_equals", _wrap_PartialIterator_equals, METH_VARARGS },
	 { (char *)"PartialIterator_isInRange", _wrap_PartialIterator_isInRange, METH_VARARGS },
	 { (char *)"new_PartialIterator", _wrap_new_PartialIterator, METH_VARARGS },
	 { (char *)"delete_PartialIterator", _wrap_delete_PartialIterator, METH_VARARGS },
	 { (char *)"new_Breakpoint", _wrap_new_Breakpoint, METH_VARARGS },
	 { (char *)"delete_Breakpoint", _wrap_delete_Breakpoint, METH_VARARGS },
	 { (char *)"Breakpoint_frequency", _wrap_Breakpoint_frequency, METH_VARARGS },
	 { (char *)"Breakpoint_amplitude", _wrap_Breakpoint_amplitude, METH_VARARGS },
	 { (char *)"Breakpoint_bandwidth", _wrap_Breakpoint_bandwidth, METH_VARARGS },
	 { (char *)"Breakpoint_phase", _wrap_Breakpoint_phase, METH_VARARGS },
	 { (char *)"Breakpoint_setFrequency", _wrap_Breakpoint_setFrequency, METH_VARARGS },
	 { (char *)"Breakpoint_setAmplitude", _wrap_Breakpoint_setAmplitude, METH_VARARGS },
	 { (char *)"Breakpoint_setBandwidth", _wrap_Breakpoint_setBandwidth, METH_VARARGS },
	 { (char *)"Breakpoint_setPhase", _wrap_Breakpoint_setPhase, METH_VARARGS },
	 { (char *)"Breakpoint_copy", _wrap_Breakpoint_copy, METH_VARARGS },
	 { (char *)"Breakpoint_equals", _wrap_Breakpoint_equals, METH_VARARGS },
	 { (char *)"new_Analyzer", _wrap_new_Analyzer, METH_VARARGS },
	 { (char *)"delete_Analyzer", _wrap_delete_Analyzer, METH_VARARGS },
	 { (char *)"Analyzer_copy", _wrap_Analyzer_copy, METH_VARARGS },
	 { (char *)"Analyzer_analyze", _wrap_Analyzer_analyze, METH_VARARGS },
	 { (char *)"Analyzer_configure", _wrap_Analyzer_configure, METH_VARARGS },
	 { (char *)"Analyzer_freqResolution", _wrap_Analyzer_freqResolution, METH_VARARGS },
	 { (char *)"Analyzer_ampFloor", _wrap_Analyzer_ampFloor, METH_VARARGS },
	 { (char *)"Analyzer_windowWidth", _wrap_Analyzer_windowWidth, METH_VARARGS },
	 { (char *)"Analyzer_freqFloor", _wrap_Analyzer_freqFloor, METH_VARARGS },
	 { (char *)"Analyzer_hopTime", _wrap_Analyzer_hopTime, METH_VARARGS },
	 { (char *)"Analyzer_freqDrift", _wrap_Analyzer_freqDrift, METH_VARARGS },
	 { (char *)"Analyzer_cropTime", _wrap_Analyzer_cropTime, METH_VARARGS },
	 { (char *)"Analyzer_bwRegionWidth", _wrap_Analyzer_bwRegionWidth, METH_VARARGS },
	 { (char *)"Analyzer_setFreqResolution", _wrap_Analyzer_setFreqResolution, METH_VARARGS },
	 { (char *)"Analyzer_setAmpFloor", _wrap_Analyzer_setAmpFloor, METH_VARARGS },
	 { (char *)"Analyzer_setWindowWidth", _wrap_Analyzer_setWindowWidth, METH_VARARGS },
	 { (char *)"Analyzer_setFreqFloor", _wrap_Analyzer_setFreqFloor, METH_VARARGS },
	 { (char *)"Analyzer_setFreqDrift", _wrap_Analyzer_setFreqDrift, METH_VARARGS },
	 { (char *)"Analyzer_setHopTime", _wrap_Analyzer_setHopTime, METH_VARARGS },
	 { (char *)"Analyzer_setCropTime", _wrap_Analyzer_setCropTime, METH_VARARGS },
	 { (char *)"Analyzer_setBwRegionWidth", _wrap_Analyzer_setBwRegionWidth, METH_VARARGS },
	 { (char *)"new_BreakpointEnvelope", _wrap_new_BreakpointEnvelope, METH_VARARGS },
	 { (char *)"delete_BreakpointEnvelope", _wrap_delete_BreakpointEnvelope, METH_VARARGS },
	 { (char *)"BreakpointEnvelope_copy", _wrap_BreakpointEnvelope_copy, METH_VARARGS },
	 { (char *)"BreakpointEnvelope_valueAt", _wrap_BreakpointEnvelope_valueAt, METH_VARARGS },
	 { (char *)"BreakpointEnvelope_insertBreakpoint", _wrap_BreakpointEnvelope_insertBreakpoint, METH_VARARGS },
	 { (char *)"BreakpointEnvelopeWithValue", _wrap_BreakpointEnvelopeWithValue, METH_VARARGS },
	 { (char *)"new_SampleVector", _wrap_new_SampleVector, METH_VARARGS },
	 { (char *)"delete_SampleVector", _wrap_delete_SampleVector, METH_VARARGS },
	 { (char *)"SampleVector_size", _wrap_SampleVector_size, METH_VARARGS },
	 { (char *)"SampleVector_resize", _wrap_SampleVector_resize, METH_VARARGS },
	 { (char *)"SampleVector_clear", _wrap_SampleVector_clear, METH_VARARGS },
	 { (char *)"SampleVector_copy", _wrap_SampleVector_copy, METH_VARARGS },
	 { (char *)"SampleVector_getAt", _wrap_SampleVector_getAt, METH_VARARGS },
	 { (char *)"SampleVector_setAt", _wrap_SampleVector_setAt, METH_VARARGS },
	 { (char *)"new_AiffFile", _wrap_new_AiffFile, METH_VARARGS },
	 { (char *)"delete_AiffFile", _wrap_delete_AiffFile, METH_VARARGS },
	 { (char *)"AiffFile_channels", _wrap_AiffFile_channels, METH_VARARGS },
	 { (char *)"AiffFile_sampleFrames", _wrap_AiffFile_sampleFrames, METH_VARARGS },
	 { (char *)"AiffFile_sampleRate", _wrap_AiffFile_sampleRate, METH_VARARGS },
	 { (char *)"AiffFile_sampleSize", _wrap_AiffFile_sampleSize, METH_VARARGS },
	 { (char *)"AiffFile_samples", _wrap_AiffFile_samples, METH_VARARGS },
	 { (char *)"channelize", _wrap_channelize, METH_VARARGS },
	 { (char *)"dilate", _wrap_dilate, METH_VARARGS },
	 { (char *)"distill", _wrap_distill, METH_VARARGS },
	 { (char *)"exportAiff", _wrap_exportAiff, METH_VARARGS },
	 { (char *)"exportSdif", _wrap_exportSdif, METH_VARARGS },
	 { (char *)"exportSpc", _wrap_exportSpc, METH_VARARGS },
	 { (char *)"importSdif", _wrap_importSdif, METH_VARARGS },
	 { (char *)"importSpc", _wrap_importSpc, METH_VARARGS },
	 { (char *)"morph", _wrap_morph, METH_VARARGS },
	 { (char *)"synthesize", _wrap_synthesize, METH_VARARGS },
	 { (char *)"sift", _wrap_sift, METH_VARARGS },
	 { (char *)"createFreqReference", _wrap_createFreqReference, METH_VARARGS },
	 { (char *)"scaleAmp", _wrap_scaleAmp, METH_VARARGS },
	 { (char *)"scaleNoiseRatio", _wrap_scaleNoiseRatio, METH_VARARGS },
	 { (char *)"shiftPitch", _wrap_shiftPitch, METH_VARARGS },
	 { NULL, NULL }
};

#ifdef __cplusplus
}
#endif

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_Partial[] = {{"_p_Partial", 0, "Partial *"},{"_p_Partial"},{0}};
static swig_type_info _swigt__p_PartialList[] = {{"_p_PartialList", 0, "PartialList *"},{"_p_PartialList"},{0}};
static swig_type_info _swigt__p_SampleVector[] = {{"_p_SampleVector", 0, "SampleVector *"},{"_p_SampleVector"},{0}};
static swig_type_info _swigt__p_AiffFile[] = {{"_p_AiffFile", 0, "AiffFile *"},{"_p_AiffFile"},{0}};
static swig_type_info _swigt__p_Analyzer[] = {{"_p_Analyzer", 0, "Analyzer *"},{"_p_Analyzer"},{0}};
static swig_type_info _swigt__p_PartialListIterator[] = {{"_p_PartialListIterator", 0, "PartialListIterator *"},{"_p_PartialListIterator"},{0}};
static swig_type_info _swigt__p_PartialIterator[] = {{"_p_PartialIterator", 0, "PartialIterator *"},{"_p_PartialIterator"},{0}};
static swig_type_info _swigt__p_Breakpoint[] = {{"_p_Breakpoint", 0, "Breakpoint *"},{"_p_Breakpoint"},{0}};
static swig_type_info _swigt__p_BreakpointEnvelope[] = {{"_p_BreakpointEnvelope", 0, "BreakpointEnvelope *"},{"_p_BreakpointEnvelope"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_Partial, 
_swigt__p_PartialList, 
_swigt__p_SampleVector, 
_swigt__p_AiffFile, 
_swigt__p_Analyzer, 
_swigt__p_PartialListIterator, 
_swigt__p_PartialIterator, 
_swigt__p_Breakpoint, 
_swigt__p_BreakpointEnvelope, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0}};

static PyObject *SWIG_globals;
#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT(void) initlorisc(void) {
    PyObject *m, *d;
    int i;
    SWIG_globals = SWIG_newvarlink();
    m = Py_InitModule((char*)"lorisc", loriscMethods);
    d = PyModule_GetDict(m);
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
    }
    
    Loris::setNotifierHandler( printf_notifier );
    Loris::setDebuggerHandler( printf_notifier );
    
    SWIG_InstallConstants(d,swig_const_table);
}

