/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3u-20000712-1502 (Alpha 5)
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON
/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#       endif
#endif
#else
#       define SWIGEXPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct swig_type_info {
  char  *name;                 
  void *(*converter)(void *);
  char  *str;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE
SWIGEXPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGEXPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGEXPORT(void *) SWIG_TypeCast(swig_type_info *, void *);
#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  while (s) {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  }
  return 0;
}

/* Cast a pointer (needed for C++ inheritance */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(void *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

#endif

#ifdef __cplusplus
}
#endif



/***********************************************************************
 * python.swg
 *
 *     This file contains the runtime support for Python modules
 *     and includes code for managing global variables and pointer
 *     type checking.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 ************************************************************************/

#include <stdlib.h>
#include "Python.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_PY_INT     1
#define SWIG_PY_FLOAT   2
#define SWIG_PY_STRING  3
#define SWIG_PY_POINTER 4

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

#ifdef SWIG_NOINCLUDE

SWIGEXPORT(PyObject *)        SWIG_newvarlink();
SWIGEXPORT(void)              SWIG_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
SWIGEXPORT(int)               SWIG_ConvertPtr(PyObject *, void **, swig_type_info *, int);
SWIGEXPORT(void)              SWIG_MakePtr(char *c, void *, swig_type_info *);
SWIGEXPORT(PyObject *)        SWIG_NewPointerObj(void *, swig_type_info *);
SWIGEXPORT(void)              SWIG_InstallConstants(PyObject *d, swig_const_info constants[]);

#else

/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */

typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

static PyObject *
swig_varlink_repr(swig_varlinkobject *v) {
  v = v;
  return PyString_FromString("<Global variables>");
}

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
  swig_globalvar  *var;
  flags = flags;
  fprintf(fp,"Global variables { ");
  for (var = v->vars; var; var=var->next) {
    fprintf(fp,"%s", var->name);
    if (var->next) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->get_attr)();
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return NULL;
}

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->set_attr)(p);
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return 1;
}

statichere PyTypeObject varlinktype = {
  PyObject_HEAD_INIT(0)              
  0,
  "swigvarlink",                      /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */
SWIGRUNTIME(PyObject *)
SWIG_newvarlink(void) {
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  result->vars = 0;
  result->ob_refcnt = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGRUNTIME(void)
SWIG_addvarlink(PyObject *p, char *name,
	   PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v;
  swig_globalvar *gv;
  v= (swig_varlinkobject *) p;
  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  gv->name = (char *) malloc(strlen(name)+1);
  strcpy(gv->name,name);
  gv->get_attr = get_attr;
  gv->set_attr = set_attr;
  gv->next = v->vars;
  v->vars = gv;
}
/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
  unsigned long p;
  register int d;
  swig_type_info *tc;
  char  *c;
  static PyObject *SWIG_this = 0;
  int    newref = 0;

  if (!obj || (obj == Py_None)) {
    *ptr = 0;
    return 0;
  }
#ifdef SWIG_COBJECT_TYPES
  if (!(PyCObject_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_InternFromString("this");
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyCObject_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  *ptr = PyCObject_AsVoidPtr(obj);
  c = (char *) PyCObject_GetDesc(obj);
  if (newref) Py_DECREF(obj);
  goto cobject;
#else
  if (!(PyString_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_InternFromString("this");
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyString_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  c = PyString_AsString(obj);
  p = 0;
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) {
      if (newref) Py_DECREF(obj);
      return 0;
    } else {
      if (newref) Py_DECREF(obj);
      goto type_error;
    }
  }
  c++;
  /* Extract hex value from pointer */
  while ((d = *c)) {
    if ((d >= '0') && (d <= '9'))
      p = (p << 4) + (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      p = (p << 4) + (d - ('a'-10));
    else
      break; 
    c++;
  }
  *ptr = (void *) p;
  if (newref) Py_DECREF(obj);
#endif

#ifdef SWIG_COBJECT_TYPES
cobject:
#endif

  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
    *ptr = SWIG_TypeCast(tc,(void*)p);
  }
  return 0;

type_error:

  if (flags) {
    if (ty) {
      char *temp = (char *) malloc(64+strlen(ty->name));
      sprintf(temp,"Type error. Expected %s", ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Take a pointer and convert it to a string */
SWIGRUNTIME(void) 
SWIG_MakePtr(char *c, void *ptr, swig_type_info *ty) {
  static char hex[17] = "0123456789abcdef";
  unsigned long p, s;
  char result[32], *r; 
  r = result;
  p = (unsigned long) ptr;
  if (p > 0) {
    while (p > 0) {
      s = p & 0xf;
      *(r++) = hex[s];
      p = p >> 4;
    }
    *r = '_';
    while (r >= result)
      *(c++) = *(r--);
    strcpy (c, ty->name);
  } else {
    strcpy (c, "NULL");
  }
}

/* Create a new pointer object */
SWIGRUNTIME(PyObject *)
SWIG_NewPointerObj(void *ptr, swig_type_info *type) {
  char result[512];
  PyObject *robj;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#ifdef SWIG_COBJECT_TYPES
  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, type->name, NULL);
#else
  SWIG_MakePtr(result,ptr,type);
  robj = PyString_FromString(result);
#endif
  return robj;
}

/* Install Constants */
SWIGRUNTIME(void)
SWIG_InstallConstants(PyObject *d, swig_const_info constants[]) {
  int i;
  PyObject *obj;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_PY_INT:
      obj = PyInt_FromLong(constants[i].lvalue);
      break;
    case SWIG_PY_FLOAT:
      obj = PyFloat_FromDouble(constants[i].dvalue);
      break;
    case SWIG_PY_STRING:
      obj = PyString_FromString((char *) constants[i].pvalue);
      break;
    case SWIG_PY_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype);
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d,constants[i].name,obj);
      Py_DECREF(obj);
    }
  }
}

#endif

#ifdef __cplusplus
}
#endif



/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_ExportSpc swig_types[0] 
#define  SWIGTYPE_p_SampleVector swig_types[1] 
#define  SWIGTYPE_p_PartialListHandle swig_types[2] 
#define  SWIGTYPE_p_PartialListHandleIteratorHandle swig_types[3] 
#define  SWIGTYPE_p_BreakpointHandle swig_types[4] 
#define  SWIGTYPE_p_AiffFile swig_types[5] 
#define  SWIGTYPE_p_Analyzer swig_types[6] 
#define  SWIGTYPE_p_BreakpointEnvelope swig_types[7] 
static swig_type_info *swig_types[9];

/* -------- TYPES TABLE (END) -------- */


/*-----------------------------------------------
              @(target):= lorisc.so
  ------------------------------------------------*/
#define SWIG_init    initlorisc

#define SWIG_name    "lorisc"

#define LORIS_OPAQUE_POINTERS 0
#include "loris.h"

#include <string>
#include <vector>

//	convert a string into a vector of doubles,
//	ignore any extraneous characters:
static std::vector<double> strtovec( const std::string & s )
{
    std::vector<double> v;
    std::string::size_type beg, end;
    //const string delims(" \t,[](){}");
    const std::string numparts("1234567890+-.");
    beg = s.find_first_of( numparts );
    while ( beg != std::string::npos )
    {
        end = s.find_first_not_of( numparts, beg );
        if ( end == std::string::npos )
            end = s.length();

        double x = atof( s.c_str() + beg );
        v.push_back(x);

        beg = s.find_first_of( numparts, end );
    }
    return v;
}

//	notification function for Loris exceptions
//	and notifications, installed in initialization
//	block below:
static void printf_notifier( const char * s )
{
	printf("*\t%s\n", s);
}

//	Exceptions absolutely cannot be thrown out of a shared
//	library on the Macintosh, so instead of rethrowing, 
//	store the error string from internal Loris exceptions
//	and catch it in the SWIG exception handler below:
//
//	Loris is no longer a shared library on the Mac, since
//	those are too fragile. Exceptions caught in the procedural
//	interface are still handled with this mechanism, but 
//	when the procedural interface is not used, then bona
//	fide C++ exceptions may make it out to the wrapper code,
//	so Loris::Exceptions and std::exceptions still need to be
//	handled below.
//
static std::string LorisErrorString;
static void throw_string( const char * s )
{
	LorisErrorString = s;
}

#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99

static void _SWIG_exception(int code, char *msg) {
  switch(code) {
  case SWIG_MemoryError:
    PyErr_SetString(PyExc_MemoryError,msg);
    break;
  case SWIG_IOError:
    PyErr_SetString(PyExc_IOError,msg);
    break;
  case SWIG_RuntimeError:
    PyErr_SetString(PyExc_RuntimeError,msg);
    break;
  case SWIG_IndexError:
    PyErr_SetString(PyExc_IndexError,msg);
    break;
  case SWIG_TypeError:
    PyErr_SetString(PyExc_TypeError,msg);
    break;
  case SWIG_DivisionByZero:
    PyErr_SetString(PyExc_ZeroDivisionError,msg);
    break;
  case SWIG_OverflowError:
    PyErr_SetString(PyExc_OverflowError,msg);
    break;
  case SWIG_SyntaxError:
    PyErr_SetString(PyExc_SyntaxError,msg);
    break;
  case SWIG_ValueError:
    PyErr_SetString(PyExc_ValueError,msg);
    break;
  case SWIG_SystemError:
    PyErr_SetString(PyExc_SystemError,msg);
    break;
  default:
    PyErr_SetString(PyExc_RuntimeError,msg);
    break;
  }
}

#define SWIG_exception(a,b) { _SWIG_exception(a,b); return NULL; }

static PyObject* l_output_helper(PyObject* target, PyObject* o) {
    PyObject*   o2;
    if (!target) {                   
        target = o;
    } else if (target == Py_None) {  
        Py_DECREF(Py_None);
        target = o;
    } else {                         
        if (!PyList_Check(target)) {
            o2 = target;
            target = PyList_New(0);
            PyList_Append(target, o2);
	    Py_XDECREF(o2);
        }
        PyList_Append(target,o);
	Py_XDECREF(o);
    }
    return target;
}

static PyObject* t_output_helper(PyObject* target, PyObject* o) {
    PyObject*   o2;
    PyObject*   o3;

    if (!target) {                   
        target = o;
    } else if (target == Py_None) {  
        Py_DECREF(Py_None);
        target = o;
    } else {                         
        if (!PyTuple_Check(target)) {
            o2 = target;
            target = PyTuple_New(1);
            PyTuple_SetItem(target, 0, o2);
        }
        o3 = PyTuple_New(1);            
        PyTuple_SetItem(o3, 0, o);      

        o2 = target;
        target = PySequence_Concat(o2, o3); 
        Py_DECREF(o2);                      
        Py_DECREF(o3);
    }
    return target;
}

#include "Handle.h"
#include "Partial.h"
#include "notifier.h"
#include <list>

using Loris::debugger;
using Loris::endl;

typedef Loris::Handle< std::list< Loris::Partial > > PartialListHandle;


	class PartialListHandleIterator
	{
		PartialListHandle _list;
		std::list< Loris::Partial >::iterator _iter;
		
		//	no default constructor:
		PartialListHandleIterator( void );
		
		public:
		//	construction:
		PartialListHandleIterator( PartialListHandle hlist ) :
			_list( hlist ),
			_iter( hlist->begin() )
		{
			debugger << "created an iterator on a list of " << _list->size() << " Partials" << std::endl;
		}
		
		//	better be careful that pos is an iterator of *hlist!
		PartialListHandleIterator( PartialListHandle hlist, std::list< Loris::Partial >::iterator pos ) :
			_list( hlist ),
			_iter( pos )
		{
			debugger << "created an iterator on a list of " << _list->size() << " Partials" << std::endl;
		}
		
		PartialListHandleIterator( const PartialListHandleIterator & rhs ) :
			_list( rhs._list ),
			_iter( rhs._iter )
		{
			debugger << "copied an iterator on a list of " << _list->size() << " Partials" << std::endl;
		}
		
		PartialListHandleIterator & operator= ( const PartialListHandleIterator & rhs )
		{
			if ( &rhs != this )
			{
				_list = rhs._list;
				_iter = rhs._iter;
			}
			debugger << "assigned an iterator on a list of " << _list->size() << " Partials" << std::endl;
			
			return *this;
		}
			
		~PartialListHandleIterator( void )
		{
			debugger << "destroyed an iterator on a list of " << _list->size() << " Partials" << std::endl;
		}
		
		//	Iterator pattern:
		//	(except current(), which isn't useful here)
		void next( void )
		{
			if ( ! atEnd() )
				++_iter;
		}
		
		bool atEnd( void )
		{
			return _iter == _list->end();
		}
		
		//	easiest place to implement removal is in this class,
		//	not sure its the most logical place in the interface:
		//	Advances iterator, so this iterator is still valid,
		//	though it may be atEnd(), after removal.
		void removeFromList( void )
		{
			_iter = _list->erase( _iter );
		}
		
		//	Partial access:
		int label( void ) const 			{ return _iter->label(); }
		double initialPhase( void ) const	{ return _iter->initialPhase(); }
		double startTime( void ) const 		{ return _iter->startTime(); }
		double endTime( void ) const		{ return _iter->endTime(); }
		double duration( void ) const		{ return _iter->duration(); }
		
		long countBreakpoints( void ) const { return _iter->countBreakpoints(); }
		
		double frequencyAt( double time ) const	{ return _iter->frequencyAt( time ); }
		double amplitudeAt( double time ) const	{ return _iter->amplitudeAt( time ); }
		double bandwidthAt( double time ) const	{ return _iter->bandwidthAt( time ); }
		double phaseAt( double time ) const		{ return _iter->phaseAt( time ); }
	
		//	mutation:
		void setLabel( int l ) { _iter->setLabel( l ); }
		
		Loris::Partial & partial( void ) { return *_iter; }
	
	};	//	end of class PartialListHandleIteratorHandle
	
	typedef Loris::Handle< PartialListHandleIterator > PartialListHandleIteratorHandle;
	
	class BreakpointHandle
	{
		PartialListHandleIteratorHandle _partialH;
		Loris::PartialIterator _iter;
		
		public:
		//	construction:
		BreakpointHandle( PartialListHandleIteratorHandle subject, Loris::PartialIterator pos ) :
			_partialH( subject ),
			_iter( pos )
		{
			debugger << "created an iterator on a partial having " << _partialH->countBreakpoints()
					 << " breakpoints" << std::endl;
		}
		
		~BreakpointHandle( void )
		{
			debugger << "destroyed an iterator on a partial having " << _partialH->countBreakpoints()
					 << " breakpoints" << std::endl;
		}
		
		//	attribute access:
		double frequency( void ) const { return _iter.breakpoint().frequency(); }
		double amplitude( void ) const { return _iter.breakpoint().amplitude(); }
		double bandwidth( void ) const { return _iter.breakpoint().bandwidth(); }
		double phase( void ) const { return _iter.breakpoint().phase(); }
		
		//	attribute mutation:
		void setFrequency( double x ) { _iter.breakpoint().setFrequency(x); }
		void setAmplitude( double x ) { _iter.breakpoint().setAmplitude(x); }
		void setBandwidth( double x ) { _iter.breakpoint().setBandwidth(x); }
		void setPhase( double x ) { _iter.breakpoint().setPhase(x); }

		//	time:
		double time( void ) const { return _iter.time(); }
		
		//	iterator behavior:
		void next( void )
		{
			if ( ! atEnd() )
				++_iter;
		}
		
		bool atEnd( void )
		{
			return _iter == _partialH->partial().end();
		}
		
	};	//	end of class BreakpointHandle
	

#include "Analyzer.h"
#include "Partial.h"

//	for procedural interface construction and 
//	destruction, see comment below:
#define LORIS_OPAQUE_POINTERS 0
#include "loris.h"

Analyzer * AnalyzerCopy_( const Analyzer * other )
{
	Analyzer * a = createAnalyzer( other->freqResolution() );
	*a = *other;
	return a;
}

#include "BreakpointEnvelope.h"
using Loris::BreakpointEnvelope;

//	for procedural interface construction and 
//	destruction, see comment below:
//#define LORIS_OPAQUE_POINTERS 0
//#include "loris.h"

BreakpointEnvelope * BreakpointEnvelopeCopy_( const BreakpointEnvelope * other )
{
	BreakpointEnvelope * env = createBreakpointEnvelope();
	*env = *other;
	return new BreakpointEnvelope( *other );
	//return copyBreakpointEnvelope( other );
}

BreakpointEnvelope * BreakpointEnvelopeWithValue_( double initialValue )
{
	/*
	BreakpointEnvelope * env = createBreakpointEnvelope();
	env->insertBreakpoint( 0., initialValue );
	//breakpointEnvelope_insertBreakpoint( env, 0., initialValue );
	return env;
	*/
	return new BreakpointEnvelope( initialValue );
}

#include "ExportSpc.h"
using Loris::ExportSpc;

//	for procedural interface construction and 
//	destruction, see comment below:
#define LORIS_OPAQUE_POINTERS 0
#include "loris.h"

#include <stdexcept>
#include <vector>
typedef std::vector< double > SampleVector;

SampleVector * SampleVectorCopy_( const SampleVector * other )
{
	return new SampleVector( *other );
}

#include "AiffFile.h"
using Loris::AiffFile;

//	AIFF export:
	void exportAiffNEW( const char * path,
					 SampleVector * samples,
					 double samplerate, int nchannels, int bitsPerSamp )
	{		
		AiffFile::Export( path, samplerate, nchannels, bitsPerSamp, 
						 samples->begin(), samples->end() );
	}

	void channelize_( PartialListHandle * partials, 
					 BreakpointEnvelope * refFreqEnvelope, int refLabel )
	{
		channelize( *partials, refFreqEnvelope, refLabel );
	}

void dilate_str( PartialListHandle * partials, 
			 	 char * initial, char * target )
{
	std::vector<double> ivec = strtovec( initial );
	std::vector<double> tvec = strtovec( target );
	
	char s[256];
	sprintf(s, "%d initial points, %d target points",
				(int)ivec.size(), (int)tvec.size() );
	printf_notifier( s );
		
	if ( ivec.size() != tvec.size() )
	{
		std::string s( "Invalid arguments to dilate(): there must be as many target points as initial points" );
		throw s;
	}
			
	dilate( *partials, ivec.begin(), tvec.begin(), ivec.size() );
}

	void distill_( PartialListHandle * partials )
	{
		distill( *partials );
	}

	void exportSdif_( const char * path, PartialListHandle * partials, double hop )
	{
		exportSdif( path, *partials, hop );
	}

	SampleVector * importAiff_( const char * path )
	{
		double samplerate;
		int nchannels;
		SampleVector * vec = new SampleVector();
		importAiff( path, vec, &samplerate, &nchannels );
		return vec;
	}

	unsigned long infoAiff( const char * path, double * samplerate, int * nchannels )
	{		
		char s[256];
		sprintf(s, "getting info for %s", path );
		printf_notifier( s );
		
		SampleVector * vec = new SampleVector();
		importAiff( path, vec, samplerate, nchannels );
		return vec->size() / *nchannels;
	}
	/*	Return the number of sample frames, sample rate, and number 
		of channels of audio samples stored in an AIFF file at the 
		given file path (or name). The samples themselves are obtained 
		using importAiff( path ). 
	 */

	PartialListHandle * importSdif_( const char * path )
	{
		PartialListHandle * partials = new PartialListHandle();
		importSdif( path, *partials );
		return partials;
	}

	PartialListHandle * morph_( const PartialListHandle * src0, const PartialListHandle * src1, 
						  const BreakpointEnvelope * ffreq, 
						  const BreakpointEnvelope * famp, 
						  const BreakpointEnvelope * fbw )
	{
		
		PartialListHandle * partials = new PartialListHandle();
		morph( *src0, *src1, ffreq, famp, fbw, *partials );
		return partials;
	}

	SampleVector * synthesize_( const PartialListHandle * partials, double srate )
	{
		SampleVector * samples = new SampleVector();
		synthesize( *partials, samples, srate );
		return samples;
	}

	void copyByLabel_( const PartialListHandle * src, long label, PartialListHandle * dst )
	{
		copyByLabel( *src, label, *dst );
	}

	BreakpointEnvelope *
	createFreqReference_( PartialListHandle * partials, int numSamples,
					 double minFreq, double maxFreq )
	{
		return createFreqReference( *partials, numSamples, minFreq, maxFreq );
	}

	void scaleAmp_( PartialListHandle * partials, BreakpointEnvelope * ampEnv )
	{
		scaleAmp( *partials, ampEnv );
	}

	void scaleNoiseRatio_( PartialListHandle * partials, BreakpointEnvelope * ampEnv )
	{
		scaleNoiseRatio( *partials, ampEnv );
	}

	void shiftPitch_( PartialListHandle * partials, BreakpointEnvelope * ampEnv )
	{
		shiftPitch( *partials, ampEnv );
	}

#include "Sieve.h"

	void sift( PartialListHandle * partials )
	{		
		char s[256];
		sprintf(s, "sifting %d Partials", (*partials)->size() );
		printf_notifier( s );
		
		Loris::Sieve sieve( 0.001 );
		sieve.sift( *partials );
	}
	/*	Lippold's wacky experimental sifting thingie: 
		If any two partials with same label overlap in time,
		keep only the longer of the two partials.
		Set the label of the shorter duration partial to zero.
	 */
#ifdef __cplusplus
extern "C" {
#endif
static PyObject *_wrap_AnalyzerCopy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    Analyzer *result ;
    
    if(!PyArg_ParseTuple(args,"O:AnalyzerCopy",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (Analyzer *)AnalyzerCopy_((Analyzer const *)arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Analyzer);
    return resultobj;
}


static PyObject *_wrap_BreakpointEnvelopeCopy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg0 ;
    PyObject * argo0 =0 ;
    BreakpointEnvelope *result ;
    
    if(!PyArg_ParseTuple(args,"O:BreakpointEnvelopeCopy",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (BreakpointEnvelope *)BreakpointEnvelopeCopy_((BreakpointEnvelope const *)arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope);
    return resultobj;
}


static PyObject *_wrap_BreakpointEnvelopeWithValue(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg0 ;
    BreakpointEnvelope *result ;
    
    if(!PyArg_ParseTuple(args,"d:BreakpointEnvelopeWithValue",&arg0)) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (BreakpointEnvelope *)BreakpointEnvelopeWithValue_(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope);
    return resultobj;
}


static PyObject *_wrap_SampleVectorCopy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg0 ;
    PyObject * argo0 =0 ;
    SampleVector *result ;
    
    if(!PyArg_ParseTuple(args,"O:SampleVectorCopy",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (SampleVector *)SampleVectorCopy_((SampleVector const *)arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector);
    return resultobj;
}


static PyObject *_wrap_exportAiffNEW(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg0 ;
    SampleVector *arg1 ;
    double arg2 ;
    int arg3 ;
    int arg4 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,"sOdii:exportAiffNEW",&arg0,&argo1,&arg2,&arg3,&arg4)) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            exportAiffNEW((char const *)arg0,arg1,arg2,arg3,arg4);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_channelize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    BreakpointEnvelope *arg1 ;
    int arg2 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,"OOi:channelize",&argo0,&argo1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            channelize_(arg0,arg1,arg2);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_dilate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    char *arg1 ;
    char *arg2 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Oss:dilate",&argo0,&arg1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            dilate_str(arg0,arg1,arg2);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_distill(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"O:distill",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            distill_(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_exportAiff(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg0 ;
    SampleVector *arg1 ;
    double arg2 ;
    int arg3 ;
    int arg4 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,"sOdii:exportAiff",&arg0,&argo1,&arg2,&arg3,&arg4)) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            exportAiff((char const *)arg0,(SampleVector const *)arg1,arg2,arg3,arg4);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_exportSdif(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg0 ;
    PartialListHandle *arg1 ;
    double arg2 = 0. ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,"sO|d:exportSdif",&arg0,&argo1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            exportSdif_((char const *)arg0,arg1,arg2);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_importAiff(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg0 ;
    SampleVector *result ;
    
    if(!PyArg_ParseTuple(args,"s:importAiff",&arg0)) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (SampleVector *)importAiff_((char const *)arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector);
    return resultobj;
}


static PyObject *_wrap_infoAiff(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg0 ;
    double *arg1 ;
    int *arg2 ;
    double temp ;
    int temp0 ;
    unsigned long result ;
    
    {
        arg1 = &temp;
    }
    {
        arg2 = &temp0;
    }
    if(!PyArg_ParseTuple(args,"s:infoAiff",&arg0)) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (unsigned long )infoAiff((char const *)arg0,arg1,arg2);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyInt_FromLong((long)result);
    {
        PyObject *o;
        o = PyFloat_FromDouble((double) (*arg1));
        resultobj = t_output_helper(resultobj, o);
    }
    {
        PyObject *o;
        o = PyInt_FromLong((long) (*arg2));
        resultobj = t_output_helper(resultobj, o);
    }
    return resultobj;
}


static PyObject *_wrap_importSdif(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg0 ;
    PartialListHandle *result ;
    
    if(!PyArg_ParseTuple(args,"s:importSdif",&arg0)) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (PartialListHandle *)importSdif_((char const *)arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListHandle);
    return resultobj;
}


static PyObject *_wrap_morph(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    PartialListHandle *arg1 ;
    BreakpointEnvelope *arg2 ;
    BreakpointEnvelope *arg3 ;
    BreakpointEnvelope *arg4 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    PyObject * argo2 =0 ;
    PyObject * argo3 =0 ;
    PyObject * argo4 =0 ;
    PartialListHandle *result ;
    
    if(!PyArg_ParseTuple(args,"OOOOO:morph",&argo0,&argo1,&argo2,&argo3,&argo4)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo2,(void **) &arg2,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo3,(void **) &arg3,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo4,(void **) &arg4,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (PartialListHandle *)morph_((PartialListHandle const *)arg0,(PartialListHandle const *)arg1,(BreakpointEnvelope const *)arg2,(BreakpointEnvelope const *)arg3,(BreakpointEnvelope const *)arg4);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListHandle);
    return resultobj;
}


static PyObject *_wrap_synthesize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    SampleVector *result ;
    
    if(!PyArg_ParseTuple(args,"Od:synthesize",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (SampleVector *)synthesize_((PartialListHandle const *)arg0,arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector);
    return resultobj;
}


static PyObject *_wrap_copyByLabel(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    long arg1 ;
    PartialListHandle *arg2 ;
    PyObject * argo0 =0 ;
    PyObject * argo2 =0 ;
    
    if(!PyArg_ParseTuple(args,"OlO:copyByLabel",&argo0,&arg1,&argo2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo2,(void **) &arg2,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            copyByLabel_((PartialListHandle const *)arg0,arg1,arg2);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_createFreqReference(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    int arg1 ;
    double arg2 ;
    double arg3 ;
    PyObject * argo0 =0 ;
    BreakpointEnvelope *result ;
    
    if(!PyArg_ParseTuple(args,"Oidd:createFreqReference",&argo0,&arg1,&arg2,&arg3)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (BreakpointEnvelope *)createFreqReference_(arg0,arg1,arg2,arg3);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope);
    return resultobj;
}


static PyObject *_wrap_scaleAmp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    BreakpointEnvelope *arg1 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,"OO:scaleAmp",&argo0,&argo1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            scaleAmp_(arg0,arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_scaleNoiseRatio(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    BreakpointEnvelope *arg1 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,"OO:scaleNoiseRatio",&argo0,&argo1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            scaleNoiseRatio_(arg0,arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_shiftPitch(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    BreakpointEnvelope *arg1 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,"OO:shiftPitch",&argo0,&argo1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            shiftPitch_(arg0,arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_sift(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"O:sift",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            sift(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


PartialListHandle * new_PartialListHandle() {
    {
        // debugger << "creating a list of " << pl->size() << " Partials" << std::endl;
        debugger << "creating an empty list of Partials" << endl;
        return new PartialListHandle();
    }
}


static PyObject *_wrap_new_PartialList(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *result ;
    
    if(!PyArg_ParseTuple(args,":new_PartialList")) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (PartialListHandle *)new_PartialListHandle();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListHandle);
    return resultobj;
}


void  delete_PartialListHandle(PartialListHandle *self) {
    {
        debugger << "destroying reference to a list of " << (*self)->size() << " Partials" << endl;
        delete self;
    }
}


static PyObject *_wrap_delete_PartialList(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"O:delete_PartialList",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            delete_PartialListHandle(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


void  PartialListHandle_clear(PartialListHandle *self) {
    {
        (*self)->clear();
    }
}


static PyObject *_wrap_PartialList_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"O:PartialList_clear",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            PartialListHandle_clear(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


PartialListHandle * PartialListHandle_copy(PartialListHandle *self) {
    {
        return new PartialListHandle( (*self)->begin(), (*self)->end() );
    }
}


static PyObject *_wrap_PartialList_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    PyObject * argo0 =0 ;
    PartialListHandle *result ;
    
    if(!PyArg_ParseTuple(args,"O:PartialList_copy",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (PartialListHandle *)PartialListHandle_copy(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListHandle);
    return resultobj;
}


unsigned long  PartialListHandle_size(PartialListHandle *self) {
    {
        return (*self)->size();
    }
}


static PyObject *_wrap_PartialList_size(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    PyObject * argo0 =0 ;
    unsigned long result ;
    
    if(!PyArg_ParseTuple(args,"O:PartialList_size",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (unsigned long )PartialListHandle_size(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


PartialListHandleIteratorHandle * PartialListHandle_first(PartialListHandle *self) {
    {
        return new PartialListHandleIteratorHandle( *self, (*self)->begin() );
    }
}


static PyObject *_wrap_PartialList_first(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    PyObject * argo0 =0 ;
    PartialListHandleIteratorHandle *result ;
    
    if(!PyArg_ParseTuple(args,"O:PartialList_first",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (PartialListHandleIteratorHandle *)PartialListHandle_first(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListHandleIteratorHandle);
    return resultobj;
}


PartialListHandleIteratorHandle * PartialListHandle_last(PartialListHandle *self) {
    {
        return new PartialListHandleIteratorHandle( *self, --(*self)->end() );
    }
}


static PyObject *_wrap_PartialList_last(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    PyObject * argo0 =0 ;
    PartialListHandleIteratorHandle *result ;
    
    if(!PyArg_ParseTuple(args,"O:PartialList_last",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (PartialListHandleIteratorHandle *)PartialListHandle_last(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListHandleIteratorHandle);
    return resultobj;
}


void  PartialListHandle_append(PartialListHandle *self,PartialListHandleIteratorHandle *iter) {
    {
        (*self)->push_back( (*iter)->partial() );
    }
}


static PyObject *_wrap_PartialList_append(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    PartialListHandleIteratorHandle *arg1 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,"OO:PartialList_append",&argo0,&argo1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            PartialListHandle_append(arg0,arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


void  PartialListHandle_splice(PartialListHandle *self,PartialListHandle *otherPartials) {
    {
        if ( self == otherPartials )
        {
            std::string s( "Cannot splice a PartialList onto itself!" );
            throw s;
        }
        (*self)->splice( (*self)->end(), *otherPartials );
    }
}


static PyObject *_wrap_PartialList_splice(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandle *arg0 ;
    PartialListHandle *arg1 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    
    if(!PyArg_ParseTuple(args,"OO:PartialList_splice",&argo0,&argo1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            PartialListHandle_splice(arg0,arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


void  delete_PartialListHandleIteratorHandle(PartialListHandleIteratorHandle *self) {
    {
        delete self;
    }
}


static PyObject *_wrap_delete_Partial(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"O:delete_Partial",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            delete_PartialListHandleIteratorHandle(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


void  PartialListHandleIteratorHandle_next(PartialListHandleIteratorHandle *self) {
    {
        (*self)->next(); 
    }
}


static PyObject *_wrap_Partial_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"O:Partial_next",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            PartialListHandleIteratorHandle_next(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


bool  PartialListHandleIteratorHandle_atEnd(PartialListHandleIteratorHandle *self) {
    {
        return (*self)->atEnd(); 
    }
}


static PyObject *_wrap_Partial_atEnd(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    PyObject * argo0 =0 ;
    bool result ;
    
    if(!PyArg_ParseTuple(args,"O:Partial_atEnd",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (bool )PartialListHandleIteratorHandle_atEnd(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


int  PartialListHandleIteratorHandle_label(PartialListHandleIteratorHandle *self) {
    {
        return (*self)->label(); 
    }
}


static PyObject *_wrap_Partial_label(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    PyObject * argo0 =0 ;
    int result ;
    
    if(!PyArg_ParseTuple(args,"O:Partial_label",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (int )PartialListHandleIteratorHandle_label(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


double  PartialListHandleIteratorHandle_initialPhase(PartialListHandleIteratorHandle *self) {
    {
        return (*self)->initialPhase(); 
    }
}


static PyObject *_wrap_Partial_initialPhase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Partial_initialPhase",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )PartialListHandleIteratorHandle_initialPhase(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


double  PartialListHandleIteratorHandle_startTime(PartialListHandleIteratorHandle *self) {
    {
        return (*self)->startTime(); 
    }
}


static PyObject *_wrap_Partial_startTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Partial_startTime",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )PartialListHandleIteratorHandle_startTime(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


double  PartialListHandleIteratorHandle_endTime(PartialListHandleIteratorHandle *self) {
    {
        return (*self)->endTime(); 
    }
}


static PyObject *_wrap_Partial_endTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Partial_endTime",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )PartialListHandleIteratorHandle_endTime(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


double  PartialListHandleIteratorHandle_duration(PartialListHandleIteratorHandle *self) {
    {
        return (*self)->duration(); 
    }
}


static PyObject *_wrap_Partial_duration(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Partial_duration",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )PartialListHandleIteratorHandle_duration(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


long  PartialListHandleIteratorHandle_countBreakpoints(PartialListHandleIteratorHandle *self) {
    {
        return (*self)->countBreakpoints(); 
    }
}


static PyObject *_wrap_Partial_countBreakpoints(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    PyObject * argo0 =0 ;
    long result ;
    
    if(!PyArg_ParseTuple(args,"O:Partial_countBreakpoints",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (long )PartialListHandleIteratorHandle_countBreakpoints(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


double  PartialListHandleIteratorHandle_frequencyAt(PartialListHandleIteratorHandle *self,double time) {
    {
        return (*self)->frequencyAt( time ); 
    }
}


static PyObject *_wrap_Partial_frequencyAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"Od:Partial_frequencyAt",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )PartialListHandleIteratorHandle_frequencyAt(arg0,arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


double  PartialListHandleIteratorHandle_amplitudeAt(PartialListHandleIteratorHandle *self,double time) {
    {
        return (*self)->amplitudeAt( time ); 
    }
}


static PyObject *_wrap_Partial_amplitudeAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"Od:Partial_amplitudeAt",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )PartialListHandleIteratorHandle_amplitudeAt(arg0,arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


double  PartialListHandleIteratorHandle_bandwidthAt(PartialListHandleIteratorHandle *self,double time) {
    {
        return (*self)->bandwidthAt( time ); 
    }
}


static PyObject *_wrap_Partial_bandwidthAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"Od:Partial_bandwidthAt",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )PartialListHandleIteratorHandle_bandwidthAt(arg0,arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


double  PartialListHandleIteratorHandle_phaseAt(PartialListHandleIteratorHandle *self,double time) {
    {
        return (*self)->phaseAt( time ); 
    }
}


static PyObject *_wrap_Partial_phaseAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"Od:Partial_phaseAt",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )PartialListHandleIteratorHandle_phaseAt(arg0,arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


void  PartialListHandleIteratorHandle_setLabel(PartialListHandleIteratorHandle *self,int l) {
    {
        (*self)->setLabel( l ); 
    }
}


static PyObject *_wrap_Partial_setLabel(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Oi:Partial_setLabel",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            PartialListHandleIteratorHandle_setLabel(arg0,arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


void  PartialListHandleIteratorHandle_removeFromList(PartialListHandleIteratorHandle *self) {
    {
        (*self)->removeFromList(); 
    }
}


static PyObject *_wrap_Partial_removeFromList(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"O:Partial_removeFromList",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            PartialListHandleIteratorHandle_removeFromList(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


BreakpointHandle * PartialListHandleIteratorHandle_first(PartialListHandleIteratorHandle *self) {
    {
        return new BreakpointHandle( *self, (*self)->partial().begin() );
    }
}


static PyObject *_wrap_Partial_first(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    PyObject * argo0 =0 ;
    BreakpointHandle *result ;
    
    if(!PyArg_ParseTuple(args,"O:Partial_first",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (BreakpointHandle *)PartialListHandleIteratorHandle_first(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointHandle);
    return resultobj;
}


BreakpointHandle * PartialListHandleIteratorHandle_last(PartialListHandleIteratorHandle *self) {
    {
        return new BreakpointHandle( *self, --( (*self)->partial().end() ) );
    }
}


static PyObject *_wrap_Partial_last(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListHandleIteratorHandle *arg0 ;
    PyObject * argo0 =0 ;
    BreakpointHandle *result ;
    
    if(!PyArg_ParseTuple(args,"O:Partial_last",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_PartialListHandleIteratorHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (BreakpointHandle *)PartialListHandleIteratorHandle_last(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointHandle);
    return resultobj;
}


static PyObject *_wrap_delete_Breakpoint(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointHandle *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"O:delete_Breakpoint",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            delete arg0;
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Breakpoint_frequency(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointHandle *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Breakpoint_frequency",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->frequency();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Breakpoint_amplitude(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointHandle *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Breakpoint_amplitude",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->amplitude();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Breakpoint_bandwidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointHandle *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Breakpoint_bandwidth",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->bandwidth();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Breakpoint_phase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointHandle *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Breakpoint_phase",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->phase();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Breakpoint_setFrequency(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointHandle *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:Breakpoint_setFrequency",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setFrequency(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Breakpoint_setAmplitude(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointHandle *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:Breakpoint_setAmplitude",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setAmplitude(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Breakpoint_setBandwidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointHandle *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:Breakpoint_setBandwidth",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setBandwidth(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Breakpoint_setPhase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointHandle *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:Breakpoint_setPhase",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setPhase(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Breakpoint_time(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointHandle *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Breakpoint_time",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->time();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Breakpoint_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointHandle *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"O:Breakpoint_next",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->next();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Breakpoint_atEnd(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointHandle *arg0 ;
    PyObject * argo0 =0 ;
    bool result ;
    
    if(!PyArg_ParseTuple(args,"O:Breakpoint_atEnd",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (bool )arg0->atEnd();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


Analyzer * new_Analyzer(double resolutionHz) {
    {
        return createAnalyzer( resolutionHz );
    }
}


static PyObject *_wrap_new_Analyzer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg0 ;
    Analyzer *result ;
    
    if(!PyArg_ParseTuple(args,"d:new_Analyzer",&arg0)) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (Analyzer *)new_Analyzer(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Analyzer);
    return resultobj;
}


void  delete_Analyzer(Analyzer *self) {
    {
        destroyAnalyzer( self );
    }
}


static PyObject *_wrap_delete_Analyzer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"O:delete_Analyzer",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            delete_Analyzer(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


PartialListHandle * Analyzer_analyze(Analyzer *self,SampleVector const *vec,double srate) {
    {
        PartialListHandle * partials = new PartialListHandle();
        //self->analyze( vec->begin(), vec->end(), srate );
        //partials->splice( partials->end(), self->partials() );
        analyzer_analyze( self, vec, srate, *partials );
        return partials;
    }
}


static PyObject *_wrap_Analyzer_analyze(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    SampleVector *arg1 ;
    double arg2 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    PartialListHandle *result ;
    
    if(!PyArg_ParseTuple(args,"OOd:Analyzer_analyze",&argo0,&argo1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (PartialListHandle *)Analyzer_analyze(arg0,(SampleVector const *)arg1,arg2);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListHandle);
    return resultobj;
}


static PyObject *_wrap_Analyzer_configure(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:Analyzer_configure",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->configure(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_freqResolution(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Analyzer_freqResolution",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->freqResolution();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_ampFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Analyzer_ampFloor",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->ampFloor();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_windowWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Analyzer_windowWidth",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->windowWidth();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_freqFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Analyzer_freqFloor",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->freqFloor();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_hopTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Analyzer_hopTime",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->hopTime();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_freqDrift(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Analyzer_freqDrift",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->freqDrift();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_cropTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Analyzer_cropTime",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->cropTime();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_bwRegionWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:Analyzer_bwRegionWidth",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->bwRegionWidth();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_Analyzer_setFreqResolution(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:Analyzer_setFreqResolution",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setFreqResolution(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setAmpFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:Analyzer_setAmpFloor",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setAmpFloor(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setWindowWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:Analyzer_setWindowWidth",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setWindowWidth(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setFreqFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:Analyzer_setFreqFloor",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setFreqFloor(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setFreqDrift(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:Analyzer_setFreqDrift",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setFreqDrift(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setHopTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:Analyzer_setHopTime",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setHopTime(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setCropTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:Analyzer_setCropTime",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setCropTime(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_Analyzer_setBwRegionWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:Analyzer_setBwRegionWidth",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_Analyzer,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setBwRegionWidth(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_new_BreakpointEnvelope(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *result ;
    
    if(!PyArg_ParseTuple(args,":new_BreakpointEnvelope")) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (BreakpointEnvelope *)new BreakpointEnvelope();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope);
    return resultobj;
}


static PyObject *_wrap_delete_BreakpointEnvelope(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"O:delete_BreakpointEnvelope",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            delete arg0;
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_BreakpointEnvelope_valueAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"Od:BreakpointEnvelope_valueAt",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->valueAt(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_BreakpointEnvelope_insertBreakpoint(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg0 ;
    double arg1 ;
    double arg2 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Odd:BreakpointEnvelope_insertBreakpoint",&argo0,&arg1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_BreakpointEnvelope,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->insertBreakpoint(arg1,arg2);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


ExportSpc * new_ExportSpc(double midiPitch) {
    {
        return createExportSpc( midiPitch );
    }
}


static PyObject *_wrap_new_ExportSpc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg0 ;
    ExportSpc *result ;
    
    if(!PyArg_ParseTuple(args,"d:new_ExportSpc",&arg0)) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (ExportSpc *)new_ExportSpc(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ExportSpc);
    return resultobj;
}


void  delete_ExportSpc(ExportSpc *self) {
    {
        destroyExportSpc( self );
    }
}


static PyObject *_wrap_delete_ExportSpc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"O:delete_ExportSpc",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            delete_ExportSpc(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


void  ExportSpc_write(ExportSpc *self,char const *filename,PartialListHandle const *partials) {
    {
        self->write( filename, *partials );
    }
}


static PyObject *_wrap_ExportSpc_write(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    char *arg1 ;
    PartialListHandle *arg2 ;
    PyObject * argo0 =0 ;
    PyObject * argo2 =0 ;
    
    if(!PyArg_ParseTuple(args,"OsO:ExportSpc_write",&argo0,&arg1,&argo2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo2,(void **) &arg2,SWIGTYPE_p_PartialListHandle,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            ExportSpc_write(arg0,(char const *)arg1,(PartialListHandle const *)arg2);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_ExportSpc_configure(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:ExportSpc_configure",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->configure(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_ExportSpc_midiPitch(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:ExportSpc_midiPitch",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->midiPitch();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_ExportSpc_numPartials(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    PyObject * argo0 =0 ;
    int result ;
    
    if(!PyArg_ParseTuple(args,"O:ExportSpc_numPartials",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (int )arg0->numPartials();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_ExportSpc_refLabel(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    PyObject * argo0 =0 ;
    int result ;
    
    if(!PyArg_ParseTuple(args,"O:ExportSpc_refLabel",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (int )arg0->refLabel();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_ExportSpc_enhanced(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    PyObject * argo0 =0 ;
    int result ;
    
    if(!PyArg_ParseTuple(args,"O:ExportSpc_enhanced",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (int )arg0->enhanced();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_ExportSpc_hop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:ExportSpc_hop",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->hop();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_ExportSpc_attackThreshold(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:ExportSpc_attackThreshold",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->attackThreshold();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_ExportSpc_startFreqTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:ExportSpc_startFreqTime",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->startFreqTime();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_ExportSpc_endTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:ExportSpc_endTime",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->endTime();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_ExportSpc_endApproachTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:ExportSpc_endApproachTime",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->endApproachTime();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_ExportSpc_markerTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:ExportSpc_markerTime",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->markerTime();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_ExportSpc_setMidiPitch(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:ExportSpc_setMidiPitch",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setMidiPitch(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_ExportSpc_setNumPartials(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Oi:ExportSpc_setNumPartials",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setNumPartials(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_ExportSpc_setRefLabel(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Oi:ExportSpc_setRefLabel",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setRefLabel(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_ExportSpc_setEnhanced(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Oi:ExportSpc_setEnhanced",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setEnhanced(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_ExportSpc_setHop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:ExportSpc_setHop",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setHop(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_ExportSpc_setAttackThreshold(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:ExportSpc_setAttackThreshold",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setAttackThreshold(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_ExportSpc_setStartFreqTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:ExportSpc_setStartFreqTime",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setStartFreqTime(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_ExportSpc_setEndTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:ExportSpc_setEndTime",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setEndTime(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_ExportSpc_setEndApproachTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:ExportSpc_setEndApproachTime",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setEndApproachTime(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_ExportSpc_setMarkerTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ExportSpc *arg0 ;
    double arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Od:ExportSpc_setMarkerTime",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_ExportSpc,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->setMarkerTime(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_new_SampleVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned long arg0 = 0 ;
    SampleVector *result ;
    
    if(!PyArg_ParseTuple(args,"|l:new_SampleVector",&arg0)) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (SampleVector *)new SampleVector(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector);
    return resultobj;
}


static PyObject *_wrap_delete_SampleVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"O:delete_SampleVector",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            delete arg0;
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_SampleVector_size(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg0 ;
    PyObject * argo0 =0 ;
    unsigned long result ;
    
    if(!PyArg_ParseTuple(args,"O:SampleVector_size",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (unsigned long )arg0->size();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_SampleVector_resize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg0 ;
    unsigned long arg1 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Ol:SampleVector_resize",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->resize(arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_SampleVector_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"O:SampleVector_clear",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            arg0->clear();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


double  SampleVector_getAt(SampleVector *self,unsigned long idx) {
    {
// return self->at(idx);	//	g++ doesn't implement at()?
		if ( idx >= self->size() )
			throw std::out_of_range("vector::at index out of range");
		return (*self)[idx];
	}
}


static PyObject *_wrap_SampleVector_getAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg0 ;
    unsigned long arg1 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"Ol:SampleVector_getAt",&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )SampleVector_getAt(arg0,arg1);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


void  SampleVector_setAt(SampleVector *self,unsigned long idx,double x) {
    {
// self->at(idx) = x;	//	g++ doesn't implement at()?
		if ( idx >= self->size() )
			throw std::out_of_range("vector::at index out of range");
		(*self)[idx] = x;
	}
}


static PyObject *_wrap_SampleVector_setAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg0 ;
    unsigned long arg1 ;
    double arg2 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"Old:SampleVector_setAt",&argo0,&arg1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_SampleVector,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            SampleVector_setAt(arg0,arg1,arg2);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_new_AiffFile(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg0 ;
    AiffFile *result ;
    
    if(!PyArg_ParseTuple(args,"s:new_AiffFile",&arg0)) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (AiffFile *)new AiffFile((char const *)arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AiffFile);
    return resultobj;
}


static PyObject *_wrap_delete_AiffFile(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg0 ;
    PyObject * argo0 =0 ;
    
    if(!PyArg_ParseTuple(args,"O:delete_AiffFile",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            delete arg0;
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_AiffFile_channels(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg0 ;
    PyObject * argo0 =0 ;
    int result ;
    
    if(!PyArg_ParseTuple(args,"O:AiffFile_channels",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (int )arg0->channels();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_AiffFile_sampleFrames(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg0 ;
    PyObject * argo0 =0 ;
    unsigned long result ;
    
    if(!PyArg_ParseTuple(args,"O:AiffFile_sampleFrames",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (unsigned long )arg0->sampleFrames();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_AiffFile_sampleRate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg0 ;
    PyObject * argo0 =0 ;
    double result ;
    
    if(!PyArg_ParseTuple(args,"O:AiffFile_sampleRate",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (double )arg0->sampleRate();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyFloat_FromDouble(result);
    return resultobj;
}


static PyObject *_wrap_AiffFile_sampleSize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg0 ;
    PyObject * argo0 =0 ;
    int result ;
    
    if(!PyArg_ParseTuple(args,"O:AiffFile_sampleSize",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (int )arg0->sampleSize();
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


SampleVector * AiffFile_samples(AiffFile *self) {
    {
        SampleVector * vec = new SampleVector( self->sampleFrames(), 0. );
        self->getSamples( vec->begin(), vec->end() );
        return vec;
    }
}


static PyObject *_wrap_AiffFile_samples(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg0 ;
    PyObject * argo0 =0 ;
    SampleVector *result ;
    
    if(!PyArg_ParseTuple(args,"O:AiffFile_samples",&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_AiffFile,1)) == -1) return NULL;
    {
        try
        {
            // LorisErrorString.clear();
            LorisErrorString = "";
            result = (SampleVector *)AiffFile_samples(arg0);
            
            
            //	catch exceptions in the procedural interface, 
            //	converted to strings by the exception handler 
            //	in the Loris procedural interface:
            if ( ! LorisErrorString.empty() )
            {
                //	this is an improperly-braced macro!
                SWIG_exception( SWIG_RuntimeError, (char *) LorisErrorString.c_str() );
            }
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception in scripting interface: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::string & exs )
        {
            //	exceptions generated by functions defined in this
            //	file may throw std::strings:
            std::string s("Exception thrown in scripting interface wrapper code: " );
            s.append( exs );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector);
    return resultobj;
}


static PyMethodDef loriscMethods[] = {
	 { "AnalyzerCopy", _wrap_AnalyzerCopy, METH_VARARGS },
	 { "BreakpointEnvelopeCopy", _wrap_BreakpointEnvelopeCopy, METH_VARARGS },
	 { "BreakpointEnvelopeWithValue", _wrap_BreakpointEnvelopeWithValue, METH_VARARGS },
	 { "SampleVectorCopy", _wrap_SampleVectorCopy, METH_VARARGS },
	 { "exportAiffNEW", _wrap_exportAiffNEW, METH_VARARGS },
	 { "channelize", _wrap_channelize, METH_VARARGS },
	 { "dilate", _wrap_dilate, METH_VARARGS },
	 { "distill", _wrap_distill, METH_VARARGS },
	 { "exportAiff", _wrap_exportAiff, METH_VARARGS },
	 { "exportSdif", _wrap_exportSdif, METH_VARARGS },
	 { "importAiff", _wrap_importAiff, METH_VARARGS },
	 { "infoAiff", _wrap_infoAiff, METH_VARARGS },
	 { "importSdif", _wrap_importSdif, METH_VARARGS },
	 { "morph", _wrap_morph, METH_VARARGS },
	 { "synthesize", _wrap_synthesize, METH_VARARGS },
	 { "copyByLabel", _wrap_copyByLabel, METH_VARARGS },
	 { "createFreqReference", _wrap_createFreqReference, METH_VARARGS },
	 { "scaleAmp", _wrap_scaleAmp, METH_VARARGS },
	 { "scaleNoiseRatio", _wrap_scaleNoiseRatio, METH_VARARGS },
	 { "shiftPitch", _wrap_shiftPitch, METH_VARARGS },
	 { "sift", _wrap_sift, METH_VARARGS },
	 { "new_PartialList", _wrap_new_PartialList, METH_VARARGS },
	 { "delete_PartialList", _wrap_delete_PartialList, METH_VARARGS },
	 { "PartialList_clear", _wrap_PartialList_clear, METH_VARARGS },
	 { "PartialList_copy", _wrap_PartialList_copy, METH_VARARGS },
	 { "PartialList_size", _wrap_PartialList_size, METH_VARARGS },
	 { "PartialList_first", _wrap_PartialList_first, METH_VARARGS },
	 { "PartialList_last", _wrap_PartialList_last, METH_VARARGS },
	 { "PartialList_append", _wrap_PartialList_append, METH_VARARGS },
	 { "PartialList_splice", _wrap_PartialList_splice, METH_VARARGS },
	 { "delete_Partial", _wrap_delete_Partial, METH_VARARGS },
	 { "Partial_next", _wrap_Partial_next, METH_VARARGS },
	 { "Partial_atEnd", _wrap_Partial_atEnd, METH_VARARGS },
	 { "Partial_label", _wrap_Partial_label, METH_VARARGS },
	 { "Partial_initialPhase", _wrap_Partial_initialPhase, METH_VARARGS },
	 { "Partial_startTime", _wrap_Partial_startTime, METH_VARARGS },
	 { "Partial_endTime", _wrap_Partial_endTime, METH_VARARGS },
	 { "Partial_duration", _wrap_Partial_duration, METH_VARARGS },
	 { "Partial_countBreakpoints", _wrap_Partial_countBreakpoints, METH_VARARGS },
	 { "Partial_frequencyAt", _wrap_Partial_frequencyAt, METH_VARARGS },
	 { "Partial_amplitudeAt", _wrap_Partial_amplitudeAt, METH_VARARGS },
	 { "Partial_bandwidthAt", _wrap_Partial_bandwidthAt, METH_VARARGS },
	 { "Partial_phaseAt", _wrap_Partial_phaseAt, METH_VARARGS },
	 { "Partial_setLabel", _wrap_Partial_setLabel, METH_VARARGS },
	 { "Partial_removeFromList", _wrap_Partial_removeFromList, METH_VARARGS },
	 { "Partial_first", _wrap_Partial_first, METH_VARARGS },
	 { "Partial_last", _wrap_Partial_last, METH_VARARGS },
	 { "delete_Breakpoint", _wrap_delete_Breakpoint, METH_VARARGS },
	 { "Breakpoint_frequency", _wrap_Breakpoint_frequency, METH_VARARGS },
	 { "Breakpoint_amplitude", _wrap_Breakpoint_amplitude, METH_VARARGS },
	 { "Breakpoint_bandwidth", _wrap_Breakpoint_bandwidth, METH_VARARGS },
	 { "Breakpoint_phase", _wrap_Breakpoint_phase, METH_VARARGS },
	 { "Breakpoint_setFrequency", _wrap_Breakpoint_setFrequency, METH_VARARGS },
	 { "Breakpoint_setAmplitude", _wrap_Breakpoint_setAmplitude, METH_VARARGS },
	 { "Breakpoint_setBandwidth", _wrap_Breakpoint_setBandwidth, METH_VARARGS },
	 { "Breakpoint_setPhase", _wrap_Breakpoint_setPhase, METH_VARARGS },
	 { "Breakpoint_time", _wrap_Breakpoint_time, METH_VARARGS },
	 { "Breakpoint_next", _wrap_Breakpoint_next, METH_VARARGS },
	 { "Breakpoint_atEnd", _wrap_Breakpoint_atEnd, METH_VARARGS },
	 { "new_Analyzer", _wrap_new_Analyzer, METH_VARARGS },
	 { "delete_Analyzer", _wrap_delete_Analyzer, METH_VARARGS },
	 { "Analyzer_analyze", _wrap_Analyzer_analyze, METH_VARARGS },
	 { "Analyzer_configure", _wrap_Analyzer_configure, METH_VARARGS },
	 { "Analyzer_freqResolution", _wrap_Analyzer_freqResolution, METH_VARARGS },
	 { "Analyzer_ampFloor", _wrap_Analyzer_ampFloor, METH_VARARGS },
	 { "Analyzer_windowWidth", _wrap_Analyzer_windowWidth, METH_VARARGS },
	 { "Analyzer_freqFloor", _wrap_Analyzer_freqFloor, METH_VARARGS },
	 { "Analyzer_hopTime", _wrap_Analyzer_hopTime, METH_VARARGS },
	 { "Analyzer_freqDrift", _wrap_Analyzer_freqDrift, METH_VARARGS },
	 { "Analyzer_cropTime", _wrap_Analyzer_cropTime, METH_VARARGS },
	 { "Analyzer_bwRegionWidth", _wrap_Analyzer_bwRegionWidth, METH_VARARGS },
	 { "Analyzer_setFreqResolution", _wrap_Analyzer_setFreqResolution, METH_VARARGS },
	 { "Analyzer_setAmpFloor", _wrap_Analyzer_setAmpFloor, METH_VARARGS },
	 { "Analyzer_setWindowWidth", _wrap_Analyzer_setWindowWidth, METH_VARARGS },
	 { "Analyzer_setFreqFloor", _wrap_Analyzer_setFreqFloor, METH_VARARGS },
	 { "Analyzer_setFreqDrift", _wrap_Analyzer_setFreqDrift, METH_VARARGS },
	 { "Analyzer_setHopTime", _wrap_Analyzer_setHopTime, METH_VARARGS },
	 { "Analyzer_setCropTime", _wrap_Analyzer_setCropTime, METH_VARARGS },
	 { "Analyzer_setBwRegionWidth", _wrap_Analyzer_setBwRegionWidth, METH_VARARGS },
	 { "new_BreakpointEnvelope", _wrap_new_BreakpointEnvelope, METH_VARARGS },
	 { "delete_BreakpointEnvelope", _wrap_delete_BreakpointEnvelope, METH_VARARGS },
	 { "BreakpointEnvelope_valueAt", _wrap_BreakpointEnvelope_valueAt, METH_VARARGS },
	 { "BreakpointEnvelope_insertBreakpoint", _wrap_BreakpointEnvelope_insertBreakpoint, METH_VARARGS },
	 { "new_ExportSpc", _wrap_new_ExportSpc, METH_VARARGS },
	 { "delete_ExportSpc", _wrap_delete_ExportSpc, METH_VARARGS },
	 { "ExportSpc_write", _wrap_ExportSpc_write, METH_VARARGS },
	 { "ExportSpc_configure", _wrap_ExportSpc_configure, METH_VARARGS },
	 { "ExportSpc_midiPitch", _wrap_ExportSpc_midiPitch, METH_VARARGS },
	 { "ExportSpc_numPartials", _wrap_ExportSpc_numPartials, METH_VARARGS },
	 { "ExportSpc_refLabel", _wrap_ExportSpc_refLabel, METH_VARARGS },
	 { "ExportSpc_enhanced", _wrap_ExportSpc_enhanced, METH_VARARGS },
	 { "ExportSpc_hop", _wrap_ExportSpc_hop, METH_VARARGS },
	 { "ExportSpc_attackThreshold", _wrap_ExportSpc_attackThreshold, METH_VARARGS },
	 { "ExportSpc_startFreqTime", _wrap_ExportSpc_startFreqTime, METH_VARARGS },
	 { "ExportSpc_endTime", _wrap_ExportSpc_endTime, METH_VARARGS },
	 { "ExportSpc_endApproachTime", _wrap_ExportSpc_endApproachTime, METH_VARARGS },
	 { "ExportSpc_markerTime", _wrap_ExportSpc_markerTime, METH_VARARGS },
	 { "ExportSpc_setMidiPitch", _wrap_ExportSpc_setMidiPitch, METH_VARARGS },
	 { "ExportSpc_setNumPartials", _wrap_ExportSpc_setNumPartials, METH_VARARGS },
	 { "ExportSpc_setRefLabel", _wrap_ExportSpc_setRefLabel, METH_VARARGS },
	 { "ExportSpc_setEnhanced", _wrap_ExportSpc_setEnhanced, METH_VARARGS },
	 { "ExportSpc_setHop", _wrap_ExportSpc_setHop, METH_VARARGS },
	 { "ExportSpc_setAttackThreshold", _wrap_ExportSpc_setAttackThreshold, METH_VARARGS },
	 { "ExportSpc_setStartFreqTime", _wrap_ExportSpc_setStartFreqTime, METH_VARARGS },
	 { "ExportSpc_setEndTime", _wrap_ExportSpc_setEndTime, METH_VARARGS },
	 { "ExportSpc_setEndApproachTime", _wrap_ExportSpc_setEndApproachTime, METH_VARARGS },
	 { "ExportSpc_setMarkerTime", _wrap_ExportSpc_setMarkerTime, METH_VARARGS },
	 { "new_SampleVector", _wrap_new_SampleVector, METH_VARARGS },
	 { "delete_SampleVector", _wrap_delete_SampleVector, METH_VARARGS },
	 { "SampleVector_size", _wrap_SampleVector_size, METH_VARARGS },
	 { "SampleVector_resize", _wrap_SampleVector_resize, METH_VARARGS },
	 { "SampleVector_clear", _wrap_SampleVector_clear, METH_VARARGS },
	 { "SampleVector_getAt", _wrap_SampleVector_getAt, METH_VARARGS },
	 { "SampleVector_setAt", _wrap_SampleVector_setAt, METH_VARARGS },
	 { "new_AiffFile", _wrap_new_AiffFile, METH_VARARGS },
	 { "delete_AiffFile", _wrap_delete_AiffFile, METH_VARARGS },
	 { "AiffFile_channels", _wrap_AiffFile_channels, METH_VARARGS },
	 { "AiffFile_sampleFrames", _wrap_AiffFile_sampleFrames, METH_VARARGS },
	 { "AiffFile_sampleRate", _wrap_AiffFile_sampleRate, METH_VARARGS },
	 { "AiffFile_sampleSize", _wrap_AiffFile_sampleSize, METH_VARARGS },
	 { "AiffFile_samples", _wrap_AiffFile_samples, METH_VARARGS },
	 { NULL, NULL }
};

#ifdef __cplusplus
}
#endif

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_ExportSpc[] = {{"_p_ExportSpc", 0, "ExportSpc *"},{"_p_ExportSpc"},{0}};
static swig_type_info _swigt__p_SampleVector[] = {{"_p_SampleVector", 0, "SampleVector *"},{"_p_SampleVector"},{0}};
static swig_type_info _swigt__p_PartialListHandle[] = {{"_p_PartialListHandle", 0, "PartialListHandle *"},{"_p_PartialListHandle"},{0}};
static swig_type_info _swigt__p_PartialListHandleIteratorHandle[] = {{"_p_PartialListHandleIteratorHandle", 0, "PartialListHandleIteratorHandle *"},{"_p_PartialListHandleIteratorHandle"},{0}};
static swig_type_info _swigt__p_BreakpointHandle[] = {{"_p_BreakpointHandle", 0, "BreakpointHandle *"},{"_p_BreakpointHandle"},{0}};
static swig_type_info _swigt__p_AiffFile[] = {{"_p_AiffFile", 0, "AiffFile *"},{"_p_AiffFile"},{0}};
static swig_type_info _swigt__p_Analyzer[] = {{"_p_Analyzer", 0, "Analyzer *"},{"_p_Analyzer"},{0}};
static swig_type_info _swigt__p_BreakpointEnvelope[] = {{"_p_BreakpointEnvelope", 0, "BreakpointEnvelope *"},{"_p_BreakpointEnvelope"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_ExportSpc, 
_swigt__p_SampleVector, 
_swigt__p_PartialListHandle, 
_swigt__p_PartialListHandleIteratorHandle, 
_swigt__p_BreakpointHandle, 
_swigt__p_AiffFile, 
_swigt__p_Analyzer, 
_swigt__p_BreakpointEnvelope, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
    { SWIG_PY_STRING, "version", 0, 0, (void *) "Loris 1.0beta3", 0 }, 
{0}};

static PyObject *SWIG_globals;
#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT(void) initlorisc(void) {
    PyObject *m, *d;
    int i;
    SWIG_globals = SWIG_newvarlink();
    m = Py_InitModule("lorisc", loriscMethods);
    d = PyModule_GetDict(m);
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
    }
    
    setNotifier( printf_notifier );
    setExceptionHandler( throw_string );
    SWIG_InstallConstants(d,swig_const_table);
}

