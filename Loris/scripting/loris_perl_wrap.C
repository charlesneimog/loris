/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.20
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */


#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};                                                    
#endif

/*************************************************************** -*- c -*-
 * perl5/precommon.swg
 *
 * Rename all exported symbols from common.swg, to avoid symbol
 * clashes if multiple interpreters are included
 *
 ************************************************************************/

#define SWIG_TypeRegister    SWIG_Perl_TypeRegister
#define SWIG_TypeCheck       SWIG_Perl_TypeCheck
#define SWIG_TypeCast        SWIG_Perl_TypeCast
#define SWIG_TypeDynamicCast SWIG_Perl_TypeDynamicCast
#define SWIG_TypeName        SWIG_Perl_TypeName
#define SWIG_TypeQuery       SWIG_Perl_TypeQuery
#define SWIG_TypeClientData  SWIG_Perl_TypeClientData
#define SWIG_PackData        SWIG_Perl_PackData 
#define SWIG_UnpackData      SWIG_Perl_UnpackData 


/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  if defined(_MSC_VER) || defined(__GNUC__)
#    if defined(STATIC_LINKED)
#      define SWIGEXPORT(a) a
#      define SWIGIMPORT(a) extern a
#    else
#      define SWIGEXPORT(a) __declspec(dllexport) a
#      define SWIGIMPORT(a) extern a
#    endif
#  else
#    if defined(__BORLANDC__)
#      define SWIGEXPORT(a) a _export
#      define SWIGIMPORT(a) a _export
#    else
#      define SWIGEXPORT(a) a
#      define SWIGIMPORT(a) a
#    endif
#  endif
#else
#  define SWIGEXPORT(a) a
#  define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#  define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#  define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);
SWIGIMPORT(char *)           SWIG_PackData(char *, void *, int);
SWIGIMPORT(char *)           SWIG_UnpackData(char *, void *, int);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti) {
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      if (tc->clientdata) ti->clientdata = tc->clientdata;
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
  l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty) {
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
        s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) {
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/* Return the name associated with this type */
SWIGRUNTIME(const char *)
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata == clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0))
          SWIG_TypeClientData(tc,clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  int i;
  unsigned char *u = (unsigned char *) ptr;
  register unsigned char uu;
  for (i = 0; i < sz; i++,u++) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu = 0;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  int i;
  for (i = 0; i < sz; i++, u++) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

#endif

#ifdef __cplusplus
}
#endif

/* ---------------------------------------------------------------------- -*- c -*-
 * perl5.swg
 *
 * Perl5 runtime library
 * $Header$
 * ----------------------------------------------------------------------------- */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
/* Needed on some windows machines---since MS plays funny games with the header files under C++ */
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* Get rid of free and malloc defined by perl */
#undef free
#undef malloc

#ifndef pTHX_
#define pTHX_
#endif

#include <string.h>
#ifdef __cplusplus
}
#endif

/* Macro to call an XS function */

#ifdef PERL_OBJECT 
#  define SWIG_CALLXS(_name) _name(cv,pPerl) 
#else 
#  ifndef MULTIPLICITY 
#    define SWIG_CALLXS(_name) _name(cv) 
#  else 
#    define SWIG_CALLXS(_name) _name(PERL_GET_THX, cv) 
#  endif 
#endif 

/* Contract support */

#define SWIG_contract_assert(expr,msg) if (!(expr)) { SWIG_croak(msg); } else

/* Note: SwigMagicFuncHack is a typedef used to get the C++ compiler to just shut up already */

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerlObj *pPerl = (CPerlObj *) this;
typedef int (CPerlObj::*SwigMagicFunc)(SV *, MAGIC *);

#ifdef __cplusplus
extern "C" {
#endif
typedef int (CPerlObj::*SwigMagicFuncHack)(SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)
#define SWIGCLASS_STATIC
#else
#define MAGIC_PPERL
#define SWIGCLASS_STATIC static
#ifndef MULTIPLICITY
#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)
typedef int (*SwigMagicFunc)(SV *, MAGIC *);

#ifdef __cplusplus
extern "C" {
#endif
typedef int (*SwigMagicFuncHack)(SV *, MAGIC *);
#ifdef __cplusplus
}
#endif


#else
#define SWIG_MAGIC(a,b) (struct interpreter *interp, SV *a, MAGIC *b)
typedef int (*SwigMagicFunc)(struct interpreter *, SV *, MAGIC *);
#ifdef __cplusplus
extern "C" {
#endif
typedef int (*SwigMagicFuncHack)(struct interpreter *, SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#endif
#endif

#if defined(WIN32) && defined(PERL_OBJECT) && !defined(PerlIO_exportFILE)
#define PerlIO_exportFILE(fh,fl) (FILE*)(fh)
#endif

/* Modifications for newer Perl 5.005 releases */

#if !defined(PERL_REVISION) || ((PERL_REVISION >= 5) && ((PERL_VERSION < 5) || ((PERL_VERSION == 5) && (PERL_SUBVERSION < 50))))
#  ifndef PL_sv_yes
#    define PL_sv_yes sv_yes
#  endif
#  ifndef PL_sv_undef
#    define PL_sv_undef sv_undef
#  endif
#  ifndef PL_na
#    define PL_na na
#  endif
#endif

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_OWNER 1
#define SWIG_SHADOW 2

/* Common SWIG API */

#ifdef PERL_OBJECT
#  define SWIG_ConvertPtr(obj, pp, type, flags) \
     SWIG_Perl_ConvertPtr(pPerl, obj, pp, type, flags)
#  define SWIG_NewPointerObj(p, type, flags) \
     SWIG_Perl_NewPointerObj(pPerl, p, type, flags)
#  define SWIG_MakePackedObj(sv, p, s, type)	\
     SWIG_Perl_MakePackedObj(pPerl, sv, p, s, type)
#  define SWIG_ConvertPacked(obj, p, s, type, flags) \
     SWIG_Perl_ConvertPacked(pPerl, obj, p, s, type, flags)

#else
#  define SWIG_ConvertPtr(obj, pp, type, flags) \
     SWIG_Perl_ConvertPtr(obj, pp, type, flags)
#  define SWIG_NewPointerObj(p, type, flags) \
     SWIG_Perl_NewPointerObj(p, type, flags)
#  define SWIG_MakePackedObj(sv, p, s, type)	\
     SWIG_Perl_MakePackedObj(sv, p, s, type )
#  define SWIG_ConvertPacked(obj, p, s, type, flags) \
     SWIG_Perl_ConvertPacked(obj, p, s, type, flags)
#endif

/* Perl-specific API */
#ifdef PERL_OBJECT
#  define SWIG_MakePtr(sv, ptr, type, flags) \
     SWIG_Perl_MakePtr(pPerl, sv, ptr, type, flags)
#  define SWIG_TypeCheckRV(rv, ty) \
     SWIG_Perl_TypeCheckRV(pPerl, rv, ty)
#  define SWIG_SetError(str) \
     SWIG_Perl_SetError(pPerl, str)
#else
#  define SWIG_MakePtr(sv, ptr, type, flags) \
     SWIG_Perl_MakePtr(sv, ptr, type, flags)
#  define SWIG_TypeCheckRV(rv, ty) \
     SWIG_Perl_TypeCheckRV(rv, ty)
#  define SWIG_SetError(str) \
     SWIG_Perl_SetError(str)
#  define SWIG_SetErrorSV(str) \
     SWIG_Perl_SetErrorSV(str)
#endif

#define SWIG_SetErrorf SWIG_Perl_SetErrorf


#ifdef PERL_OBJECT
#  define SWIG_MAYBE_PERL_OBJECT CPerlObj *pPerl,
#else
#  define SWIG_MAYBE_PERL_OBJECT
#endif

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(int)               SWIG_Perl_ConvertPtr(SWIG_MAYBE_PERL_OBJECT SV *, void **, swig_type_info *, int flags);
SWIGIMPORT(void)              SWIG_Perl_MakePtr(SWIG_MAYBE_PERL_OBJECT SV *, void *, swig_type_info *, int flags);
SWIGIMPORT(SV *)              SWIG_Perl_NewPointerObj(SWIG_MAYBE_PERL_OBJECT void *, swig_type_info *, int flags);
SWIGIMPORT(void)              SWIG_Perl_MakePackedObj(SWIG_MAYBE_PERL_OBJECT SV *, void *, int, swig_type_info *);
SWIGIMPORT(int)               SWIG_Perl_ConvertPacked(SWIG_MAYBE_PERL_OBJECT SV *, void *, int, swig_type_info *, int flags);
SWIGIMPORT(swig_type_info *)  SWIG_Perl_TypeCheckRV(SWIG_MAYBE_PERL_OBJECT SV *rv, swig_type_info *ty);
SWIGIMPORT(SV *)              SWIG_Perl_SetError(SWIG_MAYBE_PERL_OBJECT char *);

#else

SWIGRUNTIME(swig_type_info *)
SWIG_Perl_TypeCheckRV(SWIG_MAYBE_PERL_OBJECT SV *rv, swig_type_info *ty) {
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (sv_derived_from(rv, (char *) s->name)) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
        s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Function for getting a pointer value */

SWIGRUNTIME(int) 
SWIG_Perl_ConvertPtr(SWIG_MAYBE_PERL_OBJECT SV *sv, void **ptr, swig_type_info *_t, int flags) {
  swig_type_info *tc;
  void *voidptr = (void *)0;

  /* If magical, apply more magic */
  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    IV tmp = 0;
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
        mg = mg_find(tsv,'P');
        if (mg) {
          SV *rsv = mg->mg_obj;
          if (sv_isobject(rsv)) {
            tmp = SvIV((SV*)SvRV(rsv));
          }
        }
      } else {
        return -1;
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    voidptr = (void *)tmp;
    if (!_t) {
      *(ptr) = voidptr;
      return 0;
    }
  } else if (! SvOK(sv)) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return 0;
  } else if (SvTYPE(sv) == SVt_RV) {  /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv))
      return 0;
    else
      return -1;
  } else {                            /* Don't know what it is */
    *(ptr) = (void *) 0;
    return -1;
  }
  if (_t) {
    /* Now see if the types match */
    tc = SWIG_TypeCheckRV(sv,_t);
    if (!tc) {
      *ptr = voidptr;
      return -1;
    }
    *ptr = SWIG_TypeCast(tc,voidptr);
    return 0;
  }
  *ptr = voidptr;
  return 0;
}

SWIGRUNTIME(void)
SWIG_Perl_MakePtr(SWIG_MAYBE_PERL_OBJECT SV *sv, void *ptr, swig_type_info *t, int flags) {
  if (ptr && (flags & SWIG_SHADOW)) {
    SV *self;
    SV *obj=newSV(0);
    HV *hash=newHV();
    HV *stash;
    sv_setref_pv(obj, (char *) t->name, ptr);
    stash=SvSTASH(SvRV(obj));
    if (flags & SWIG_OWNER) {
      HV *hv;
      GV *gv=*(GV**)hv_fetch(stash, "OWNER", 5, TRUE);
      if (!isGV(gv))
        gv_init(gv, stash, "OWNER", 5, FALSE);
      hv=GvHVn(gv);
      hv_store_ent(hv, obj, newSViv(1), 0);
    }
    sv_magic((SV *)hash, (SV *)obj, 'P', Nullch, 0);
    SvREFCNT_dec(obj);
    self=newRV_noinc((SV *)hash);
    sv_setsv(sv, self);
    SvREFCNT_dec((SV *)self);
    sv_bless(sv, stash);
  }
  else {
    sv_setref_pv(sv, (char *) t->name, ptr);
  }
}

SWIGRUNTIME(SV *)
SWIG_Perl_NewPointerObj(SWIG_MAYBE_PERL_OBJECT void *ptr, swig_type_info *t, int flags) {
  SV *result = sv_newmortal();
  SWIG_MakePtr(result, ptr, t, flags);
  return result;
}

SWIGRUNTIME(void)
  SWIG_Perl_MakePackedObj(SWIG_MAYBE_PERL_OBJECT SV *sv, void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  sv_setpv(sv, result);
}

/* Convert a packed value value */
SWIGRUNTIME(int)
SWIG_Perl_ConvertPacked(SWIG_MAYBE_PERL_OBJECT SV *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c = 0;

  if ((!obj) || (!SvOK(obj))) return -1;
  c = SvPV(obj, PL_na);
  /* Pointer values must start with leading underscore */
  if (*c != '_') return -1;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) return -1;
  }
  return 0;
}

SWIGRUNTIME(void)
SWIG_Perl_SetError(SWIG_MAYBE_PERL_OBJECT const char *error) {
  if (error) sv_setpv(perl_get_sv("@", TRUE), error);
}

SWIGRUNTIME(void)
SWIG_Perl_SetErrorSV(SWIG_MAYBE_PERL_OBJECT SV *error) {
  if (error) sv_setsv(perl_get_sv("@", TRUE), error);
}

SWIGRUNTIME(void)
SWIG_Perl_SetErrorf(const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  sv_vsetpvfn(perl_get_sv("@", TRUE), fmt, strlen(fmt), &args, Null(SV**), 0, Null(bool*));
  va_end(args);
}

#endif

/* Macros for low-level exception handling */
#define SWIG_fail       goto fail
#define SWIG_croak(x)   { SWIG_SetError(x); goto fail; }
#define SWIG_croakSV(x) { SWIG_SetErrorSV(x); goto fail; }
/* most preprocessors do not support vararg macros :-( */
/* #define SWIG_croakf(x...) { SWIG_SetErrorf(x); goto fail; } */


typedef XS(SwigPerlWrapper);
typedef SwigPerlWrapper *SwigPerlWrapperPtr;

/* Structure for command table */
typedef struct {
  const char         *name;
  SwigPerlWrapperPtr  wrapper;
} swig_command_info;

/* Information for constant table */

#define SWIG_INT     1
#define SWIG_FLOAT   2
#define SWIG_STRING  3
#define SWIG_POINTER 4
#define SWIG_BINARY  5

/* Constant information structure */
typedef struct swig_constant_info {
    int              type;
    const char      *name;
    long             lvalue;
    double           dvalue;
    void            *pvalue;
    swig_type_info **ptype;
} swig_constant_info;

#ifdef __cplusplus
}
#endif

/* Structure for variable table */
typedef struct {
  const char   *name;
  SwigMagicFunc   set;
  SwigMagicFunc   get;
  swig_type_info  **type;
} swig_variable_info;

/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
  #ifndef MULTIPLICITY
     static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) {
  #else
     static void _swig_create_magic(SV *sv, char *name, int (*set)(struct interpreter*, SV *, MAGIC *), int (*get)(struct interpreter*, SV *,MAGIC *)) {
  #endif
#else
#  define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerlObj *pPerl, SV *sv, const char *name, int (CPerlObj::*set)(SV *, MAGIC *), int (CPerlObj::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',(char *) name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = (SwigMagicFuncHack) get;
  mg->mg_virtual->svt_set = (SwigMagicFuncHack) set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}






#ifdef do_open
  #undef do_open
#endif
#ifdef do_close
  #undef do_close
#endif
#ifdef scalar
  #undef scalar
#endif
#ifdef list
  #undef list
#endif
#ifdef apply
  #undef apply
#endif
#ifdef convert
  #undef convert
#endif
#ifdef Error
  #undef Error
#endif
#ifdef form
  #undef form
#endif
#ifdef vform
  #undef vform
#endif
#ifdef LABEL
  #undef LABEL
#endif
#ifdef METHOD
  #undef METHOD
#endif
#ifdef Move
  #undef Move
#endif
#ifdef yylex
  #undef yylex
#endif
#ifdef yyparse
  #undef yyparse
#endif
#ifdef yyerror
  #undef yyerror
#endif
#ifdef invert
  #undef invert
#endif
#ifdef ref
  #undef ref
#endif
#ifdef ENTER
  #undef ENTER
#endif


/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_PartialList swig_types[0] 
#define  SWIGTYPE_p_SpcFile swig_types[1] 
#define  SWIGTYPE_p_Breakpoint swig_types[2] 
#define  SWIGTYPE_p_Analyzer swig_types[3] 
#define  SWIGTYPE_p_double swig_types[4] 
#define  SWIGTYPE_p_Partial swig_types[5] 
#define  SWIGTYPE_p_Loris__Partial swig_types[6] 
#define  SWIGTYPE_p_BreakpointEnvelope swig_types[7] 
#define  SWIGTYPE_p_BreakpointPosition swig_types[8] 
#define  SWIGTYPE_p_AiffFile swig_types[9] 
#define  SWIGTYPE_p_SampleVector swig_types[10] 
#define  SWIGTYPE_p_SdifFile swig_types[11] 
#define  SWIGTYPE_p_NewPartialIterator swig_types[12] 
#define  SWIGTYPE_p_NewPlistIterator swig_types[13] 
#define  SWIGTYPE_p_Marker swig_types[14] 
#define  SWIGTYPE_p_PartialListIterator swig_types[15] 
#define  SWIGTYPE_p_PartialIterator swig_types[16] 
static swig_type_info *swig_types[18];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    boot_perLoris

#define SWIG_name   "perLorisc::boot_perLoris"
#define SWIG_prefix "perLorisc::"

#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
#ifndef MULTIPLICITY
SWIGEXPORT(void) SWIG_init (CV* cv);
#else
SWIGEXPORT(void) SWIG_init (pTHXo_ CV* cv);
#endif
#else
SWIGEXPORT(void) SWIG_init (CV *cv, CPerlObj *);
#endif


		#undef list
	
 
/*	exception handling code for procedural interface calls

	Copied from the SWIG manual. Tastes great, less filling.
*/
static char error_message[256];
static int error_status = 0;

void throw_exception(const char *msg) {
        strncpy(error_message,msg,256);
        error_status = 1;
}

void clear_exception() {
        error_status = 0;
}
char *check_exception() {
        if (error_status) return error_message;
        else return NULL;
}

#include <loris.h>

//	import the entire Loris namespace, because
//	SWIG does not seem to like to wrap functions
//	with qualified names (like Loris::channelize),
//	they simply get ignored.
using namespace Loris;

//	notification function for Loris debugging
//	and notifications, installed in initialization
//	block below:
static void printf_notifier( const char * s )
{
	printf("*\t%s\n", s);
}	

//	exception handling for the procedural interface
//	(the pi catches all exceptions and handles them
//	by passing their string descriptions to this 
//	function):
/*static char EXCEPTION_THROWN[256];
static void exception_handler( const char * s )
{
	snprintf(EXCEPTION_THROWN, 255, "%s", s);
}*/


#include <vector>
#include <string>
using std::vector;
using std::string;

// helper function for converting a string to a
// vector of doubles (this will work anywhere)
static bool fill_vector( const string & s, vector<double> & v )
{
	std::string::size_type beg, end;
	const std::string numparts("1234567890+-.");
	beg = s.find_first_of( numparts );
	while ( beg != std::string::npos )
	{
		end = s.find_first_not_of( numparts, beg );
		if ( end == std::string::npos )
			end = s.length();

		double x = atof( s.c_str() + beg );
		v.push_back(x);

		beg = s.find_first_of( numparts, end );
	}
	return true;
}



#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


#define SWIG_exception(a,b)   SWIG_croak(b)


#include <Exception.h>
#include <Notifier.h>
#include <vector>

void dilate_v( PartialList * partials, vector<double> & ivec, vector<double> & tvec )
{
	Loris::debugger << ivec.size() << " initial points, " 
					<< tvec.size() << " target points" << Loris::endl;
					
	if ( ivec.size() != tvec.size() )
	{
		Throw( InvalidArgument, "Invalid arguments to dilate(): there must be as many target points as initial points" );
	}
	
	double * initial = &(ivec[0]);
	double * target = &(tvec[0]);
	int npts = ivec.size();
	dilate( partials, initial, target, npts );
}


	void dilate_s( PartialList * partials, 
				   char * initial_times, char * target_times )
	{
		std::vector<double> ivec;
		fill_vector( initial_times, ivec );
		std::vector<double> tvec;
		fill_vector( target_times, tvec );
		
		dilate_v( partials, ivec, tvec );
	}


	PartialList * importSdif( const char * path )
	{
		PartialList * dst = createPartialList();
		importSdif( path, dst );

		// check for exception:
		if (check_exception())
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	#include<BreakpointEnvelope.h>


	PartialList * importSpc( const char * path )
	{
		PartialList * dst = createPartialList();
		importSpc( path, dst );

		// check for exception:
		if (check_exception())
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	PartialList * morph( const PartialList * src0, const PartialList * src1, 
						 const BreakpointEnvelope * ffreq, 
						 const BreakpointEnvelope * famp, 
						 const BreakpointEnvelope * fbw )
	{
		PartialList * dst = createPartialList();
		morph( src0, src1, ffreq, famp, fbw, dst );
		
		// check for exception:
		if ( check_exception() )
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}
	PartialList * morph( const PartialList * src0, const PartialList * src1, 
						 double freqweight, 
						 double ampweight, 
						 double bwweight )
	{
		BreakpointEnvelope ffreq( freqweight ), famp( ampweight ), fbw( bwweight );
		
		PartialList * dst = createPartialList();
		morph( src0, src1, &ffreq, &famp, &fbw, dst );
		
		// check for exception:
		if ( check_exception() )
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	SampleVector * synthesize( const PartialList * partials, double srate = 44100.0 )
	{
		SampleVector * dst = createSampleVector(0);
		synthesize( partials, dst, srate );
				
		// check for exception:
		if ( check_exception() )
		{
			destroySampleVector( dst );
			dst = NULL;
		}
		return dst;
	}


	PartialList * copyLabeled( PartialList * partials, long label )
	{
		PartialList * dst = createPartialList();
		copyLabeled( partials, label, dst );
		
		// check for exception:
		if ( check_exception() )
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	PartialList * extractLabeled( PartialList * partials, long label )
	{
		PartialList * dst = createPartialList();
		extractLabeled( partials, label, dst );
		
		// check for exception:
		if ( check_exception() )
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}

	
	void scaleAmp( PartialList * partials, double w )
	{
		BreakpointEnvelope e( w );
		scaleAmp( partials, &e );
	}
	
	
	void scaleBandwidth( PartialList * partials, double w )
	{
		BreakpointEnvelope e( w );
		scaleBandwidth( partials, &e );
	}
	
	
	void scaleFrequency( PartialList * partials, double w )
	{
		BreakpointEnvelope e( w );
		scaleFrequency( partials, &e );
	}
	
	
	void scaleNoiseRatio( PartialList * partials, double w )
	{
		BreakpointEnvelope e( w );
		scaleNoiseRatio( partials, &e );
	}
	
	
	void shiftPitch( PartialList * partials, double w )
	{
		BreakpointEnvelope e( w );
		shiftPitch( partials, &e );
	}


	const char * version( void )
	{
		static const char * vstr = LORIS_VERSION_STR;
		return vstr;
	}


	#include <Exception.h>
	#include <stdexcept>


	#include<Marker.h>

char const *Marker_name(Marker *self){ return self->name().c_str(); }

	#include<AiffFile.h>

AiffFile *new_AiffFile__SWIG_2(PartialList *l,double sampleRate,double fadeTime){
			return new AiffFile( l->begin(), l->end(), sampleRate, fadeTime );
		}
SampleVector *AiffFile_samples(AiffFile *self){
			SampleVector * vec = new SampleVector( self->samples() );
			return vec;
		}
int AiffFile_channels(AiffFile *self){ return 1; }
void AiffFile_addPartials(AiffFile *self,PartialList *l,double fadeTime){
			self->addPartials( l->begin(), l->end(), fadeTime );
		}
int AiffFile_numMarkers(AiffFile *self){ return self->markers().size(); }
Marker &AiffFile_getMarker(AiffFile *self,int i){
		 	if ( i < 0 || i >= self->markers().size() )
		 	{
		 		Throw( InvalidArgument, "Marker index out of range." );
		 	}
		 	return self->markers()[i];
		 }
void AiffFile_removeMarker(AiffFile *self,int i){
		 	if ( i < 0 || i >= self->markers().size() )
		 	{
		 		Throw( InvalidArgument, "Marker index out of range." );
		 	}
		 	self->markers().erase( self->markers().begin() + i );
		 }
void AiffFile_addMarker(AiffFile *self,Marker m){
		 	self->markers().push_back( m );
		 }

	#include<Analyzer.h>
	#include<Partial.h>

Analyzer *new_Analyzer(double resolutionHz,double windowWidthHz){
			if ( windowWidthHz == 0. )
				windowWidthHz = resolutionHz;
			return new Analyzer( resolutionHz, windowWidthHz );
		}
Analyzer *Analyzer_copy(Analyzer *self){
			return new Analyzer( *self );
		}
PartialList *Analyzer_analyze__SWIG_0(Analyzer *self,SampleVector const *vec,double srate){
			PartialList * partials = new PartialList();
			if ( ! vec->empty() )
				self->analyze( &((*vec)[0]), &((*vec)[vec->size()]), srate );
			partials->splice( partials->end(), self->partials() );
			return partials;
		}
PartialList *Analyzer_analyze__SWIG_1(Analyzer *self,SampleVector const *vec,double srate,BreakpointEnvelope *env){
			PartialList * partials = new PartialList();
			if ( ! vec->empty() )
				self->analyze( *vec, srate, *env );
			partials->splice( partials->end(), self->partials() );
			return partials;
		}

	#include<BreakpointEnvelope.h>

BreakpointEnvelope *BreakpointEnvelope_copy(BreakpointEnvelope *self){
			return new BreakpointEnvelope( *self );
		}

	BreakpointEnvelope *
	BreakpointEnvelopeWithValue( double initialValue )
	{
		return new BreakpointEnvelope( initialValue );
	}

SampleVector *SampleVector_copy(SampleVector *self){
			return new SampleVector( *self );
		}
double SampleVector_getAt(SampleVector *self,unsigned long idx){
			if ( idx >= self->size() )
				throw std::out_of_range("SampleVector::getAt index out of range");
			return (*self)[idx];
		}
void SampleVector_setAt(SampleVector *self,unsigned long idx,double x){
			if ( idx >= self->size() )
				throw std::out_of_range("SampleVector::setAt index out of range");
			(*self)[idx] = x;
		}

	#include<SdifFile.h>

SdifFile *new_SdifFile__SWIG_2(PartialList *l){
			return new SdifFile( l->begin(), l->end() );
		}
PartialList *SdifFile_partials(SdifFile *self){
			PartialList * plist = new PartialList( self->partials() );
			return plist;
		}
void SdifFile_addPartials(SdifFile *self,PartialList *l){
			self->addPartials( l->begin(), l->end() );
		}
int SdifFile_numMarkers(SdifFile *self){ return self->markers().size(); }
Marker &SdifFile_getMarker(SdifFile *self,int i){
		 	if ( i < 0 || i >= self->markers().size() )
		 	{
		 		Throw( InvalidArgument, "Marker index out of range." );
		 	}
		 	return self->markers()[i];
		 }
void SdifFile_removeMarker(SdifFile *self,int i){
		 	if ( i < 0 || i >= self->markers().size() )
		 	{
		 		Throw( InvalidArgument, "Marker index out of range." );
		 	}
		 	self->markers().erase( self->markers().begin() + i );
		 }
void SdifFile_addMarker(SdifFile *self,Marker m){
		 	self->markers().push_back( m );
		 }

	#include<SpcFile.h>

SpcFile *new_SpcFile__SWIG_2(PartialList *l,double midiNoteNum){
			return new SpcFile( l->begin(), l->end(), midiNoteNum );
		}
PartialList *SpcFile_partials(SpcFile *self){
			PartialList * plist = new PartialList( self->partials().begin(), self->partials().end() );
			return plist;
		}
void SpcFile_addPartials(SpcFile *self,PartialList *l){
			self->addPartials( l->begin(), l->end() );
		}
int SpcFile_numMarkers(SpcFile *self){ return self->markers().size(); }
Marker &SpcFile_getMarker(SpcFile *self,int i){
		 	if ( i < 0 || i >= self->markers().size() )
		 	{
		 		Throw( InvalidArgument, "Marker index out of range." );
		 	}
		 	return self->markers()[i];
		 }
void SpcFile_removeMarker(SpcFile *self,int i){
		 	if ( i < 0 || i >= self->markers().size() )
		 	{
		 		Throw( InvalidArgument, "Marker index out of range." );
		 	}
		 	self->markers().erase( self->markers().begin() + i );
		 }
void SpcFile_addMarker(SpcFile *self,Marker m){
		 	self->markers().push_back( m );
		 }

#include<Partial.h>
#include<PartialList.h>
#include<PartialUtils.h>
#include<Notifier.h>
#include <list>

using Loris::debugger;
using Loris::Partial;
using Loris::PartialList;
using Loris::PartialListIterator;
using Loris::Breakpoint;

typedef Loris::Partial::iterator PartialIterator;

/*	new iterator definitions

	These are much better than the old things, more like the 
	iterators in Python 2.2 and later, very much simpler.
	The old iterators will be replaced entirely by the new
	kind soon, very soon.
	
	Note: the only reason I cannot merge the new functionality 
	into the old iterators is that the old iterators use the
	next() method to advance and return another iterator. Duh.
*/
struct NewPlistIterator
{
	PartialList & subject;
	PartialList::iterator it;

	NewPlistIterator( PartialList & l ) : subject( l ), it ( l.begin() ) {}
	NewPlistIterator( PartialList & l, PartialList::iterator i ) : subject( l ), it ( i ) {}
	
	bool atEnd( void ) { return it == subject.end(); }
	bool hasNext( void ) { return !atEnd(); }

	Partial * next( void )
	{
		if ( atEnd() )
		{
			throw_exception("end of PartialList");
			return 0;
		}
		Partial * ret = &(*it);
		++it;
		return ret;
	}
};

typedef Partial::iterator BreakpointPosition;

struct NewPartialIterator
{
	Partial & subject;
	Partial::iterator it;

	NewPartialIterator( Partial & p ) : subject( p ), it ( p.begin() ) {}
	NewPartialIterator( Partial & p, Partial::iterator i ) : subject( p ), it ( i ) {}
	
	bool atEnd( void ) { return it == subject.end(); }
	bool hasNext( void ) { return !atEnd(); }

	BreakpointPosition * next( void )
	{
		if ( atEnd() )
		{
			throw_exception("end of Partial");
			return 0;
		}
		BreakpointPosition * ret = new BreakpointPosition(it);
		++it;
		return ret;
	}
};


Partial *NewPlistIterator_partial(NewPlistIterator *self){
			if ( self->atEnd() )
			{
				throw_exception("end of PartialList");
				return 0;
			}			
			Partial & current = *(self->it);
			return &current;
		}
void PartialList_timeSpan(PartialList *self,double *tmin_out,double *tmax_out){
		 	std::pair<double, double> span = 
		 		Loris::PartialUtils::timeSpan( self->begin(), self->end() );
		 	*tmin_out = span.first;
		 	*tmax_out = span.second;
		 }
NewPlistIterator *PartialList_iterator(PartialList *self){
			return new NewPlistIterator(*self);
		}
void PartialList_append(PartialList *self,Partial *partial){
			self->insert( self->end(), *partial );
		}
NewPlistIterator *PartialList_insert__SWIG_0(PartialList *self,NewPlistIterator *position,Partial *partial){
			if ( self != &(position->subject) )
				return 0;
			return new NewPlistIterator(*self, self->insert( position->it, *partial ) );
		}
void PartialList_erase__SWIG_0(PartialList *self,Partial *partial){
			PartialList::iterator it = self->begin();
			while ( it != self->end() )
			{
				if ( &(*it) == partial )	// compare addresses
				{
					self->erase( it );
					return;
				}
				++it;
			}
			throw_exception( "PartialList.erase(p): p not in PartialList" );
		}
void PartialList_splice__SWIG_0(PartialList *self,PartialList *other){
			self->splice( self->end(), *other );
		}
PartialListIterator PartialList_insert__SWIG_2(PartialList *self,Partial const &partial){
			return self->insert( self->end(), partial );
		}
PartialList *PartialList_copy(PartialList *self){ return new PartialList( *self ); }
NewPartialIterator *Partial_iterator(Partial *self){
			return new NewPartialIterator(*self);
		}
void Partial_erase__SWIG_0(Partial *self,BreakpointPosition *pos){
			if ( *pos != self->end() )
			{
				*pos = self->erase( *pos );
			}
		}
Partial *Partial_copy(Partial *self){ return new Partial( *self ); }
int Partial_equals(Partial *self,Partial *other){
			return *self == *other;
		}
Breakpoint *Breakpoint_copy(Breakpoint *self){
			return new Breakpoint( *self );
		}
int Breakpoint_equals(Breakpoint *self,Breakpoint *other){
			return *self == *other;
		}
double BreakpointPosition_time(BreakpointPosition *self){ 
			return self->time(); 
		}
Breakpoint *BreakpointPosition_breakpoint(BreakpointPosition *self){ 
			return &(self->breakpoint());
		}
double BreakpointPosition_frequency(BreakpointPosition *self){ return self->breakpoint().frequency(); }
double BreakpointPosition_amplitude(BreakpointPosition *self){ return self->breakpoint().amplitude(); }
double BreakpointPosition_bandwidth(BreakpointPosition *self){ return self->breakpoint().bandwidth(); }
double BreakpointPosition_phase(BreakpointPosition *self){ return self->breakpoint().phase(); }
void BreakpointPosition_setFrequency(BreakpointPosition *self,double x){ self->breakpoint().setFrequency( x ); }
void BreakpointPosition_setAmplitude(BreakpointPosition *self,double x){ self->breakpoint().setAmplitude( x ); }
void BreakpointPosition_setBandwidth(BreakpointPosition *self,double x){ self->breakpoint().setBandwidth( x ); }
void BreakpointPosition_setPhase(BreakpointPosition *self,double x){ self->breakpoint().setPhase( x ); }
Breakpoint *PartialIterator_breakpoint(PartialIterator *self){ 
			return &(self->breakpoint());
		}
PartialIterator *PartialIterator_copy(PartialIterator *self){
			return new PartialIterator( *self );
		}
PartialIterator *PartialIterator_next(PartialIterator *self){
			PartialIterator * next = new PartialIterator(*self);
			++(*next);
			return next;
		}
PartialIterator *PartialIterator_prev(PartialIterator *self){
			PartialIterator * prev = new PartialIterator(*self);
			--(*prev);
			return prev;
		}
int PartialIterator_equals(PartialIterator *self,PartialIterator *other){
			return *self == *other;
		}
int PartialIterator_isInRange(PartialIterator *self,PartialIterator const *begin,PartialIterator const *end){	
		 	PartialIterator it;
		 	for ( it = *begin; it != *end; ++it )
		 	{
		 		if ( it == *self )
		 			return true;
		 	}
		 	return false;
		 }
PartialListIterator *PartialListIterator_copy(PartialListIterator *self){
			return new PartialListIterator( *self );
		}
PartialListIterator *PartialListIterator_next(PartialListIterator *self){
			PartialListIterator * next = new PartialListIterator(*self);
			++(*next);
			return next;
		}
PartialListIterator *PartialListIterator_prev(PartialListIterator *self){
			PartialListIterator * prev = new PartialListIterator(*self);
			--(*prev);
			return prev;
		}
Partial *PartialListIterator_partial(PartialListIterator *self){
			Partial & current = **self;
			return &current;
		}
int PartialListIterator_equals(PartialListIterator *self,PartialListIterator *other){
			return *self == *other;
		}
int PartialListIterator_isInRange(PartialListIterator *self,PartialListIterator const *begin,PartialListIterator const *end){	
		 	PartialListIterator it;
		 	for ( it = *begin; it != *end; ++it )
		 	{
		 		if ( it == *self )
		 			return true;
		 	}
		 	return false;
		 }
#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_perLoris_var::
class _wrap_perLoris_var : public CPerlObj {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(pTHX_ SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}


#ifdef PERL_OBJECT
};
#endif

#ifdef __cplusplus
extern "C" {
#endif
XS(_wrap_channelize) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
        int arg3 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: channelize(partials,refFreqEnvelope,refLabel);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of channelize. Expected _p_PartialList");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,0) < 0) {
                SWIG_croak("Type error in argument 2 of channelize. Expected _p_BreakpointEnvelope");
            }
        }
        arg3 = (int) SvIV(ST(2));
        {
            char * err;
            clear_exception();
            channelize(arg1,arg2,arg3);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_createFreqReference) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        double arg2 ;
        double arg3 ;
        long arg4 = (long) 0 ;
        BreakpointEnvelope *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 4)) {
            SWIG_croak("Usage: createFreqReference(partials,minFreq,maxFreq,numSamps);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of createFreqReference. Expected _p_PartialList");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        arg3 = (double) SvNV(ST(2));
        
        if (items > 3) {
            arg4 = (long) SvIV(ST(3));
        }
        {
            char * err;
            clear_exception();
            result = (BreakpointEnvelope *)createFreqReference(arg1,arg2,arg3,arg4);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BreakpointEnvelope, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_dilate) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        char *arg2 ;
        char *arg3 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: dilate(partials,initial_times,target_times);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of dilate. Expected _p_PartialList");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            char * err;
            clear_exception();
            dilate_s(arg1,arg2,arg3);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_distill) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: distill(partials);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of distill. Expected _p_PartialList");
            }
        }
        {
            char * err;
            clear_exception();
            distill(arg1);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_exportAiff) {
    {
        char *arg1 ;
        SampleVector *arg2 = (SampleVector *) 0 ;
        double arg3 = (double) 44100.0 ;
        int arg4 = (int) 1 ;
        int arg5 = (int) 16 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 5)) {
            SWIG_croak("Usage: exportAiff(path,samples,samplerate,nchannels,bitsPerSamp);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SampleVector,0) < 0) {
                SWIG_croak("Type error in argument 2 of exportAiff. Expected _p_SampleVector");
            }
        }
        if (items > 2) {
            arg3 = (double) SvNV(ST(2));
            
        }
        if (items > 3) {
            arg4 = (int) SvIV(ST(3));
        }
        if (items > 4) {
            arg5 = (int) SvIV(ST(4));
        }
        {
            char * err;
            clear_exception();
            exportAiff((char const *)arg1,arg2,arg3,arg4,arg5);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_exportSdif) {
    {
        char *arg1 ;
        PartialList *arg2 = (PartialList *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: exportSdif(path,partials);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 2 of exportSdif. Expected _p_PartialList");
            }
        }
        {
            char * err;
            clear_exception();
            exportSdif((char const *)arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_exportSpc) {
    {
        char *arg1 ;
        PartialList *arg2 = (PartialList *) 0 ;
        double arg3 ;
        int arg4 = (int) true ;
        double arg5 = (double) 0. ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 5)) {
            SWIG_croak("Usage: exportSpc(path,partials,midiPitch,enhanced,endApproachTime);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 2 of exportSpc. Expected _p_PartialList");
            }
        }
        arg3 = (double) SvNV(ST(2));
        
        if (items > 3) {
            arg4 = (int) SvIV(ST(3));
        }
        if (items > 4) {
            arg5 = (double) SvNV(ST(4));
            
        }
        {
            char * err;
            clear_exception();
            exportSpc((char const *)arg1,arg2,arg3,arg4,arg5);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_importSdif) {
    {
        char *arg1 ;
        PartialList *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: importSdif(path);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        {
            char * err;
            clear_exception();
            result = (PartialList *)importSdif((char const *)arg1);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_importSpc) {
    {
        char *arg1 ;
        PartialList *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: importSpc(path);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        {
            char * err;
            clear_exception();
            result = (PartialList *)importSpc((char const *)arg1);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_morph__SWIG_0) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        PartialList *arg2 = (PartialList *) 0 ;
        BreakpointEnvelope *arg3 = (BreakpointEnvelope *) 0 ;
        BreakpointEnvelope *arg4 = (BreakpointEnvelope *) 0 ;
        BreakpointEnvelope *arg5 = (BreakpointEnvelope *) 0 ;
        PartialList *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: morph(src0,src1,ffreq,famp,fbw);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of morph. Expected _p_PartialList");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 2 of morph. Expected _p_PartialList");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_BreakpointEnvelope,0) < 0) {
                SWIG_croak("Type error in argument 3 of morph. Expected _p_BreakpointEnvelope");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_BreakpointEnvelope,0) < 0) {
                SWIG_croak("Type error in argument 4 of morph. Expected _p_BreakpointEnvelope");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_BreakpointEnvelope,0) < 0) {
                SWIG_croak("Type error in argument 5 of morph. Expected _p_BreakpointEnvelope");
            }
        }
        {
            char * err;
            clear_exception();
            result = (PartialList *)morph((PartialList const *)arg1,(PartialList const *)arg2,(BreakpointEnvelope const *)arg3,(BreakpointEnvelope const *)arg4,(BreakpointEnvelope const *)arg5);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_morph__SWIG_1) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        PartialList *arg2 = (PartialList *) 0 ;
        double arg3 ;
        double arg4 ;
        double arg5 ;
        PartialList *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: morph(src0,src1,freqweight,ampweight,bwweight);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of morph. Expected _p_PartialList");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 2 of morph. Expected _p_PartialList");
            }
        }
        arg3 = (double) SvNV(ST(2));
        
        arg4 = (double) SvNV(ST(3));
        
        arg5 = (double) SvNV(ST(4));
        
        {
            char * err;
            clear_exception();
            result = (PartialList *)morph((PartialList const *)arg1,(PartialList const *)arg2,arg3,arg4,arg5);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_morph) {
    dXSARGS;
    
    if (items == 5) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *tmp;
                    if (SWIG_ConvertPtr(ST(2), (void **) &tmp, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                        _v = 0;
                    } else {
                        _v = 1;
                    }
                }
                if (_v) {
                    {
                        void *tmp;
                        if (SWIG_ConvertPtr(ST(3), (void **) &tmp, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                            _v = 0;
                        } else {
                            _v = 1;
                        }
                    }
                    if (_v) {
                        {
                            void *tmp;
                            if (SWIG_ConvertPtr(ST(4), (void **) &tmp, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                                _v = 0;
                            } else {
                                _v = 1;
                            }
                        }
                        if (_v) {
                            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_morph__SWIG_0); return;
                        }
                    }
                }
            }
        }
    }
    if (items == 5) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    _v = SvNIOK(ST(2)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = SvNIOK(ST(3)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = SvNIOK(ST(4)) ? 1 : 0;
                        }
                        if (_v) {
                            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_morph__SWIG_1); return;
                        }
                    }
                }
            }
        }
    }
    
    croak("No matching function for overloaded 'morph'");
    XSRETURN(0);
}


XS(_wrap_synthesize) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        double arg2 = (double) 44100.0 ;
        SampleVector *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 2)) {
            SWIG_croak("Usage: synthesize(partials,srate);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of synthesize. Expected _p_PartialList");
            }
        }
        if (items > 1) {
            arg2 = (double) SvNV(ST(1));
            
        }
        {
            char * err;
            clear_exception();
            result = (SampleVector *)synthesize((PartialList const *)arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SampleVector, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_crop) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        double arg2 ;
        double arg3 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: crop(partials,t1,t2);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of crop. Expected _p_PartialList");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        arg3 = (double) SvNV(ST(2));
        
        {
            char * err;
            clear_exception();
            crop(arg1,arg2,arg3);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_copyLabeled) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        long arg2 ;
        PartialList *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: copyLabeled(partials,label);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of copyLabeled. Expected _p_PartialList");
            }
        }
        arg2 = (long) SvIV(ST(1));
        {
            char * err;
            clear_exception();
            result = (PartialList *)copyLabeled(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_extractLabeled) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        long arg2 ;
        PartialList *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: extractLabeled(partials,label);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of extractLabeled. Expected _p_PartialList");
            }
        }
        arg2 = (long) SvIV(ST(1));
        {
            char * err;
            clear_exception();
            result = (PartialList *)extractLabeled(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_removeLabeled) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        long arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: removeLabeled(partials,label);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of removeLabeled. Expected _p_PartialList");
            }
        }
        arg2 = (long) SvIV(ST(1));
        {
            char * err;
            clear_exception();
            removeLabeled(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_resample) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: resample(partials,interval);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of resample. Expected _p_PartialList");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            char * err;
            clear_exception();
            resample(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_scaleAmp__SWIG_0) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: scaleAmp(partials,ampEnv);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of scaleAmp. Expected _p_PartialList");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,0) < 0) {
                SWIG_croak("Type error in argument 2 of scaleAmp. Expected _p_BreakpointEnvelope");
            }
        }
        {
            char * err;
            clear_exception();
            scaleAmp(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_scaleBandwidth__SWIG_0) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: scaleBandwidth(partials,bwEnv);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of scaleBandwidth. Expected _p_PartialList");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,0) < 0) {
                SWIG_croak("Type error in argument 2 of scaleBandwidth. Expected _p_BreakpointEnvelope");
            }
        }
        {
            char * err;
            clear_exception();
            scaleBandwidth(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_scaleFrequency__SWIG_0) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: scaleFrequency(partials,freqEnv);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of scaleFrequency. Expected _p_PartialList");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,0) < 0) {
                SWIG_croak("Type error in argument 2 of scaleFrequency. Expected _p_BreakpointEnvelope");
            }
        }
        {
            char * err;
            clear_exception();
            scaleFrequency(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_scaleNoiseRatio__SWIG_0) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: scaleNoiseRatio(partials,noiseEnv);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of scaleNoiseRatio. Expected _p_PartialList");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,0) < 0) {
                SWIG_croak("Type error in argument 2 of scaleNoiseRatio. Expected _p_BreakpointEnvelope");
            }
        }
        {
            char * err;
            clear_exception();
            scaleNoiseRatio(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_shiftPitch__SWIG_0) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: shiftPitch(partials,pitchEnv);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of shiftPitch. Expected _p_PartialList");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,0) < 0) {
                SWIG_croak("Type error in argument 2 of shiftPitch. Expected _p_BreakpointEnvelope");
            }
        }
        {
            char * err;
            clear_exception();
            shiftPitch(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_scaleAmp__SWIG_1) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: scaleAmp(partials,w);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of scaleAmp. Expected _p_PartialList");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            char * err;
            clear_exception();
            scaleAmp(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_scaleAmp) {
    dXSARGS;
    
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_scaleAmp__SWIG_0); return;
            }
        }
    }
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = SvNIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_scaleAmp__SWIG_1); return;
            }
        }
    }
    
    croak("No matching function for overloaded 'scaleAmp'");
    XSRETURN(0);
}


XS(_wrap_scaleBandwidth__SWIG_1) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: scaleBandwidth(partials,w);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of scaleBandwidth. Expected _p_PartialList");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            char * err;
            clear_exception();
            scaleBandwidth(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_scaleBandwidth) {
    dXSARGS;
    
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_scaleBandwidth__SWIG_0); return;
            }
        }
    }
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = SvNIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_scaleBandwidth__SWIG_1); return;
            }
        }
    }
    
    croak("No matching function for overloaded 'scaleBandwidth'");
    XSRETURN(0);
}


XS(_wrap_scaleFrequency__SWIG_1) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: scaleFrequency(partials,w);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of scaleFrequency. Expected _p_PartialList");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            char * err;
            clear_exception();
            scaleFrequency(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_scaleFrequency) {
    dXSARGS;
    
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_scaleFrequency__SWIG_0); return;
            }
        }
    }
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = SvNIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_scaleFrequency__SWIG_1); return;
            }
        }
    }
    
    croak("No matching function for overloaded 'scaleFrequency'");
    XSRETURN(0);
}


XS(_wrap_scaleNoiseRatio__SWIG_1) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: scaleNoiseRatio(partials,w);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of scaleNoiseRatio. Expected _p_PartialList");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            char * err;
            clear_exception();
            scaleNoiseRatio(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_scaleNoiseRatio) {
    dXSARGS;
    
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_scaleNoiseRatio__SWIG_0); return;
            }
        }
    }
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = SvNIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_scaleNoiseRatio__SWIG_1); return;
            }
        }
    }
    
    croak("No matching function for overloaded 'scaleNoiseRatio'");
    XSRETURN(0);
}


XS(_wrap_shiftPitch__SWIG_1) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: shiftPitch(partials,w);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of shiftPitch. Expected _p_PartialList");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            char * err;
            clear_exception();
            shiftPitch(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_shiftPitch) {
    dXSARGS;
    
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_shiftPitch__SWIG_0); return;
            }
        }
    }
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = SvNIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_shiftPitch__SWIG_1); return;
            }
        }
    }
    
    croak("No matching function for overloaded 'shiftPitch'");
    XSRETURN(0);
}


XS(_wrap_shiftTime) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: shiftTime(partials,offset);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of shiftTime. Expected _p_PartialList");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            char * err;
            clear_exception();
            shiftTime(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_sift) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: sift(partials);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of sift. Expected _p_PartialList");
            }
        }
        {
            char * err;
            clear_exception();
            sift(arg1);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_sortByLabel) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: sortByLabel(partials);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of sortByLabel. Expected _p_PartialList");
            }
        }
        {
            char * err;
            clear_exception();
            sortByLabel(arg1);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_version) {
    {
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: version();");
        }
        {
            char * err;
            clear_exception();
            result = (char *)version();
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Marker__SWIG_0) {
    {
        Marker *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_Marker();");
        }
        {
            try
            {
                result = (Marker *)new Marker();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Marker, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Marker__SWIG_1) {
    {
        double arg1 ;
        char *arg2 ;
        Marker *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: new_Marker(t,s);");
        }
        arg1 = (double) SvNV(ST(0));
        
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            try
            {
                result = (Marker *)new Marker(arg1,(char const *)arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Marker, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Marker__SWIG_2) {
    {
        Marker *arg1 = 0 ;
        Marker *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: new_Marker(other);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Marker,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_Marker. Expected _p_Marker");
            }
        }
        {
            try
            {
                result = (Marker *)new Marker((Marker const &)*arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Marker, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Marker) {
    dXSARGS;
    
    if (items == 0) {
        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_Marker__SWIG_0); return;
    }
    if (items == 1) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_Marker, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_Marker__SWIG_2); return;
        }
    }
    if (items == 2) {
        int _v;
        {
            _v = SvNIOK(ST(0)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = SvPOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_Marker__SWIG_1); return;
            }
        }
    }
    
    croak("No matching function for overloaded 'new_Marker'");
    XSRETURN(0);
}


XS(_wrap_Marker_name) {
    {
        Marker *arg1 = (Marker *) 0 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Marker_name(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Marker,0) < 0) {
                SWIG_croak("Type error in argument 1 of Marker_name. Expected _p_Marker");
            }
        }
        {
            try
            {
                result = (char *)Marker_name(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        } else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Marker_time) {
    {
        Marker *arg1 = (Marker *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Marker_time(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Marker,0) < 0) {
                SWIG_croak("Type error in argument 1 of Marker_time. Expected _p_Marker");
            }
        }
        {
            try
            {
                result = (double)(arg1)->time();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Marker_setName) {
    {
        Marker *arg1 = (Marker *) 0 ;
        char *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Marker_setName(self,s);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Marker,0) < 0) {
                SWIG_croak("Type error in argument 1 of Marker_setName. Expected _p_Marker");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            try
            {
                (arg1)->setName((char const *)arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Marker_setTime) {
    {
        Marker *arg1 = (Marker *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Marker_setTime(self,t);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Marker,0) < 0) {
                SWIG_croak("Type error in argument 1 of Marker_setTime. Expected _p_Marker");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setTime(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_Marker) {
    {
        Marker *arg1 = (Marker *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_Marker(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Marker,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_Marker. Expected _p_Marker");
            }
        }
        {
            try
            {
                delete arg1;
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_AiffFile__SWIG_0) {
    {
        char *arg1 ;
        AiffFile *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: new_AiffFile(filename);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        {
            try
            {
                result = (AiffFile *)new AiffFile((char const *)arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_AiffFile, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_AiffFile__SWIG_1) {
    {
        SampleVector *arg1 = 0 ;
        double arg2 ;
        AiffFile *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: new_AiffFile(vec,samplerate);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SampleVector,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_AiffFile. Expected _p_SampleVector");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                result = (AiffFile *)new AiffFile(*arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_AiffFile, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_AiffFile) {
    {
        AiffFile *arg1 = (AiffFile *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_AiffFile(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_AiffFile. Expected _p_AiffFile");
            }
        }
        {
            try
            {
                delete arg1;
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_AiffFile_sampleRate) {
    {
        AiffFile *arg1 = (AiffFile *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: AiffFile_sampleRate(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of AiffFile_sampleRate. Expected _p_AiffFile");
            }
        }
        {
            try
            {
                result = (double)((AiffFile const *)arg1)->sampleRate();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_AiffFile_midiNoteNumber) {
    {
        AiffFile *arg1 = (AiffFile *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: AiffFile_midiNoteNumber(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of AiffFile_midiNoteNumber. Expected _p_AiffFile");
            }
        }
        {
            try
            {
                result = (double)((AiffFile const *)arg1)->midiNoteNumber();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_AiffFile_sampleFrames) {
    {
        AiffFile *arg1 = (AiffFile *) 0 ;
        unsigned long result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: AiffFile_sampleFrames(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of AiffFile_sampleFrames. Expected _p_AiffFile");
            }
        }
        {
            try
            {
                result = (unsigned long)((AiffFile const *)arg1)->numFrames();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setuv(ST(argvi++), (UV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_AiffFile_addPartial) {
    {
        AiffFile *arg1 = (AiffFile *) 0 ;
        Loris::Partial *arg2 = 0 ;
        double arg3 = (double) .001 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 3)) {
            SWIG_croak("Usage: AiffFile_addPartial(self,p,fadeTime);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of AiffFile_addPartial. Expected _p_AiffFile");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Loris__Partial,0) < 0) {
                SWIG_croak("Type error in argument 2 of AiffFile_addPartial. Expected _p_Loris__Partial");
            }
        }
        if (items > 2) {
            arg3 = (double) SvNV(ST(2));
            
        }
        {
            try
            {
                (arg1)->addPartial((Loris::Partial const &)*arg2,arg3);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_AiffFile_setMidiNoteNumber) {
    {
        AiffFile *arg1 = (AiffFile *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: AiffFile_setMidiNoteNumber(self,nn);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of AiffFile_setMidiNoteNumber. Expected _p_AiffFile");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setMidiNoteNumber(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_AiffFile_write) {
    {
        AiffFile *arg1 = (AiffFile *) 0 ;
        char *arg2 ;
        unsigned int arg3 = (unsigned int) 16 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 3)) {
            SWIG_croak("Usage: AiffFile_write(self,filename,bps);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of AiffFile_write. Expected _p_AiffFile");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (items > 2) {
            arg3 = (unsigned int) SvUV(ST(2));
        }
        {
            try
            {
                (arg1)->write((char const *)arg2,arg3);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_AiffFile__SWIG_2) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        double arg2 ;
        double arg3 = (double) .001 ;
        AiffFile *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 3)) {
            SWIG_croak("Usage: new_AiffFile(l,sampleRate,fadeTime);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_AiffFile. Expected _p_PartialList");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        if (items > 2) {
            arg3 = (double) SvNV(ST(2));
            
        }
        {
            try
            {
                result = (AiffFile *)new_AiffFile__SWIG_2(arg1,arg2,arg3);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_AiffFile, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_AiffFile) {
    dXSARGS;
    
    if (items == 1) {
        int _v;
        {
            _v = SvPOK(ST(0)) ? 1 : 0;
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_AiffFile__SWIG_0); return;
        }
    }
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_SampleVector, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = SvNIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_AiffFile__SWIG_1); return;
            }
        }
    }
    if ((items >= 2) && (items <= 3)) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = SvNIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                if (items <= 2) {
                    (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_AiffFile__SWIG_2); return;
                }
                {
                    _v = SvNIOK(ST(2)) ? 1 : 0;
                }
                if (_v) {
                    (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_AiffFile__SWIG_2); return;
                }
            }
        }
    }
    
    croak("No matching function for overloaded 'new_AiffFile'");
    XSRETURN(0);
}


XS(_wrap_AiffFile_samples) {
    {
        AiffFile *arg1 = (AiffFile *) 0 ;
        SampleVector *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: AiffFile_samples(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of AiffFile_samples. Expected _p_AiffFile");
            }
        }
        {
            try
            {
                result = (SampleVector *)AiffFile_samples(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SampleVector, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_AiffFile_channels) {
    {
        AiffFile *arg1 = (AiffFile *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: AiffFile_channels(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of AiffFile_channels. Expected _p_AiffFile");
            }
        }
        {
            try
            {
                result = (int)AiffFile_channels(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_AiffFile_addPartials) {
    {
        AiffFile *arg1 = (AiffFile *) 0 ;
        PartialList *arg2 = (PartialList *) 0 ;
        double arg3 = (double) 0.001 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 3)) {
            SWIG_croak("Usage: AiffFile_addPartials(self,l,fadeTime);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of AiffFile_addPartials. Expected _p_AiffFile");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 2 of AiffFile_addPartials. Expected _p_PartialList");
            }
        }
        if (items > 2) {
            arg3 = (double) SvNV(ST(2));
            
        }
        {
            try
            {
                AiffFile_addPartials(arg1,arg2,arg3);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_AiffFile_numMarkers) {
    {
        AiffFile *arg1 = (AiffFile *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: AiffFile_numMarkers(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of AiffFile_numMarkers. Expected _p_AiffFile");
            }
        }
        {
            try
            {
                result = (int)AiffFile_numMarkers(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_AiffFile_getMarker) {
    {
        AiffFile *arg1 = (AiffFile *) 0 ;
        int arg2 ;
        Marker *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: AiffFile_getMarker(self,i);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of AiffFile_getMarker. Expected _p_AiffFile");
            }
        }
        arg2 = (int) SvIV(ST(1));
        {
            try
            {
                {
                    Marker &_result_ref = AiffFile_getMarker(arg1,arg2);
                    result = (Marker *) &_result_ref;
                }
                
            }
            catch ( InvalidArgument & ex )
            {
                SWIG_exception(SWIG_ValueError, ex.what() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Marker, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_AiffFile_removeMarker) {
    {
        AiffFile *arg1 = (AiffFile *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: AiffFile_removeMarker(self,i);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of AiffFile_removeMarker. Expected _p_AiffFile");
            }
        }
        arg2 = (int) SvIV(ST(1));
        {
            try
            {
                AiffFile_removeMarker(arg1,arg2);
                
            }
            catch ( InvalidArgument & ex )
            {
                SWIG_exception(SWIG_ValueError, ex.what() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_AiffFile_addMarker) {
    {
        AiffFile *arg1 = (AiffFile *) 0 ;
        Marker arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: AiffFile_addMarker(self,m);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of AiffFile_addMarker. Expected _p_AiffFile");
            }
        }
        {
            Marker * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_Marker,0) < 0) {
                SWIG_croak("Type error in argument 2 of AiffFile_addMarker. Expected _p_Marker");
            }
            arg2 = *argp;
        }
        {
            try
            {
                AiffFile_addMarker(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Analyzer) {
    {
        double arg1 ;
        double arg2 = (double) 0. ;
        Analyzer *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 2)) {
            SWIG_croak("Usage: new_Analyzer(resolutionHz,windowWidthHz);");
        }
        arg1 = (double) SvNV(ST(0));
        
        if (items > 1) {
            arg2 = (double) SvNV(ST(1));
            
        }
        {
            try
            {
                result = (Analyzer *)new_Analyzer(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Analyzer, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_copy) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        Analyzer *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Analyzer_copy(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_copy. Expected _p_Analyzer");
            }
        }
        {
            try
            {
                result = (Analyzer *)Analyzer_copy(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Analyzer, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_analyze__SWIG_0) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        SampleVector *arg2 = (SampleVector *) 0 ;
        double arg3 ;
        PartialList *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: Analyzer_analyze(self,vec,srate);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_analyze. Expected _p_Analyzer");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SampleVector,0) < 0) {
                SWIG_croak("Type error in argument 2 of Analyzer_analyze. Expected _p_SampleVector");
            }
        }
        arg3 = (double) SvNV(ST(2));
        
        {
            try
            {
                result = (PartialList *)Analyzer_analyze__SWIG_0(arg1,(SampleVector const *)arg2,arg3);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_analyze__SWIG_1) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        SampleVector *arg2 = (SampleVector *) 0 ;
        double arg3 ;
        BreakpointEnvelope *arg4 = (BreakpointEnvelope *) 0 ;
        PartialList *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: Analyzer_analyze(self,vec,srate,env);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_analyze. Expected _p_Analyzer");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SampleVector,0) < 0) {
                SWIG_croak("Type error in argument 2 of Analyzer_analyze. Expected _p_SampleVector");
            }
        }
        arg3 = (double) SvNV(ST(2));
        
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_BreakpointEnvelope,0) < 0) {
                SWIG_croak("Type error in argument 4 of Analyzer_analyze. Expected _p_BreakpointEnvelope");
            }
        }
        {
            try
            {
                result = (PartialList *)Analyzer_analyze__SWIG_1(arg1,(SampleVector const *)arg2,arg3,arg4);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_analyze) {
    dXSARGS;
    
    if (items == 3) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_Analyzer, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_SampleVector, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    _v = SvNIOK(ST(2)) ? 1 : 0;
                }
                if (_v) {
                    (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_Analyzer_analyze__SWIG_0); return;
                }
            }
        }
    }
    if (items == 4) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_Analyzer, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_SampleVector, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    _v = SvNIOK(ST(2)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *tmp;
                        if (SWIG_ConvertPtr(ST(3), (void **) &tmp, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                            _v = 0;
                        } else {
                            _v = 1;
                        }
                    }
                    if (_v) {
                        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_Analyzer_analyze__SWIG_1); return;
                    }
                }
            }
        }
    }
    
    croak("No matching function for overloaded 'Analyzer_analyze'");
    XSRETURN(0);
}


XS(_wrap_Analyzer_freqResolution) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Analyzer_freqResolution(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_freqResolution. Expected _p_Analyzer");
            }
        }
        {
            try
            {
                result = (double)((Analyzer const *)arg1)->freqResolution();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_ampFloor) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Analyzer_ampFloor(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_ampFloor. Expected _p_Analyzer");
            }
        }
        {
            try
            {
                result = (double)((Analyzer const *)arg1)->ampFloor();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_windowWidth) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Analyzer_windowWidth(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_windowWidth. Expected _p_Analyzer");
            }
        }
        {
            try
            {
                result = (double)((Analyzer const *)arg1)->windowWidth();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_sidelobeLevel) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Analyzer_sidelobeLevel(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_sidelobeLevel. Expected _p_Analyzer");
            }
        }
        {
            try
            {
                result = (double)((Analyzer const *)arg1)->sidelobeLevel();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_freqFloor) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Analyzer_freqFloor(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_freqFloor. Expected _p_Analyzer");
            }
        }
        {
            try
            {
                result = (double)((Analyzer const *)arg1)->freqFloor();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_hopTime) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Analyzer_hopTime(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_hopTime. Expected _p_Analyzer");
            }
        }
        {
            try
            {
                result = (double)((Analyzer const *)arg1)->hopTime();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_freqDrift) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Analyzer_freqDrift(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_freqDrift. Expected _p_Analyzer");
            }
        }
        {
            try
            {
                result = (double)((Analyzer const *)arg1)->freqDrift();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_cropTime) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Analyzer_cropTime(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_cropTime. Expected _p_Analyzer");
            }
        }
        {
            try
            {
                result = (double)((Analyzer const *)arg1)->cropTime();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_bwRegionWidth) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Analyzer_bwRegionWidth(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_bwRegionWidth. Expected _p_Analyzer");
            }
        }
        {
            try
            {
                result = (double)((Analyzer const *)arg1)->bwRegionWidth();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_setFreqResolution) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Analyzer_setFreqResolution(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_setFreqResolution. Expected _p_Analyzer");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setFreqResolution(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_setAmpFloor) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Analyzer_setAmpFloor(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_setAmpFloor. Expected _p_Analyzer");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setAmpFloor(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_setWindowWidth) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Analyzer_setWindowWidth(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_setWindowWidth. Expected _p_Analyzer");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setWindowWidth(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_setSidelobeLevel) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Analyzer_setSidelobeLevel(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_setSidelobeLevel. Expected _p_Analyzer");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setSidelobeLevel(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_setFreqFloor) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Analyzer_setFreqFloor(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_setFreqFloor. Expected _p_Analyzer");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setFreqFloor(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_setFreqDrift) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Analyzer_setFreqDrift(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_setFreqDrift. Expected _p_Analyzer");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setFreqDrift(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_setHopTime) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Analyzer_setHopTime(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_setHopTime. Expected _p_Analyzer");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setHopTime(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_setCropTime) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Analyzer_setCropTime(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_setCropTime. Expected _p_Analyzer");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setCropTime(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Analyzer_setBwRegionWidth) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Analyzer_setBwRegionWidth(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of Analyzer_setBwRegionWidth. Expected _p_Analyzer");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setBwRegionWidth(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_Analyzer) {
    {
        Analyzer *arg1 = (Analyzer *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_Analyzer(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_Analyzer. Expected _p_Analyzer");
            }
        }
        {
            try
            {
                delete arg1;
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_BreakpointEnvelope__SWIG_0) {
    {
        BreakpointEnvelope *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_BreakpointEnvelope();");
        }
        {
            try
            {
                result = (BreakpointEnvelope *)new BreakpointEnvelope();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BreakpointEnvelope, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_BreakpointEnvelope__SWIG_1) {
    {
        double arg1 ;
        BreakpointEnvelope *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: new_BreakpointEnvelope(initialValue);");
        }
        arg1 = (double) SvNV(ST(0));
        
        {
            try
            {
                result = (BreakpointEnvelope *)new BreakpointEnvelope(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BreakpointEnvelope, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_BreakpointEnvelope) {
    dXSARGS;
    
    if (items == 0) {
        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_BreakpointEnvelope__SWIG_0); return;
    }
    if (items == 1) {
        int _v;
        {
            _v = SvNIOK(ST(0)) ? 1 : 0;
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_BreakpointEnvelope__SWIG_1); return;
        }
    }
    
    croak("No matching function for overloaded 'new_BreakpointEnvelope'");
    XSRETURN(0);
}


XS(_wrap_delete_BreakpointEnvelope) {
    {
        BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_BreakpointEnvelope(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_BreakpointEnvelope. Expected _p_BreakpointEnvelope");
            }
        }
        {
            try
            {
                delete arg1;
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_BreakpointEnvelope_copy) {
    {
        BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
        BreakpointEnvelope *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: BreakpointEnvelope_copy(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,0) < 0) {
                SWIG_croak("Type error in argument 1 of BreakpointEnvelope_copy. Expected _p_BreakpointEnvelope");
            }
        }
        {
            try
            {
                result = (BreakpointEnvelope *)BreakpointEnvelope_copy(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BreakpointEnvelope, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_BreakpointEnvelope_insertBreakpoint) {
    {
        BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
        double arg2 ;
        double arg3 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: BreakpointEnvelope_insertBreakpoint(self,time,value);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,0) < 0) {
                SWIG_croak("Type error in argument 1 of BreakpointEnvelope_insertBreakpoint. Expected _p_BreakpointEnvelope");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        arg3 = (double) SvNV(ST(2));
        
        {
            try
            {
                (arg1)->insertBreakpoint(arg2,arg3);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_BreakpointEnvelope_valueAt) {
    {
        BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
        double arg2 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: BreakpointEnvelope_valueAt(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,0) < 0) {
                SWIG_croak("Type error in argument 1 of BreakpointEnvelope_valueAt. Expected _p_BreakpointEnvelope");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                result = (double)((BreakpointEnvelope const *)arg1)->valueAt(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_BreakpointEnvelopeWithValue) {
    {
        double arg1 ;
        BreakpointEnvelope *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: BreakpointEnvelopeWithValue(initialValue);");
        }
        arg1 = (double) SvNV(ST(0));
        
        {
            try
            {
                result = (BreakpointEnvelope *)BreakpointEnvelopeWithValue(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BreakpointEnvelope, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_SampleVector) {
    {
        unsigned long arg1 = (unsigned long) 0 ;
        SampleVector *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 1)) {
            SWIG_croak("Usage: new_SampleVector(size);");
        }
        if (items > 0) {
            arg1 = (unsigned long) SvUV(ST(0));
        }
        {
            try
            {
                result = (SampleVector *)new SampleVector(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SampleVector, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_SampleVector) {
    {
        SampleVector *arg1 = (SampleVector *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_SampleVector(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SampleVector,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_SampleVector. Expected _p_SampleVector");
            }
        }
        {
            try
            {
                delete arg1;
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SampleVector_clear) {
    {
        SampleVector *arg1 = (SampleVector *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: SampleVector_clear(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SampleVector,0) < 0) {
                SWIG_croak("Type error in argument 1 of SampleVector_clear. Expected _p_SampleVector");
            }
        }
        {
            try
            {
                (arg1)->clear();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SampleVector_resize) {
    {
        SampleVector *arg1 = (SampleVector *) 0 ;
        unsigned long arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SampleVector_resize(self,size);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SampleVector,0) < 0) {
                SWIG_croak("Type error in argument 1 of SampleVector_resize. Expected _p_SampleVector");
            }
        }
        arg2 = (unsigned long) SvUV(ST(1));
        {
            try
            {
                (arg1)->resize(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SampleVector_size) {
    {
        SampleVector *arg1 = (SampleVector *) 0 ;
        unsigned long result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: SampleVector_size(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SampleVector,0) < 0) {
                SWIG_croak("Type error in argument 1 of SampleVector_size. Expected _p_SampleVector");
            }
        }
        {
            try
            {
                result = (unsigned long)(arg1)->size();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setuv(ST(argvi++), (UV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SampleVector_copy) {
    {
        SampleVector *arg1 = (SampleVector *) 0 ;
        SampleVector *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: SampleVector_copy(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SampleVector,0) < 0) {
                SWIG_croak("Type error in argument 1 of SampleVector_copy. Expected _p_SampleVector");
            }
        }
        {
            try
            {
                result = (SampleVector *)SampleVector_copy(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SampleVector, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SampleVector_getAt) {
    {
        SampleVector *arg1 = (SampleVector *) 0 ;
        unsigned long arg2 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SampleVector_getAt(self,idx);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SampleVector,0) < 0) {
                SWIG_croak("Type error in argument 1 of SampleVector_getAt. Expected _p_SampleVector");
            }
        }
        arg2 = (unsigned long) SvUV(ST(1));
        {
            try
            {
                result = (double)SampleVector_getAt(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SampleVector_setAt) {
    {
        SampleVector *arg1 = (SampleVector *) 0 ;
        unsigned long arg2 ;
        double arg3 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: SampleVector_setAt(self,idx,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SampleVector,0) < 0) {
                SWIG_croak("Type error in argument 1 of SampleVector_setAt. Expected _p_SampleVector");
            }
        }
        arg2 = (unsigned long) SvUV(ST(1));
        arg3 = (double) SvNV(ST(2));
        
        {
            try
            {
                SampleVector_setAt(arg1,arg2,arg3);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_SdifFile__SWIG_0) {
    {
        char *arg1 ;
        SdifFile *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: new_SdifFile(filename);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        {
            try
            {
                result = (SdifFile *)new SdifFile((char const *)arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SdifFile, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_SdifFile__SWIG_1) {
    {
        SdifFile *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_SdifFile();");
        }
        {
            try
            {
                result = (SdifFile *)new SdifFile();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SdifFile, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_SdifFile) {
    {
        SdifFile *arg1 = (SdifFile *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_SdifFile(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SdifFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_SdifFile. Expected _p_SdifFile");
            }
        }
        {
            try
            {
                delete arg1;
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SdifFile_write) {
    {
        SdifFile *arg1 = (SdifFile *) 0 ;
        char *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SdifFile_write(self,path);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SdifFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SdifFile_write. Expected _p_SdifFile");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            try
            {
                (arg1)->write((char const *)arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SdifFile_write1TRC) {
    {
        SdifFile *arg1 = (SdifFile *) 0 ;
        char *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SdifFile_write1TRC(self,path);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SdifFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SdifFile_write1TRC. Expected _p_SdifFile");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            try
            {
                (arg1)->write1TRC((char const *)arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_SdifFile__SWIG_2) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        SdifFile *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: new_SdifFile(l);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_SdifFile. Expected _p_PartialList");
            }
        }
        {
            try
            {
                result = (SdifFile *)new_SdifFile__SWIG_2(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SdifFile, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_SdifFile) {
    dXSARGS;
    
    if (items == 0) {
        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_SdifFile__SWIG_1); return;
    }
    if (items == 1) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_SdifFile__SWIG_2); return;
        }
    }
    if (items == 1) {
        int _v;
        {
            _v = SvPOK(ST(0)) ? 1 : 0;
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_SdifFile__SWIG_0); return;
        }
    }
    
    croak("No matching function for overloaded 'new_SdifFile'");
    XSRETURN(0);
}


XS(_wrap_SdifFile_partials) {
    {
        SdifFile *arg1 = (SdifFile *) 0 ;
        PartialList *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: SdifFile_partials(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SdifFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SdifFile_partials. Expected _p_SdifFile");
            }
        }
        {
            try
            {
                result = (PartialList *)SdifFile_partials(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SdifFile_addPartials) {
    {
        SdifFile *arg1 = (SdifFile *) 0 ;
        PartialList *arg2 = (PartialList *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SdifFile_addPartials(self,l);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SdifFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SdifFile_addPartials. Expected _p_SdifFile");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 2 of SdifFile_addPartials. Expected _p_PartialList");
            }
        }
        {
            try
            {
                SdifFile_addPartials(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SdifFile_numMarkers) {
    {
        SdifFile *arg1 = (SdifFile *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: SdifFile_numMarkers(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SdifFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SdifFile_numMarkers. Expected _p_SdifFile");
            }
        }
        {
            try
            {
                result = (int)SdifFile_numMarkers(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SdifFile_getMarker) {
    {
        SdifFile *arg1 = (SdifFile *) 0 ;
        int arg2 ;
        Marker *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SdifFile_getMarker(self,i);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SdifFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SdifFile_getMarker. Expected _p_SdifFile");
            }
        }
        arg2 = (int) SvIV(ST(1));
        {
            try
            {
                {
                    Marker &_result_ref = SdifFile_getMarker(arg1,arg2);
                    result = (Marker *) &_result_ref;
                }
                
            }
            catch ( InvalidArgument & ex )
            {
                SWIG_exception(SWIG_ValueError, ex.what() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Marker, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SdifFile_removeMarker) {
    {
        SdifFile *arg1 = (SdifFile *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SdifFile_removeMarker(self,i);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SdifFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SdifFile_removeMarker. Expected _p_SdifFile");
            }
        }
        arg2 = (int) SvIV(ST(1));
        {
            try
            {
                SdifFile_removeMarker(arg1,arg2);
                
            }
            catch ( InvalidArgument & ex )
            {
                SWIG_exception(SWIG_ValueError, ex.what() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SdifFile_addMarker) {
    {
        SdifFile *arg1 = (SdifFile *) 0 ;
        Marker arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SdifFile_addMarker(self,m);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SdifFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SdifFile_addMarker. Expected _p_SdifFile");
            }
        }
        {
            Marker * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_Marker,0) < 0) {
                SWIG_croak("Type error in argument 2 of SdifFile_addMarker. Expected _p_Marker");
            }
            arg2 = *argp;
        }
        {
            try
            {
                SdifFile_addMarker(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_SpcFile__SWIG_0) {
    {
        char *arg1 ;
        SpcFile *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: new_SpcFile(filename);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        {
            try
            {
                result = (SpcFile *)new SpcFile((char const *)arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SpcFile, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_SpcFile__SWIG_1) {
    {
        double arg1 = (double) 60 ;
        SpcFile *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 1)) {
            SWIG_croak("Usage: new_SpcFile(midiNoteNum);");
        }
        if (items > 0) {
            arg1 = (double) SvNV(ST(0));
            
        }
        {
            try
            {
                result = (SpcFile *)new SpcFile(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SpcFile, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_SpcFile) {
    {
        SpcFile *arg1 = (SpcFile *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_SpcFile(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SpcFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_SpcFile. Expected _p_SpcFile");
            }
        }
        {
            try
            {
                delete arg1;
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpcFile_sampleRate) {
    {
        SpcFile *arg1 = (SpcFile *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: SpcFile_sampleRate(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SpcFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpcFile_sampleRate. Expected _p_SpcFile");
            }
        }
        {
            try
            {
                result = (double)((SpcFile const *)arg1)->sampleRate();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpcFile_midiNoteNumber) {
    {
        SpcFile *arg1 = (SpcFile *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: SpcFile_midiNoteNumber(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SpcFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpcFile_midiNoteNumber. Expected _p_SpcFile");
            }
        }
        {
            try
            {
                result = (double)((SpcFile const *)arg1)->midiNoteNumber();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpcFile_addPartial__SWIG_0) {
    {
        SpcFile *arg1 = (SpcFile *) 0 ;
        Loris::Partial *arg2 = 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SpcFile_addPartial(self,p);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SpcFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpcFile_addPartial. Expected _p_SpcFile");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Loris__Partial,0) < 0) {
                SWIG_croak("Type error in argument 2 of SpcFile_addPartial. Expected _p_Loris__Partial");
            }
        }
        {
            try
            {
                (arg1)->addPartial((Loris::Partial const &)*arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpcFile_addPartial__SWIG_1) {
    {
        SpcFile *arg1 = (SpcFile *) 0 ;
        Loris::Partial *arg2 = 0 ;
        int arg3 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: SpcFile_addPartial(self,p,label);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SpcFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpcFile_addPartial. Expected _p_SpcFile");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Loris__Partial,0) < 0) {
                SWIG_croak("Type error in argument 2 of SpcFile_addPartial. Expected _p_Loris__Partial");
            }
        }
        arg3 = (int) SvIV(ST(2));
        {
            try
            {
                (arg1)->addPartial((Loris::Partial const &)*arg2,arg3);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpcFile_addPartial) {
    dXSARGS;
    
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_SpcFile, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_Loris__Partial, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_SpcFile_addPartial__SWIG_0); return;
            }
        }
    }
    if (items == 3) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_SpcFile, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_Loris__Partial, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    _v = SvIOK(ST(2)) ? 1 : 0;
                }
                if (_v) {
                    (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_SpcFile_addPartial__SWIG_1); return;
                }
            }
        }
    }
    
    croak("No matching function for overloaded 'SpcFile_addPartial'");
    XSRETURN(0);
}


XS(_wrap_SpcFile_setMidiNoteNumber) {
    {
        SpcFile *arg1 = (SpcFile *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SpcFile_setMidiNoteNumber(self,nn);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SpcFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpcFile_setMidiNoteNumber. Expected _p_SpcFile");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setMidiNoteNumber(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpcFile_setSampleRate) {
    {
        SpcFile *arg1 = (SpcFile *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SpcFile_setSampleRate(self,rate);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SpcFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpcFile_setSampleRate. Expected _p_SpcFile");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setSampleRate(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpcFile_write) {
    {
        SpcFile *arg1 = (SpcFile *) 0 ;
        char *arg2 ;
        bool arg3 = (bool) true ;
        double arg4 = (double) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 4)) {
            SWIG_croak("Usage: SpcFile_write(self,filename,enhanced,endApproachTime);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SpcFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpcFile_write. Expected _p_SpcFile");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (items > 2) {
            arg3 = (bool) SvIV(ST(2));
        }
        if (items > 3) {
            arg4 = (double) SvNV(ST(3));
            
        }
        {
            try
            {
                (arg1)->write((char const *)arg2,arg3,arg4);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_SpcFile__SWIG_2) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        double arg2 = (double) 60 ;
        SpcFile *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 2)) {
            SWIG_croak("Usage: new_SpcFile(l,midiNoteNum);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_SpcFile. Expected _p_PartialList");
            }
        }
        if (items > 1) {
            arg2 = (double) SvNV(ST(1));
            
        }
        {
            try
            {
                result = (SpcFile *)new_SpcFile__SWIG_2(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SpcFile, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_SpcFile) {
    dXSARGS;
    
    if ((items >= 0) && (items <= 1)) {
        int _v;
        if (items <= 0) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_SpcFile__SWIG_1); return;
        }
        {
            _v = SvNIOK(ST(0)) ? 1 : 0;
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_SpcFile__SWIG_1); return;
        }
    }
    if ((items >= 1) && (items <= 2)) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            if (items <= 1) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_SpcFile__SWIG_2); return;
            }
            {
                _v = SvNIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_SpcFile__SWIG_2); return;
            }
        }
    }
    if (items == 1) {
        int _v;
        {
            _v = SvPOK(ST(0)) ? 1 : 0;
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_SpcFile__SWIG_0); return;
        }
    }
    
    croak("No matching function for overloaded 'new_SpcFile'");
    XSRETURN(0);
}


XS(_wrap_SpcFile_partials) {
    {
        SpcFile *arg1 = (SpcFile *) 0 ;
        PartialList *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: SpcFile_partials(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SpcFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpcFile_partials. Expected _p_SpcFile");
            }
        }
        {
            try
            {
                result = (PartialList *)SpcFile_partials(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpcFile_addPartials) {
    {
        SpcFile *arg1 = (SpcFile *) 0 ;
        PartialList *arg2 = (PartialList *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SpcFile_addPartials(self,l);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SpcFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpcFile_addPartials. Expected _p_SpcFile");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 2 of SpcFile_addPartials. Expected _p_PartialList");
            }
        }
        {
            try
            {
                SpcFile_addPartials(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpcFile_numMarkers) {
    {
        SpcFile *arg1 = (SpcFile *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: SpcFile_numMarkers(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SpcFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpcFile_numMarkers. Expected _p_SpcFile");
            }
        }
        {
            try
            {
                result = (int)SpcFile_numMarkers(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpcFile_getMarker) {
    {
        SpcFile *arg1 = (SpcFile *) 0 ;
        int arg2 ;
        Marker *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SpcFile_getMarker(self,i);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SpcFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpcFile_getMarker. Expected _p_SpcFile");
            }
        }
        arg2 = (int) SvIV(ST(1));
        {
            try
            {
                {
                    Marker &_result_ref = SpcFile_getMarker(arg1,arg2);
                    result = (Marker *) &_result_ref;
                }
                
            }
            catch ( InvalidArgument & ex )
            {
                SWIG_exception(SWIG_ValueError, ex.what() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Marker, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpcFile_removeMarker) {
    {
        SpcFile *arg1 = (SpcFile *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SpcFile_removeMarker(self,i);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SpcFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpcFile_removeMarker. Expected _p_SpcFile");
            }
        }
        arg2 = (int) SvIV(ST(1));
        {
            try
            {
                SpcFile_removeMarker(arg1,arg2);
                
            }
            catch ( InvalidArgument & ex )
            {
                SWIG_exception(SWIG_ValueError, ex.what() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpcFile_addMarker) {
    {
        SpcFile *arg1 = (SpcFile *) 0 ;
        Marker arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SpcFile_addMarker(self,m);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SpcFile,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpcFile_addMarker. Expected _p_SpcFile");
            }
        }
        {
            Marker * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_Marker,0) < 0) {
                SWIG_croak("Type error in argument 2 of SpcFile_addMarker. Expected _p_Marker");
            }
            arg2 = *argp;
        }
        {
            try
            {
                SpcFile_addMarker(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_NewPlistIterator_atEnd) {
    {
        NewPlistIterator *arg1 = (NewPlistIterator *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: NewPlistIterator_atEnd(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_NewPlistIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of NewPlistIterator_atEnd. Expected _p_NewPlistIterator");
            }
        }
        {
            try
            {
                result = (bool)(arg1)->atEnd();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_NewPlistIterator_next) {
    {
        NewPlistIterator *arg1 = (NewPlistIterator *) 0 ;
        Partial *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: NewPlistIterator_next(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_NewPlistIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of NewPlistIterator_next. Expected _p_NewPlistIterator");
            }
        }
        {
            char * err;
            clear_exception();
            result = (Partial *)(arg1)->next();
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
                
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Partial, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_NewPlistIterator_partial) {
    {
        NewPlistIterator *arg1 = (NewPlistIterator *) 0 ;
        Partial *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: NewPlistIterator_partial(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_NewPlistIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of NewPlistIterator_partial. Expected _p_NewPlistIterator");
            }
        }
        {
            char * err;
            clear_exception();
            result = (Partial *)NewPlistIterator_partial(arg1);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Partial, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_NewPartialIterator_atEnd) {
    {
        NewPartialIterator *arg1 = (NewPartialIterator *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: NewPartialIterator_atEnd(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_NewPartialIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of NewPartialIterator_atEnd. Expected _p_NewPartialIterator");
            }
        }
        {
            try
            {
                result = (bool)(arg1)->atEnd();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_NewPartialIterator_hasNext) {
    {
        NewPartialIterator *arg1 = (NewPartialIterator *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: NewPartialIterator_hasNext(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_NewPartialIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of NewPartialIterator_hasNext. Expected _p_NewPartialIterator");
            }
        }
        {
            try
            {
                result = (bool)(arg1)->hasNext();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_NewPartialIterator_next) {
    {
        NewPartialIterator *arg1 = (NewPartialIterator *) 0 ;
        BreakpointPosition *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: NewPartialIterator_next(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_NewPartialIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of NewPartialIterator_next. Expected _p_NewPartialIterator");
            }
        }
        {
            char * err;
            clear_exception();
            result = (BreakpointPosition *)(arg1)->next();
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
                
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BreakpointPosition, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_PartialList__SWIG_0) {
    {
        PartialList *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_PartialList();");
        }
        {
            try
            {
                result = (PartialList *)new PartialList();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_PartialList__SWIG_1) {
    {
        PartialList *arg1 = 0 ;
        PartialList *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: new_PartialList(rhs);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_PartialList. Expected _p_PartialList");
            }
        }
        {
            try
            {
                result = (PartialList *)new PartialList((PartialList const &)*arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_PartialList) {
    dXSARGS;
    
    if (items == 0) {
        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_PartialList__SWIG_0); return;
    }
    if (items == 1) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_PartialList__SWIG_1); return;
        }
    }
    
    croak("No matching function for overloaded 'new_PartialList'");
    XSRETURN(0);
}


XS(_wrap_delete_PartialList) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_PartialList(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_PartialList. Expected _p_PartialList");
            }
        }
        {
            try
            {
                delete arg1;
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialList_clear) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialList_clear(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialList_clear. Expected _p_PartialList");
            }
        }
        {
            try
            {
                (arg1)->clear();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialList_size) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        unsigned long result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialList_size(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialList_size. Expected _p_PartialList");
            }
        }
        {
            try
            {
                result = (unsigned long)(arg1)->size();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setuv(ST(argvi++), (UV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialList_timeSpan) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        double *arg2 = (double *) 0 ;
        double *arg3 = (double *) 0 ;
        double temp2 ;
        double temp3 ;
        int argvi = 0;
        dXSARGS;
        
        arg2 = &temp2;
        arg3 = &temp3;
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialList_timeSpan(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialList_timeSpan. Expected _p_PartialList");
            }
        }
        {
            try
            {
                PartialList_timeSpan(arg1,arg2,arg3);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        {
            if (argvi >= items) {
                EXTEND(sp,1);
            }
            ST(argvi) = sv_newmortal();
            sv_setnv(ST(argvi),(double) *(arg2));
            argvi++;
        }
        {
            if (argvi >= items) {
                EXTEND(sp,1);
            }
            ST(argvi) = sv_newmortal();
            sv_setnv(ST(argvi),(double) *(arg3));
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialList_iterator) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        NewPlistIterator *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialList_iterator(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialList_iterator. Expected _p_PartialList");
            }
        }
        {
            try
            {
                result = (NewPlistIterator *)PartialList_iterator(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_NewPlistIterator, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialList_append) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        Partial *arg2 = (Partial *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: PartialList_append(self,partial);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialList_append. Expected _p_PartialList");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 2 of PartialList_append. Expected _p_Partial");
            }
        }
        {
            try
            {
                PartialList_append(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialList_insert__SWIG_0) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        NewPlistIterator *arg2 = (NewPlistIterator *) 0 ;
        Partial *arg3 = (Partial *) 0 ;
        NewPlistIterator *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: PartialList_insert(self,position,partial);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialList_insert. Expected _p_PartialList");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_NewPlistIterator,0) < 0) {
                SWIG_croak("Type error in argument 2 of PartialList_insert. Expected _p_NewPlistIterator");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 3 of PartialList_insert. Expected _p_Partial");
            }
        }
        {
            try
            {
                result = (NewPlistIterator *)PartialList_insert__SWIG_0(arg1,arg2,arg3);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_NewPlistIterator, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialList_erase__SWIG_0) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        Partial *arg2 = (Partial *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: PartialList_erase(self,partial);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialList_erase. Expected _p_PartialList");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 2 of PartialList_erase. Expected _p_Partial");
            }
        }
        {
            char * err;
            clear_exception();
            PartialList_erase__SWIG_0(arg1,arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialList_splice__SWIG_0) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        PartialList *arg2 = (PartialList *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: PartialList_splice(self,other);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialList_splice. Expected _p_PartialList");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 2 of PartialList_splice. Expected _p_PartialList");
            }
        }
        {
            try
            {
                PartialList_splice__SWIG_0(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialList_begin) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        PartialListIterator result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialList_begin(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialList_begin. Expected _p_PartialList");
            }
        }
        {
            try
            {
                result = (arg1)->begin();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        {
            PartialListIterator * resultobj = new PartialListIterator((PartialListIterator &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialListIterator, SWIG_SHADOW|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialList_end) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        PartialListIterator result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialList_end(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialList_end. Expected _p_PartialList");
            }
        }
        {
            try
            {
                result = (arg1)->end();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        {
            PartialListIterator * resultobj = new PartialListIterator((PartialListIterator &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialListIterator, SWIG_SHADOW|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialList_insert__SWIG_1) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        PartialListIterator arg2 ;
        Partial *arg3 = 0 ;
        PartialListIterator result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: PartialList_insert(self,position,partial);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialList_insert. Expected _p_PartialList");
            }
        }
        {
            PartialListIterator * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_PartialListIterator,0) < 0) {
                SWIG_croak("Type error in argument 2 of PartialList_insert. Expected _p_PartialListIterator");
            }
            arg2 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 3 of PartialList_insert. Expected _p_Partial");
            }
        }
        {
            try
            {
                result = (arg1)->insert(arg2,(Partial const &)*arg3);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        {
            PartialListIterator * resultobj = new PartialListIterator((PartialListIterator &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialListIterator, SWIG_SHADOW|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialList_erase__SWIG_1) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        PartialListIterator arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: PartialList_erase(self,position);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialList_erase. Expected _p_PartialList");
            }
        }
        {
            PartialListIterator * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_PartialListIterator,0) < 0) {
                SWIG_croak("Type error in argument 2 of PartialList_erase. Expected _p_PartialListIterator");
            }
            arg2 = *argp;
        }
        {
            char * err;
            clear_exception();
            (arg1)->erase(arg2);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialList_erase) {
    dXSARGS;
    
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_Partial, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_PartialList_erase__SWIG_0); return;
            }
        }
    }
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_PartialListIterator, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_PartialList_erase__SWIG_1); return;
            }
        }
    }
    
    croak("No matching function for overloaded 'PartialList_erase'");
    XSRETURN(0);
}


XS(_wrap_PartialList_splice__SWIG_1) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        PartialListIterator arg2 ;
        PartialList *arg3 = 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: PartialList_splice(self,position,list);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialList_splice. Expected _p_PartialList");
            }
        }
        {
            PartialListIterator * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_PartialListIterator,0) < 0) {
                SWIG_croak("Type error in argument 2 of PartialList_splice. Expected _p_PartialListIterator");
            }
            arg2 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 3 of PartialList_splice. Expected _p_PartialList");
            }
        }
        {
            try
            {
                (arg1)->splice(arg2,*arg3);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialList_splice) {
    dXSARGS;
    
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_PartialList_splice__SWIG_0); return;
            }
        }
    }
    if (items == 3) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_PartialListIterator, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *tmp;
                    if (SWIG_ConvertPtr(ST(2), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                        _v = 0;
                    } else {
                        _v = 1;
                    }
                }
                if (_v) {
                    (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_PartialList_splice__SWIG_1); return;
                }
            }
        }
    }
    
    croak("No matching function for overloaded 'PartialList_splice'");
    XSRETURN(0);
}


XS(_wrap_PartialList_insert__SWIG_2) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        Partial *arg2 = 0 ;
        PartialListIterator result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: PartialList_insert(self,partial);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialList_insert. Expected _p_PartialList");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 2 of PartialList_insert. Expected _p_Partial");
            }
        }
        {
            try
            {
                result = PartialList_insert__SWIG_2(arg1,(Partial const &)*arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        {
            PartialListIterator * resultobj = new PartialListIterator((PartialListIterator &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialListIterator, SWIG_SHADOW|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialList_insert) {
    dXSARGS;
    
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_Partial, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_PartialList_insert__SWIG_2); return;
            }
        }
    }
    if (items == 3) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_PartialListIterator, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *tmp;
                    if (SWIG_ConvertPtr(ST(2), (void **) &tmp, SWIGTYPE_p_Partial, 0) == -1) {
                        _v = 0;
                    } else {
                        _v = 1;
                    }
                }
                if (_v) {
                    (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_PartialList_insert__SWIG_1); return;
                }
            }
        }
    }
    if (items == 3) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_NewPlistIterator, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *tmp;
                    if (SWIG_ConvertPtr(ST(2), (void **) &tmp, SWIGTYPE_p_Partial, 0) == -1) {
                        _v = 0;
                    } else {
                        _v = 1;
                    }
                }
                if (_v) {
                    (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_PartialList_insert__SWIG_0); return;
                }
            }
        }
    }
    
    croak("No matching function for overloaded 'PartialList_insert'");
    XSRETURN(0);
}


XS(_wrap_PartialList_copy) {
    {
        PartialList *arg1 = (PartialList *) 0 ;
        PartialList *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialList_copy(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialList_copy. Expected _p_PartialList");
            }
        }
        {
            try
            {
                result = (PartialList *)PartialList_copy(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Partial__SWIG_0) {
    {
        Partial *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_Partial();");
        }
        {
            try
            {
                result = (Partial *)new Partial();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Partial, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Partial__SWIG_1) {
    {
        Partial *arg1 = 0 ;
        Partial *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: new_Partial(Partial const &);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_Partial. Expected _p_Partial");
            }
        }
        {
            try
            {
                result = (Partial *)new Partial((Partial const &)*arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Partial, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Partial) {
    dXSARGS;
    
    if (items == 0) {
        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_Partial__SWIG_0); return;
    }
    if (items == 1) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_Partial, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_Partial__SWIG_1); return;
        }
    }
    
    croak("No matching function for overloaded 'new_Partial'");
    XSRETURN(0);
}


XS(_wrap_delete_Partial) {
    {
        Partial *arg1 = (Partial *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_Partial(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_Partial. Expected _p_Partial");
            }
        }
        {
            try
            {
                delete arg1;
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_label) {
    {
        Partial *arg1 = (Partial *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Partial_label(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_label. Expected _p_Partial");
            }
        }
        {
            try
            {
                result = (int)(arg1)->label();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_initialPhase) {
    {
        Partial *arg1 = (Partial *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Partial_initialPhase(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_initialPhase. Expected _p_Partial");
            }
        }
        {
            try
            {
                result = (double)(arg1)->initialPhase();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_startTime) {
    {
        Partial *arg1 = (Partial *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Partial_startTime(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_startTime. Expected _p_Partial");
            }
        }
        {
            try
            {
                result = (double)(arg1)->startTime();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_endTime) {
    {
        Partial *arg1 = (Partial *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Partial_endTime(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_endTime. Expected _p_Partial");
            }
        }
        {
            try
            {
                result = (double)(arg1)->endTime();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_duration) {
    {
        Partial *arg1 = (Partial *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Partial_duration(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_duration. Expected _p_Partial");
            }
        }
        {
            try
            {
                result = (double)(arg1)->duration();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_numBreakpoints) {
    {
        Partial *arg1 = (Partial *) 0 ;
        long result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Partial_numBreakpoints(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_numBreakpoints. Expected _p_Partial");
            }
        }
        {
            try
            {
                result = (long)(arg1)->numBreakpoints();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_setLabel) {
    {
        Partial *arg1 = (Partial *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Partial_setLabel(self,l);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_setLabel. Expected _p_Partial");
            }
        }
        arg2 = (int) SvIV(ST(1));
        {
            try
            {
                (arg1)->setLabel(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_frequencyAt) {
    {
        Partial *arg1 = (Partial *) 0 ;
        double arg2 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Partial_frequencyAt(self,time);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_frequencyAt. Expected _p_Partial");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                result = (double)(arg1)->frequencyAt(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_amplitudeAt) {
    {
        Partial *arg1 = (Partial *) 0 ;
        double arg2 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Partial_amplitudeAt(self,time);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_amplitudeAt. Expected _p_Partial");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                result = (double)(arg1)->amplitudeAt(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_bandwidthAt) {
    {
        Partial *arg1 = (Partial *) 0 ;
        double arg2 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Partial_bandwidthAt(self,time);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_bandwidthAt. Expected _p_Partial");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                result = (double)(arg1)->bandwidthAt(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_phaseAt) {
    {
        Partial *arg1 = (Partial *) 0 ;
        double arg2 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Partial_phaseAt(self,time);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_phaseAt. Expected _p_Partial");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                result = (double)(arg1)->phaseAt(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_iterator) {
    {
        Partial *arg1 = (Partial *) 0 ;
        NewPartialIterator *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Partial_iterator(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_iterator. Expected _p_Partial");
            }
        }
        {
            try
            {
                result = (NewPartialIterator *)Partial_iterator(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_NewPartialIterator, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_erase__SWIG_0) {
    {
        Partial *arg1 = (Partial *) 0 ;
        BreakpointPosition *arg2 = (BreakpointPosition *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Partial_erase(self,pos);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_erase. Expected _p_Partial");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_BreakpointPosition,0) < 0) {
                SWIG_croak("Type error in argument 2 of Partial_erase. Expected _p_BreakpointPosition");
            }
        }
        {
            try
            {
                Partial_erase__SWIG_0(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_begin) {
    {
        Partial *arg1 = (Partial *) 0 ;
        PartialIterator result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Partial_begin(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_begin. Expected _p_Partial");
            }
        }
        {
            try
            {
                result = (arg1)->begin();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        {
            PartialIterator * resultobj = new PartialIterator((PartialIterator &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialIterator, SWIG_SHADOW|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_end) {
    {
        Partial *arg1 = (Partial *) 0 ;
        PartialIterator result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Partial_end(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_end. Expected _p_Partial");
            }
        }
        {
            try
            {
                result = (arg1)->end();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        {
            PartialIterator * resultobj = new PartialIterator((PartialIterator &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialIterator, SWIG_SHADOW|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_erase__SWIG_1) {
    {
        Partial *arg1 = (Partial *) 0 ;
        PartialIterator *arg2 = 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Partial_erase(self,pos);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_erase. Expected _p_Partial");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialIterator,0) < 0) {
                SWIG_croak("Type error in argument 2 of Partial_erase. Expected _p_PartialIterator");
            }
        }
        {
            try
            {
                (arg1)->erase(*arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_erase) {
    dXSARGS;
    
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_Partial, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_BreakpointPosition, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_Partial_erase__SWIG_0); return;
            }
        }
    }
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_Partial, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_PartialIterator, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_Partial_erase__SWIG_1); return;
            }
        }
    }
    
    croak("No matching function for overloaded 'Partial_erase'");
    XSRETURN(0);
}


XS(_wrap_Partial_insert) {
    {
        Partial *arg1 = (Partial *) 0 ;
        double arg2 ;
        Breakpoint *arg3 = 0 ;
        PartialIterator result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: Partial_insert(self,time,bp);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_insert. Expected _p_Partial");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_Breakpoint,0) < 0) {
                SWIG_croak("Type error in argument 3 of Partial_insert. Expected _p_Breakpoint");
            }
        }
        {
            try
            {
                result = (arg1)->insert(arg2,(Breakpoint const &)*arg3);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        {
            PartialIterator * resultobj = new PartialIterator((PartialIterator &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialIterator, SWIG_SHADOW|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_findAfter) {
    {
        Partial *arg1 = (Partial *) 0 ;
        double arg2 ;
        PartialIterator result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Partial_findAfter(self,time);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_findAfter. Expected _p_Partial");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                result = (arg1)->findAfter(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        {
            PartialIterator * resultobj = new PartialIterator((PartialIterator &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialIterator, SWIG_SHADOW|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_findNearest) {
    {
        Partial *arg1 = (Partial *) 0 ;
        double arg2 ;
        PartialIterator result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Partial_findNearest(self,time);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_findNearest. Expected _p_Partial");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                result = (arg1)->findNearest(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        {
            PartialIterator * resultobj = new PartialIterator((PartialIterator &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialIterator, SWIG_SHADOW|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_copy) {
    {
        Partial *arg1 = (Partial *) 0 ;
        Partial *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Partial_copy(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_copy. Expected _p_Partial");
            }
        }
        {
            try
            {
                result = (Partial *)Partial_copy(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Partial, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Partial_equals) {
    {
        Partial *arg1 = (Partial *) 0 ;
        Partial *arg2 = (Partial *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Partial_equals(self,other);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 1 of Partial_equals. Expected _p_Partial");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Partial,0) < 0) {
                SWIG_croak("Type error in argument 2 of Partial_equals. Expected _p_Partial");
            }
        }
        {
            try
            {
                result = (int)Partial_equals(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Breakpoint__SWIG_0) {
    {
        double arg1 ;
        double arg2 ;
        double arg3 ;
        double arg4 = (double) 0. ;
        Breakpoint *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 4)) {
            SWIG_croak("Usage: new_Breakpoint(f,a,b,p);");
        }
        arg1 = (double) SvNV(ST(0));
        
        arg2 = (double) SvNV(ST(1));
        
        arg3 = (double) SvNV(ST(2));
        
        if (items > 3) {
            arg4 = (double) SvNV(ST(3));
            
        }
        {
            try
            {
                result = (Breakpoint *)new Breakpoint(arg1,arg2,arg3,arg4);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Breakpoint, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Breakpoint__SWIG_1) {
    {
        Breakpoint *arg1 = 0 ;
        Breakpoint *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: new_Breakpoint(rhs);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_Breakpoint. Expected _p_Breakpoint");
            }
        }
        {
            try
            {
                result = (Breakpoint *)new Breakpoint((Breakpoint const &)*arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Breakpoint, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Breakpoint) {
    dXSARGS;
    
    if (items == 1) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_Breakpoint, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_Breakpoint__SWIG_1); return;
        }
    }
    if ((items >= 3) && (items <= 4)) {
        int _v;
        {
            _v = SvNIOK(ST(0)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = SvNIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = SvNIOK(ST(2)) ? 1 : 0;
                }
                if (_v) {
                    if (items <= 3) {
                        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_Breakpoint__SWIG_0); return;
                    }
                    {
                        _v = SvNIOK(ST(3)) ? 1 : 0;
                    }
                    if (_v) {
                        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_Breakpoint__SWIG_0); return;
                    }
                }
            }
        }
    }
    
    croak("No matching function for overloaded 'new_Breakpoint'");
    XSRETURN(0);
}


XS(_wrap_delete_Breakpoint) {
    {
        Breakpoint *arg1 = (Breakpoint *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_Breakpoint(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_Breakpoint. Expected _p_Breakpoint");
            }
        }
        {
            try
            {
                delete arg1;
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Breakpoint_frequency) {
    {
        Breakpoint *arg1 = (Breakpoint *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Breakpoint_frequency(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint,0) < 0) {
                SWIG_croak("Type error in argument 1 of Breakpoint_frequency. Expected _p_Breakpoint");
            }
        }
        {
            try
            {
                result = (double)(arg1)->frequency();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Breakpoint_amplitude) {
    {
        Breakpoint *arg1 = (Breakpoint *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Breakpoint_amplitude(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint,0) < 0) {
                SWIG_croak("Type error in argument 1 of Breakpoint_amplitude. Expected _p_Breakpoint");
            }
        }
        {
            try
            {
                result = (double)(arg1)->amplitude();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Breakpoint_bandwidth) {
    {
        Breakpoint *arg1 = (Breakpoint *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Breakpoint_bandwidth(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint,0) < 0) {
                SWIG_croak("Type error in argument 1 of Breakpoint_bandwidth. Expected _p_Breakpoint");
            }
        }
        {
            try
            {
                result = (double)(arg1)->bandwidth();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Breakpoint_phase) {
    {
        Breakpoint *arg1 = (Breakpoint *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Breakpoint_phase(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint,0) < 0) {
                SWIG_croak("Type error in argument 1 of Breakpoint_phase. Expected _p_Breakpoint");
            }
        }
        {
            try
            {
                result = (double)(arg1)->phase();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Breakpoint_setFrequency) {
    {
        Breakpoint *arg1 = (Breakpoint *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Breakpoint_setFrequency(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint,0) < 0) {
                SWIG_croak("Type error in argument 1 of Breakpoint_setFrequency. Expected _p_Breakpoint");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setFrequency(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Breakpoint_setAmplitude) {
    {
        Breakpoint *arg1 = (Breakpoint *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Breakpoint_setAmplitude(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint,0) < 0) {
                SWIG_croak("Type error in argument 1 of Breakpoint_setAmplitude. Expected _p_Breakpoint");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setAmplitude(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Breakpoint_setBandwidth) {
    {
        Breakpoint *arg1 = (Breakpoint *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Breakpoint_setBandwidth(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint,0) < 0) {
                SWIG_croak("Type error in argument 1 of Breakpoint_setBandwidth. Expected _p_Breakpoint");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setBandwidth(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Breakpoint_setPhase) {
    {
        Breakpoint *arg1 = (Breakpoint *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Breakpoint_setPhase(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint,0) < 0) {
                SWIG_croak("Type error in argument 1 of Breakpoint_setPhase. Expected _p_Breakpoint");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                (arg1)->setPhase(arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Breakpoint_copy) {
    {
        Breakpoint *arg1 = (Breakpoint *) 0 ;
        Breakpoint *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Breakpoint_copy(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint,0) < 0) {
                SWIG_croak("Type error in argument 1 of Breakpoint_copy. Expected _p_Breakpoint");
            }
        }
        {
            try
            {
                result = (Breakpoint *)Breakpoint_copy(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Breakpoint, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Breakpoint_equals) {
    {
        Breakpoint *arg1 = (Breakpoint *) 0 ;
        Breakpoint *arg2 = (Breakpoint *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Breakpoint_equals(self,other);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint,0) < 0) {
                SWIG_croak("Type error in argument 1 of Breakpoint_equals. Expected _p_Breakpoint");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Breakpoint,0) < 0) {
                SWIG_croak("Type error in argument 2 of Breakpoint_equals. Expected _p_Breakpoint");
            }
        }
        {
            try
            {
                result = (int)Breakpoint_equals(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_BreakpointPosition_time) {
    {
        BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: BreakpointPosition_time(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointPosition,0) < 0) {
                SWIG_croak("Type error in argument 1 of BreakpointPosition_time. Expected _p_BreakpointPosition");
            }
        }
        {
            try
            {
                result = (double)BreakpointPosition_time(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_BreakpointPosition_breakpoint) {
    {
        BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
        Breakpoint *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: BreakpointPosition_breakpoint(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointPosition,0) < 0) {
                SWIG_croak("Type error in argument 1 of BreakpointPosition_breakpoint. Expected _p_BreakpointPosition");
            }
        }
        {
            try
            {
                result = (Breakpoint *)BreakpointPosition_breakpoint(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Breakpoint, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_BreakpointPosition_frequency) {
    {
        BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: BreakpointPosition_frequency(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointPosition,0) < 0) {
                SWIG_croak("Type error in argument 1 of BreakpointPosition_frequency. Expected _p_BreakpointPosition");
            }
        }
        {
            try
            {
                result = (double)BreakpointPosition_frequency(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_BreakpointPosition_amplitude) {
    {
        BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: BreakpointPosition_amplitude(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointPosition,0) < 0) {
                SWIG_croak("Type error in argument 1 of BreakpointPosition_amplitude. Expected _p_BreakpointPosition");
            }
        }
        {
            try
            {
                result = (double)BreakpointPosition_amplitude(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_BreakpointPosition_bandwidth) {
    {
        BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: BreakpointPosition_bandwidth(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointPosition,0) < 0) {
                SWIG_croak("Type error in argument 1 of BreakpointPosition_bandwidth. Expected _p_BreakpointPosition");
            }
        }
        {
            try
            {
                result = (double)BreakpointPosition_bandwidth(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_BreakpointPosition_phase) {
    {
        BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: BreakpointPosition_phase(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointPosition,0) < 0) {
                SWIG_croak("Type error in argument 1 of BreakpointPosition_phase. Expected _p_BreakpointPosition");
            }
        }
        {
            try
            {
                result = (double)BreakpointPosition_phase(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_BreakpointPosition_setFrequency) {
    {
        BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: BreakpointPosition_setFrequency(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointPosition,0) < 0) {
                SWIG_croak("Type error in argument 1 of BreakpointPosition_setFrequency. Expected _p_BreakpointPosition");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                BreakpointPosition_setFrequency(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_BreakpointPosition_setAmplitude) {
    {
        BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: BreakpointPosition_setAmplitude(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointPosition,0) < 0) {
                SWIG_croak("Type error in argument 1 of BreakpointPosition_setAmplitude. Expected _p_BreakpointPosition");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                BreakpointPosition_setAmplitude(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_BreakpointPosition_setBandwidth) {
    {
        BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: BreakpointPosition_setBandwidth(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointPosition,0) < 0) {
                SWIG_croak("Type error in argument 1 of BreakpointPosition_setBandwidth. Expected _p_BreakpointPosition");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                BreakpointPosition_setBandwidth(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_BreakpointPosition_setPhase) {
    {
        BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: BreakpointPosition_setPhase(self,x);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointPosition,0) < 0) {
                SWIG_croak("Type error in argument 1 of BreakpointPosition_setPhase. Expected _p_BreakpointPosition");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        {
            try
            {
                BreakpointPosition_setPhase(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialIterator_time) {
    {
        PartialIterator *arg1 = (PartialIterator *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialIterator_time(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialIterator_time. Expected _p_PartialIterator");
            }
        }
        {
            try
            {
                result = (double)((PartialIterator const *)arg1)->time();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialIterator_breakpoint) {
    {
        PartialIterator *arg1 = (PartialIterator *) 0 ;
        Breakpoint *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialIterator_breakpoint(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialIterator_breakpoint. Expected _p_PartialIterator");
            }
        }
        {
            try
            {
                result = (Breakpoint *)PartialIterator_breakpoint(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Breakpoint, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialIterator_copy) {
    {
        PartialIterator *arg1 = (PartialIterator *) 0 ;
        PartialIterator *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialIterator_copy(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialIterator_copy. Expected _p_PartialIterator");
            }
        }
        {
            try
            {
                result = (PartialIterator *)PartialIterator_copy(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialIterator_next) {
    {
        PartialIterator *arg1 = (PartialIterator *) 0 ;
        PartialIterator *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialIterator_next(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialIterator_next. Expected _p_PartialIterator");
            }
        }
        {
            char * err;
            clear_exception();
            result = (PartialIterator *)PartialIterator_next(arg1);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
                
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialIterator_prev) {
    {
        PartialIterator *arg1 = (PartialIterator *) 0 ;
        PartialIterator *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialIterator_prev(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialIterator_prev. Expected _p_PartialIterator");
            }
        }
        {
            try
            {
                result = (PartialIterator *)PartialIterator_prev(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialIterator_equals) {
    {
        PartialIterator *arg1 = (PartialIterator *) 0 ;
        PartialIterator *arg2 = (PartialIterator *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: PartialIterator_equals(self,other);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialIterator_equals. Expected _p_PartialIterator");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialIterator,0) < 0) {
                SWIG_croak("Type error in argument 2 of PartialIterator_equals. Expected _p_PartialIterator");
            }
        }
        {
            try
            {
                result = (int)PartialIterator_equals(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialIterator_isInRange) {
    {
        PartialIterator *arg1 = (PartialIterator *) 0 ;
        PartialIterator *arg2 = (PartialIterator *) 0 ;
        PartialIterator *arg3 = (PartialIterator *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: PartialIterator_isInRange(self,begin,end);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialIterator_isInRange. Expected _p_PartialIterator");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialIterator,0) < 0) {
                SWIG_croak("Type error in argument 2 of PartialIterator_isInRange. Expected _p_PartialIterator");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_PartialIterator,0) < 0) {
                SWIG_croak("Type error in argument 3 of PartialIterator_isInRange. Expected _p_PartialIterator");
            }
        }
        {
            try
            {
                result = (int)PartialIterator_isInRange(arg1,(PartialIterator const *)arg2,(PartialIterator const *)arg3);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_PartialIterator) {
    {
        PartialIterator *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_PartialIterator();");
        }
        {
            try
            {
                result = (PartialIterator *)new PartialIterator();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_PartialIterator) {
    {
        PartialIterator *arg1 = (PartialIterator *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_PartialIterator(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_PartialIterator. Expected _p_PartialIterator");
            }
        }
        {
            try
            {
                delete arg1;
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialListIterator_copy) {
    {
        PartialListIterator *arg1 = (PartialListIterator *) 0 ;
        PartialListIterator *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialListIterator_copy(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialListIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialListIterator_copy. Expected _p_PartialListIterator");
            }
        }
        {
            try
            {
                result = (PartialListIterator *)PartialListIterator_copy(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialListIterator, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialListIterator_next) {
    {
        PartialListIterator *arg1 = (PartialListIterator *) 0 ;
        PartialListIterator *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialListIterator_next(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialListIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialListIterator_next. Expected _p_PartialListIterator");
            }
        }
        {
            char * err;
            clear_exception();
            result = (PartialListIterator *)PartialListIterator_next(arg1);
            
            if ((err = check_exception()))
            {
                SWIG_exception( SWIG_ValueError, err );
                
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialListIterator, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialListIterator_prev) {
    {
        PartialListIterator *arg1 = (PartialListIterator *) 0 ;
        PartialListIterator *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialListIterator_prev(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialListIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialListIterator_prev. Expected _p_PartialListIterator");
            }
        }
        {
            try
            {
                result = (PartialListIterator *)PartialListIterator_prev(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialListIterator, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialListIterator_partial) {
    {
        PartialListIterator *arg1 = (PartialListIterator *) 0 ;
        Partial *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: PartialListIterator_partial(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialListIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialListIterator_partial. Expected _p_PartialListIterator");
            }
        }
        {
            try
            {
                result = (Partial *)PartialListIterator_partial(arg1);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Partial, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialListIterator_equals) {
    {
        PartialListIterator *arg1 = (PartialListIterator *) 0 ;
        PartialListIterator *arg2 = (PartialListIterator *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: PartialListIterator_equals(self,other);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialListIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialListIterator_equals. Expected _p_PartialListIterator");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialListIterator,0) < 0) {
                SWIG_croak("Type error in argument 2 of PartialListIterator_equals. Expected _p_PartialListIterator");
            }
        }
        {
            try
            {
                result = (int)PartialListIterator_equals(arg1,arg2);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_PartialListIterator_isInRange) {
    {
        PartialListIterator *arg1 = (PartialListIterator *) 0 ;
        PartialListIterator *arg2 = (PartialListIterator *) 0 ;
        PartialListIterator *arg3 = (PartialListIterator *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: PartialListIterator_isInRange(self,begin,end);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialListIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of PartialListIterator_isInRange. Expected _p_PartialListIterator");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialListIterator,0) < 0) {
                SWIG_croak("Type error in argument 2 of PartialListIterator_isInRange. Expected _p_PartialListIterator");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_PartialListIterator,0) < 0) {
                SWIG_croak("Type error in argument 3 of PartialListIterator_isInRange. Expected _p_PartialListIterator");
            }
        }
        {
            try
            {
                result = (int)PartialListIterator_isInRange(arg1,(PartialListIterator const *)arg2,(PartialListIterator const *)arg3);
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_PartialListIterator) {
    {
        PartialListIterator *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_PartialListIterator();");
        }
        {
            try
            {
                result = (PartialListIterator *)new PartialListIterator();
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialListIterator, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_PartialListIterator) {
    {
        PartialListIterator *arg1 = (PartialListIterator *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_PartialListIterator(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialListIterator,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_PartialListIterator. Expected _p_PartialListIterator");
            }
        }
        {
            try
            {
                delete arg1;
                
            }
            catch( Loris::Exception & ex ) 
            {
                //	catch Loris::Exceptions:
                std::string s("Loris exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
            catch( std::exception & ex ) 
            {
                //	catch std::exceptions:
                std::string s("std C++ exception: " );
                s.append( ex.what() );
                SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
            }
        }
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_PartialList[] = {{"perLoris::PartialList", 0, "PartialList *", 0},{"perLoris::PartialList"},{0}};
static swig_type_info _swigt__p_SpcFile[] = {{"perLoris::SpcFile", 0, "SpcFile *", 0},{"perLoris::SpcFile"},{0}};
static swig_type_info _swigt__p_Breakpoint[] = {{"perLoris::Breakpoint", 0, "Breakpoint *", 0},{"perLoris::Breakpoint"},{0}};
static swig_type_info _swigt__p_Analyzer[] = {{"perLoris::Analyzer", 0, "Analyzer *", 0},{"perLoris::Analyzer"},{0}};
static swig_type_info _swigt__p_double[] = {{"_p_double", 0, "double *", 0},{"_p_double"},{0}};
static swig_type_info _swigt__p_Partial[] = {{"perLoris::Partial", 0, "Partial *", 0},{"perLoris::Partial"},{0}};
static swig_type_info _swigt__p_Loris__Partial[] = {{"_p_Loris__Partial", 0, "Loris::Partial *", 0},{"_p_Loris__Partial"},{0}};
static swig_type_info _swigt__p_BreakpointEnvelope[] = {{"perLoris::BreakpointEnvelope", 0, "BreakpointEnvelope *", 0},{"perLoris::BreakpointEnvelope"},{0}};
static swig_type_info _swigt__p_BreakpointPosition[] = {{"perLoris::BreakpointPosition", 0, "BreakpointPosition *", 0},{"perLoris::BreakpointPosition"},{0}};
static swig_type_info _swigt__p_AiffFile[] = {{"perLoris::AiffFile", 0, "AiffFile *", 0},{"perLoris::AiffFile"},{0}};
static swig_type_info _swigt__p_SampleVector[] = {{"perLoris::SampleVector", 0, "SampleVector *", 0},{"perLoris::SampleVector"},{0}};
static swig_type_info _swigt__p_SdifFile[] = {{"perLoris::SdifFile", 0, "SdifFile *", 0},{"perLoris::SdifFile"},{0}};
static swig_type_info _swigt__p_NewPartialIterator[] = {{"perLoris::NewPartialIterator", 0, "NewPartialIterator *", 0},{"perLoris::NewPartialIterator"},{0}};
static swig_type_info _swigt__p_NewPlistIterator[] = {{"perLoris::NewPlistIterator", 0, "NewPlistIterator *", 0},{"perLoris::NewPlistIterator"},{0}};
static swig_type_info _swigt__p_Marker[] = {{"perLoris::Marker", 0, "Marker *", 0},{"perLoris::Marker"},{0}};
static swig_type_info _swigt__p_PartialListIterator[] = {{"perLoris::PartialListIterator", 0, "PartialListIterator *", 0},{"perLoris::PartialListIterator"},{0}};
static swig_type_info _swigt__p_PartialIterator[] = {{"perLoris::PartialIterator", 0, "PartialIterator *", 0},{"perLoris::PartialIterator"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_PartialList, 
_swigt__p_SpcFile, 
_swigt__p_Breakpoint, 
_swigt__p_Analyzer, 
_swigt__p_double, 
_swigt__p_Partial, 
_swigt__p_Loris__Partial, 
_swigt__p_BreakpointEnvelope, 
_swigt__p_BreakpointPosition, 
_swigt__p_AiffFile, 
_swigt__p_SampleVector, 
_swigt__p_SdifFile, 
_swigt__p_NewPartialIterator, 
_swigt__p_NewPlistIterator, 
_swigt__p_Marker, 
_swigt__p_PartialListIterator, 
_swigt__p_PartialIterator, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_constant_info swig_constants[] = {
{0}
};
#ifdef __cplusplus
}
#endif
static swig_variable_info swig_variables[] = {
{0}
};
static swig_command_info swig_commands[] = {
{"perLorisc::channelize", _wrap_channelize},
{"perLorisc::createFreqReference", _wrap_createFreqReference},
{"perLorisc::dilate", _wrap_dilate},
{"perLorisc::distill", _wrap_distill},
{"perLorisc::exportAiff", _wrap_exportAiff},
{"perLorisc::exportSdif", _wrap_exportSdif},
{"perLorisc::exportSpc", _wrap_exportSpc},
{"perLorisc::importSdif", _wrap_importSdif},
{"perLorisc::importSpc", _wrap_importSpc},
{"perLorisc::morph", _wrap_morph},
{"perLorisc::synthesize", _wrap_synthesize},
{"perLorisc::crop", _wrap_crop},
{"perLorisc::copyLabeled", _wrap_copyLabeled},
{"perLorisc::extractLabeled", _wrap_extractLabeled},
{"perLorisc::removeLabeled", _wrap_removeLabeled},
{"perLorisc::resample", _wrap_resample},
{"perLorisc::scaleAmp", _wrap_scaleAmp},
{"perLorisc::scaleBandwidth", _wrap_scaleBandwidth},
{"perLorisc::scaleFrequency", _wrap_scaleFrequency},
{"perLorisc::scaleNoiseRatio", _wrap_scaleNoiseRatio},
{"perLorisc::shiftPitch", _wrap_shiftPitch},
{"perLorisc::shiftTime", _wrap_shiftTime},
{"perLorisc::sift", _wrap_sift},
{"perLorisc::sortByLabel", _wrap_sortByLabel},
{"perLorisc::version", _wrap_version},
{"perLorisc::new_Marker", _wrap_new_Marker},
{"perLorisc::Marker_name", _wrap_Marker_name},
{"perLorisc::Marker_time", _wrap_Marker_time},
{"perLorisc::Marker_setName", _wrap_Marker_setName},
{"perLorisc::Marker_setTime", _wrap_Marker_setTime},
{"perLorisc::delete_Marker", _wrap_delete_Marker},
{"perLorisc::delete_AiffFile", _wrap_delete_AiffFile},
{"perLorisc::AiffFile_sampleRate", _wrap_AiffFile_sampleRate},
{"perLorisc::AiffFile_midiNoteNumber", _wrap_AiffFile_midiNoteNumber},
{"perLorisc::AiffFile_sampleFrames", _wrap_AiffFile_sampleFrames},
{"perLorisc::AiffFile_addPartial", _wrap_AiffFile_addPartial},
{"perLorisc::AiffFile_setMidiNoteNumber", _wrap_AiffFile_setMidiNoteNumber},
{"perLorisc::AiffFile_write", _wrap_AiffFile_write},
{"perLorisc::new_AiffFile", _wrap_new_AiffFile},
{"perLorisc::AiffFile_samples", _wrap_AiffFile_samples},
{"perLorisc::AiffFile_channels", _wrap_AiffFile_channels},
{"perLorisc::AiffFile_addPartials", _wrap_AiffFile_addPartials},
{"perLorisc::AiffFile_numMarkers", _wrap_AiffFile_numMarkers},
{"perLorisc::AiffFile_getMarker", _wrap_AiffFile_getMarker},
{"perLorisc::AiffFile_removeMarker", _wrap_AiffFile_removeMarker},
{"perLorisc::AiffFile_addMarker", _wrap_AiffFile_addMarker},
{"perLorisc::new_Analyzer", _wrap_new_Analyzer},
{"perLorisc::Analyzer_copy", _wrap_Analyzer_copy},
{"perLorisc::Analyzer_analyze", _wrap_Analyzer_analyze},
{"perLorisc::Analyzer_freqResolution", _wrap_Analyzer_freqResolution},
{"perLorisc::Analyzer_ampFloor", _wrap_Analyzer_ampFloor},
{"perLorisc::Analyzer_windowWidth", _wrap_Analyzer_windowWidth},
{"perLorisc::Analyzer_sidelobeLevel", _wrap_Analyzer_sidelobeLevel},
{"perLorisc::Analyzer_freqFloor", _wrap_Analyzer_freqFloor},
{"perLorisc::Analyzer_hopTime", _wrap_Analyzer_hopTime},
{"perLorisc::Analyzer_freqDrift", _wrap_Analyzer_freqDrift},
{"perLorisc::Analyzer_cropTime", _wrap_Analyzer_cropTime},
{"perLorisc::Analyzer_bwRegionWidth", _wrap_Analyzer_bwRegionWidth},
{"perLorisc::Analyzer_setFreqResolution", _wrap_Analyzer_setFreqResolution},
{"perLorisc::Analyzer_setAmpFloor", _wrap_Analyzer_setAmpFloor},
{"perLorisc::Analyzer_setWindowWidth", _wrap_Analyzer_setWindowWidth},
{"perLorisc::Analyzer_setSidelobeLevel", _wrap_Analyzer_setSidelobeLevel},
{"perLorisc::Analyzer_setFreqFloor", _wrap_Analyzer_setFreqFloor},
{"perLorisc::Analyzer_setFreqDrift", _wrap_Analyzer_setFreqDrift},
{"perLorisc::Analyzer_setHopTime", _wrap_Analyzer_setHopTime},
{"perLorisc::Analyzer_setCropTime", _wrap_Analyzer_setCropTime},
{"perLorisc::Analyzer_setBwRegionWidth", _wrap_Analyzer_setBwRegionWidth},
{"perLorisc::delete_Analyzer", _wrap_delete_Analyzer},
{"perLorisc::new_BreakpointEnvelope", _wrap_new_BreakpointEnvelope},
{"perLorisc::delete_BreakpointEnvelope", _wrap_delete_BreakpointEnvelope},
{"perLorisc::BreakpointEnvelope_copy", _wrap_BreakpointEnvelope_copy},
{"perLorisc::BreakpointEnvelope_insertBreakpoint", _wrap_BreakpointEnvelope_insertBreakpoint},
{"perLorisc::BreakpointEnvelope_valueAt", _wrap_BreakpointEnvelope_valueAt},
{"perLorisc::BreakpointEnvelopeWithValue", _wrap_BreakpointEnvelopeWithValue},
{"perLorisc::new_SampleVector", _wrap_new_SampleVector},
{"perLorisc::delete_SampleVector", _wrap_delete_SampleVector},
{"perLorisc::SampleVector_clear", _wrap_SampleVector_clear},
{"perLorisc::SampleVector_resize", _wrap_SampleVector_resize},
{"perLorisc::SampleVector_size", _wrap_SampleVector_size},
{"perLorisc::SampleVector_copy", _wrap_SampleVector_copy},
{"perLorisc::SampleVector_getAt", _wrap_SampleVector_getAt},
{"perLorisc::SampleVector_setAt", _wrap_SampleVector_setAt},
{"perLorisc::delete_SdifFile", _wrap_delete_SdifFile},
{"perLorisc::SdifFile_write", _wrap_SdifFile_write},
{"perLorisc::SdifFile_write1TRC", _wrap_SdifFile_write1TRC},
{"perLorisc::new_SdifFile", _wrap_new_SdifFile},
{"perLorisc::SdifFile_partials", _wrap_SdifFile_partials},
{"perLorisc::SdifFile_addPartials", _wrap_SdifFile_addPartials},
{"perLorisc::SdifFile_numMarkers", _wrap_SdifFile_numMarkers},
{"perLorisc::SdifFile_getMarker", _wrap_SdifFile_getMarker},
{"perLorisc::SdifFile_removeMarker", _wrap_SdifFile_removeMarker},
{"perLorisc::SdifFile_addMarker", _wrap_SdifFile_addMarker},
{"perLorisc::delete_SpcFile", _wrap_delete_SpcFile},
{"perLorisc::SpcFile_sampleRate", _wrap_SpcFile_sampleRate},
{"perLorisc::SpcFile_midiNoteNumber", _wrap_SpcFile_midiNoteNumber},
{"perLorisc::SpcFile_addPartial", _wrap_SpcFile_addPartial},
{"perLorisc::SpcFile_setMidiNoteNumber", _wrap_SpcFile_setMidiNoteNumber},
{"perLorisc::SpcFile_setSampleRate", _wrap_SpcFile_setSampleRate},
{"perLorisc::SpcFile_write", _wrap_SpcFile_write},
{"perLorisc::new_SpcFile", _wrap_new_SpcFile},
{"perLorisc::SpcFile_partials", _wrap_SpcFile_partials},
{"perLorisc::SpcFile_addPartials", _wrap_SpcFile_addPartials},
{"perLorisc::SpcFile_numMarkers", _wrap_SpcFile_numMarkers},
{"perLorisc::SpcFile_getMarker", _wrap_SpcFile_getMarker},
{"perLorisc::SpcFile_removeMarker", _wrap_SpcFile_removeMarker},
{"perLorisc::SpcFile_addMarker", _wrap_SpcFile_addMarker},
{"perLorisc::NewPlistIterator_atEnd", _wrap_NewPlistIterator_atEnd},
{"perLorisc::NewPlistIterator_next", _wrap_NewPlistIterator_next},
{"perLorisc::NewPlistIterator_partial", _wrap_NewPlistIterator_partial},
{"perLorisc::NewPartialIterator_atEnd", _wrap_NewPartialIterator_atEnd},
{"perLorisc::NewPartialIterator_hasNext", _wrap_NewPartialIterator_hasNext},
{"perLorisc::NewPartialIterator_next", _wrap_NewPartialIterator_next},
{"perLorisc::new_PartialList", _wrap_new_PartialList},
{"perLorisc::delete_PartialList", _wrap_delete_PartialList},
{"perLorisc::PartialList_clear", _wrap_PartialList_clear},
{"perLorisc::PartialList_size", _wrap_PartialList_size},
{"perLorisc::PartialList_timeSpan", _wrap_PartialList_timeSpan},
{"perLorisc::PartialList_iterator", _wrap_PartialList_iterator},
{"perLorisc::PartialList_append", _wrap_PartialList_append},
{"perLorisc::PartialList_begin", _wrap_PartialList_begin},
{"perLorisc::PartialList_end", _wrap_PartialList_end},
{"perLorisc::PartialList_erase", _wrap_PartialList_erase},
{"perLorisc::PartialList_splice", _wrap_PartialList_splice},
{"perLorisc::PartialList_insert", _wrap_PartialList_insert},
{"perLorisc::PartialList_copy", _wrap_PartialList_copy},
{"perLorisc::new_Partial", _wrap_new_Partial},
{"perLorisc::delete_Partial", _wrap_delete_Partial},
{"perLorisc::Partial_label", _wrap_Partial_label},
{"perLorisc::Partial_initialPhase", _wrap_Partial_initialPhase},
{"perLorisc::Partial_startTime", _wrap_Partial_startTime},
{"perLorisc::Partial_endTime", _wrap_Partial_endTime},
{"perLorisc::Partial_duration", _wrap_Partial_duration},
{"perLorisc::Partial_numBreakpoints", _wrap_Partial_numBreakpoints},
{"perLorisc::Partial_setLabel", _wrap_Partial_setLabel},
{"perLorisc::Partial_frequencyAt", _wrap_Partial_frequencyAt},
{"perLorisc::Partial_amplitudeAt", _wrap_Partial_amplitudeAt},
{"perLorisc::Partial_bandwidthAt", _wrap_Partial_bandwidthAt},
{"perLorisc::Partial_phaseAt", _wrap_Partial_phaseAt},
{"perLorisc::Partial_iterator", _wrap_Partial_iterator},
{"perLorisc::Partial_begin", _wrap_Partial_begin},
{"perLorisc::Partial_end", _wrap_Partial_end},
{"perLorisc::Partial_erase", _wrap_Partial_erase},
{"perLorisc::Partial_insert", _wrap_Partial_insert},
{"perLorisc::Partial_findAfter", _wrap_Partial_findAfter},
{"perLorisc::Partial_findNearest", _wrap_Partial_findNearest},
{"perLorisc::Partial_copy", _wrap_Partial_copy},
{"perLorisc::Partial_equals", _wrap_Partial_equals},
{"perLorisc::new_Breakpoint", _wrap_new_Breakpoint},
{"perLorisc::delete_Breakpoint", _wrap_delete_Breakpoint},
{"perLorisc::Breakpoint_frequency", _wrap_Breakpoint_frequency},
{"perLorisc::Breakpoint_amplitude", _wrap_Breakpoint_amplitude},
{"perLorisc::Breakpoint_bandwidth", _wrap_Breakpoint_bandwidth},
{"perLorisc::Breakpoint_phase", _wrap_Breakpoint_phase},
{"perLorisc::Breakpoint_setFrequency", _wrap_Breakpoint_setFrequency},
{"perLorisc::Breakpoint_setAmplitude", _wrap_Breakpoint_setAmplitude},
{"perLorisc::Breakpoint_setBandwidth", _wrap_Breakpoint_setBandwidth},
{"perLorisc::Breakpoint_setPhase", _wrap_Breakpoint_setPhase},
{"perLorisc::Breakpoint_copy", _wrap_Breakpoint_copy},
{"perLorisc::Breakpoint_equals", _wrap_Breakpoint_equals},
{"perLorisc::BreakpointPosition_time", _wrap_BreakpointPosition_time},
{"perLorisc::BreakpointPosition_breakpoint", _wrap_BreakpointPosition_breakpoint},
{"perLorisc::BreakpointPosition_frequency", _wrap_BreakpointPosition_frequency},
{"perLorisc::BreakpointPosition_amplitude", _wrap_BreakpointPosition_amplitude},
{"perLorisc::BreakpointPosition_bandwidth", _wrap_BreakpointPosition_bandwidth},
{"perLorisc::BreakpointPosition_phase", _wrap_BreakpointPosition_phase},
{"perLorisc::BreakpointPosition_setFrequency", _wrap_BreakpointPosition_setFrequency},
{"perLorisc::BreakpointPosition_setAmplitude", _wrap_BreakpointPosition_setAmplitude},
{"perLorisc::BreakpointPosition_setBandwidth", _wrap_BreakpointPosition_setBandwidth},
{"perLorisc::BreakpointPosition_setPhase", _wrap_BreakpointPosition_setPhase},
{"perLorisc::PartialIterator_time", _wrap_PartialIterator_time},
{"perLorisc::PartialIterator_breakpoint", _wrap_PartialIterator_breakpoint},
{"perLorisc::PartialIterator_copy", _wrap_PartialIterator_copy},
{"perLorisc::PartialIterator_next", _wrap_PartialIterator_next},
{"perLorisc::PartialIterator_prev", _wrap_PartialIterator_prev},
{"perLorisc::PartialIterator_equals", _wrap_PartialIterator_equals},
{"perLorisc::PartialIterator_isInRange", _wrap_PartialIterator_isInRange},
{"perLorisc::new_PartialIterator", _wrap_new_PartialIterator},
{"perLorisc::delete_PartialIterator", _wrap_delete_PartialIterator},
{"perLorisc::PartialListIterator_copy", _wrap_PartialListIterator_copy},
{"perLorisc::PartialListIterator_next", _wrap_PartialListIterator_next},
{"perLorisc::PartialListIterator_prev", _wrap_PartialListIterator_prev},
{"perLorisc::PartialListIterator_partial", _wrap_PartialListIterator_partial},
{"perLorisc::PartialListIterator_equals", _wrap_PartialListIterator_equals},
{"perLorisc::PartialListIterator_isInRange", _wrap_PartialListIterator_isInRange},
{"perLorisc::new_PartialListIterator", _wrap_new_PartialListIterator},
{"perLorisc::delete_PartialListIterator", _wrap_delete_PartialListIterator},
{0,0}
};

#ifdef __cplusplus
extern "C"
#endif

XS(SWIG_init) {
    dXSARGS;
    int i;
    static int _init = 0;
    if (!_init) {
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }	
        _init = 1;
    }
    
    /* Install commands */
    for (i = 0; swig_commands[i].name; i++) {
        newXS((char*) swig_commands[i].name,swig_commands[i].wrapper, (char*)__FILE__);
    }
    
    /* Install variables */
    for (i = 0; swig_variables[i].name; i++) {
        SV *sv;
        sv = perl_get_sv((char*) swig_variables[i].name, TRUE | 0x2);
        if (swig_variables[i].type) {
            SWIG_MakePtr(sv,(void *)1, *swig_variables[i].type,0);
        } else {
            sv_setiv(sv,(IV) 0);
        }
        swig_create_magic(sv, (char *) swig_variables[i].name, swig_variables[i].set, swig_variables[i].get); 
    }
    
    /* Install constant */
    for (i = 0; swig_constants[i].type; i++) {
        SV *sv;
        sv = perl_get_sv((char*)swig_constants[i].name, TRUE | 0x2);
        switch(swig_constants[i].type) {
            case SWIG_INT:
            sv_setiv(sv, (IV) swig_constants[i].lvalue);
            break;
            case SWIG_FLOAT:
            sv_setnv(sv, (double) swig_constants[i].dvalue);
            break;
            case SWIG_STRING:
            sv_setpv(sv, (char *) swig_constants[i].pvalue);
            break;
            case SWIG_POINTER:
            SWIG_MakePtr(sv, swig_constants[i].pvalue, *(swig_constants[i].ptype),0);
            break;
            case SWIG_BINARY:
            SWIG_MakePackedObj(sv, swig_constants[i].pvalue, swig_constants[i].lvalue, *(swig_constants[i].ptype));
            break;
            default:
            break;
        }
        SvREADONLY_on(sv);
    }
    
    
    Loris::setNotifier( printf_notifier );
    Loris::setExceptionHandler( throw_exception );
    
    SWIG_TypeClientData(SWIGTYPE_p_Marker, (void*) "perLoris::Marker");
    SWIG_TypeClientData(SWIGTYPE_p_AiffFile, (void*) "perLoris::AiffFile");
    SWIG_TypeClientData(SWIGTYPE_p_Analyzer, (void*) "perLoris::Analyzer");
    SWIG_TypeClientData(SWIGTYPE_p_BreakpointEnvelope, (void*) "perLoris::BreakpointEnvelope");
    SWIG_TypeClientData(SWIGTYPE_p_SampleVector, (void*) "perLoris::SampleVector");
    SWIG_TypeClientData(SWIGTYPE_p_SdifFile, (void*) "perLoris::SdifFile");
    SWIG_TypeClientData(SWIGTYPE_p_SpcFile, (void*) "perLoris::SpcFile");
    SWIG_TypeClientData(SWIGTYPE_p_NewPlistIterator, (void*) "perLoris::NewPlistIterator");
    SWIG_TypeClientData(SWIGTYPE_p_NewPartialIterator, (void*) "perLoris::NewPartialIterator");
    SWIG_TypeClientData(SWIGTYPE_p_PartialList, (void*) "perLoris::PartialList");
    SWIG_TypeClientData(SWIGTYPE_p_Partial, (void*) "perLoris::Partial");
    SWIG_TypeClientData(SWIGTYPE_p_Breakpoint, (void*) "perLoris::Breakpoint");
    SWIG_TypeClientData(SWIGTYPE_p_BreakpointPosition, (void*) "perLoris::BreakpointPosition");
    SWIG_TypeClientData(SWIGTYPE_p_PartialIterator, (void*) "perLoris::PartialIterator");
    SWIG_TypeClientData(SWIGTYPE_p_PartialListIterator, (void*) "perLoris::PartialListIterator");
    ST(0) = &PL_sv_yes;
    XSRETURN(1);
}

