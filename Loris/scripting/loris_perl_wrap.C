/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.11u-20020201-1626
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */


#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    inline SwigValueWrapper() : tt(0) { }
    inline ~SwigValueWrapper() { if (tt) delete tt; } 
    inline SwigValueWrapper& operator=(T t) {tt = new T(t); return *this;}
    inline operator T() const {return *tt;}
    inline T *operator&() { return tt; }
};                                                    
#endif

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#       endif
#endif
#else
#       define SWIGEXPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif



#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);

typedef struct swig_type_info {
  const char             *name;                 
  swig_converter_func     converter;
  const char             *str;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
  void                   *clientdata;	
} swig_type_info;

#ifdef SWIG_NOINCLUDE
SWIGEXPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGEXPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGEXPORT(void *) SWIG_TypeCast(swig_type_info *, void *);
SWIGEXPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGEXPORT(void) SWIG_TypeClientData(swig_type_info *, void *);
#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  while (s) {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  }
  return 0;
}

/* Cast a pointer (needed for C++ inheritance */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
	if ((strcmp(tc->name, equiv->name) == 0))
	  SWIG_TypeClientData(tc,clientdata);
	tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}
#endif

#ifdef __cplusplus
}

#endif




/* -----------------------------------------------------------------------------
 * perl5.swg
 *
 * Perl5 runtime library
 * $Header$
 * ----------------------------------------------------------------------------- */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
/* Needed on some windows machines---since MS plays funny
   games with the header files under C++ */
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* Get rid of free and malloc defined by perl */
#undef free
#undef malloc

#ifndef pTHX_
#define pTHX_
#endif

#include <string.h>
#ifdef __cplusplus
}
#endif

/* Note: SwigMagicFuncHack is a typedef used to get the C++
   compiler to just shut up already */

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerlObj *pPerl = (CPerlObj *) this;
typedef int (CPerlObj::*SwigMagicFunc)(SV *, MAGIC *);

#ifdef __cplusplus
extern "C" {
#endif
typedef int (CPerlObj::*SwigMagicFuncHack)(SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)
#define SWIGCLASS_STATIC
#else
#define MAGIC_PPERL
#define SWIGCLASS_STATIC static
#ifndef MULTIPLICITY
#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)
typedef int (*SwigMagicFunc)(SV *, MAGIC *);

#ifdef __cplusplus
extern "C" {
#endif
typedef int (*SwigMagicFuncHack)(SV *, MAGIC *);
#ifdef __cplusplus
}
#endif


#else
#define SWIG_MAGIC(a,b) (struct interpreter *interp, SV *a, MAGIC *b)
typedef int (*SwigMagicFunc)(struct interpreter *, SV *, MAGIC *);
#ifdef __cplusplus
extern "C" {
#endif
typedef int (*SwigMagicFuncHack)(struct interpreter *, SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#endif
#endif

#if defined(WIN32) && defined(PERL_OBJECT) && !defined(PerlIO_exportFILE)
#define PerlIO_exportFILE(fh,fl) (FILE*)(fh)
#endif

/* Modifications for newer Perl 5.005 releases */

#if !defined(PERL_REVISION) || ((PERL_REVISION >= 5) && ((PERL_VERSION < 5) || ((PERL_VERSION == 5) && (PERL_SUBVERSION < 50))))
#ifndef PL_sv_yes
#define PL_sv_yes sv_yes
#endif
#ifndef PL_sv_undef
#define PL_sv_undef sv_undef
#endif
#ifndef PL_na
#define PL_na na
#endif
#endif

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SWIG_NOINCLUDE

#ifndef PERL_OBJECT
extern int SWIG_ConvertPtr(SV *, void **, swig_type_info *);
extern void SWIG_MakePtr(SV *, void *, swig_type_info *);
#else
extern int _SWIG_ConvertPtr(CPerlObj *, SV *, void **, swig_type_info *);
extern void _SWIG_MakePtr(CPerlObj *, SV *, void *, swig_type_info *);
#define SWIG_ConvertPtr(a,b,c) _SWIG_ConvertPtr(pPerl,a,b,c)
#define SWIG_MakePtr(a,b,c) _SWIG_MakePtr(pPerl,a,b,c)
#endif

#else

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGRUNTIME(int) 
SWIG_ConvertPtr(SV *sv, void **ptr, swig_type_info *_t)
#else
#define SWIG_ConvertPtr(a,b,c) _SWIG_ConvertPtr(pPerl,a,b,c)
SWIGRUNTIME(int)
_SWIG_ConvertPtr(CPerlObj *pPerl, SV *sv, void **ptr, swig_type_info *_t)
#endif
{
  char *_c;
  swig_type_info *tc;
  IV   tmp;

  /* If magical, apply more magic */
  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
	mg = mg_find(tsv,'P');
	if (mg) {
	  SV *rsv = mg->mg_obj;
	  if (sv_isobject(rsv)) {
	    tmp = SvIV((SV*)SvRV(rsv));
	  }
	}
      } else {
	return -1;
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    if (!_t) {
      *(ptr) = (void *) tmp;
      return 0;
    }
  } else if (! SvOK(sv)) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return 0;
  } else if (SvTYPE(sv) == SVt_RV) {  /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv)) 
      return 0;
    else
      return -1;
  } else {                            /* Don't know what it is */
      *(ptr) = (void *) 0;
      return -1;
  }
  if (_t) {
    /* Now see if the types match */      
    _c = HvNAME(SvSTASH(SvRV(sv)));
    tc = SWIG_TypeCheck(_c,_t);
    if (!tc) {
      *ptr = (void *) tmp;
      return -1;
    }
    *ptr = SWIG_TypeCast(tc,(void *)tmp);
    return 0;
  }
  *ptr = (void *) tmp;
  return 0;
}
#ifndef PERL_OBJECT
SWIGRUNTIME(void) 
SWIG_MakePtr(SV *sv, void *ptr, swig_type_info *t)
#else
#define SWIG_MakePtr(a,b,c) _SWIG_MakePtr(pPerl,a,b,c)
SWIGRUNTIME(void)
_SWIG_MakePtr(CPerlObj *pPerl, SV *sv, void *ptr, swig_type_info *t)
#endif
{
  sv_setref_pv(sv, (char *) t->name, ptr);
}

#endif

typedef XS(SwigPerlWrapper);
typedef SwigPerlWrapper *SwigPerlWrapperPtr;

/* Structure for command table */
typedef struct {
  const char         *name;
  SwigPerlWrapperPtr  wrapper;
} swig_command_info;

/* Information for constant table */

#define SWIG_INT     1
#define SWIG_FLOAT   2
#define SWIG_STRING  3
#define SWIG_POINTER 4
#define SWIG_BINARY  5

/* Constant information structure */
typedef struct swig_constant_info {
    int              type;
    const char      *name;
    long             lvalue;
    double           dvalue;
    void            *pvalue;
    swig_type_info **ptype;
} swig_constant_info;

#ifdef __cplusplus
}
#endif

/* Structure for variable table */
typedef struct {
  const char   *name;
  SwigMagicFunc   set;
  SwigMagicFunc   get;
} swig_variable_info;

/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
  #ifndef MULTIPLICITY 
       static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int \
(*get)(SV *,MAGIC *)) { 
  #else 
       static void _swig_create_magic(SV *sv, char *name, int (*set)(struct interpreter*,\
 SV *, MAGIC *), int (*get)(struct interpreter*, SV *,MAGIC *)) { 
  #endif 
#else
#define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerlObj *pPerl, SV *sv, const char *name, int (CPerlObj::*set)(SV *, MAGIC *), int (CPerlObj::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',(char *) name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = (SwigMagicFuncHack) get;
  mg->mg_virtual->svt_set = (SwigMagicFuncHack) set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}







/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_Partial swig_types[0] 
#define  SWIGTYPE_p_PartialList swig_types[1] 
#define  SWIGTYPE_p_SampleVector swig_types[2] 
#define  SWIGTYPE_p_AiffFile swig_types[3] 
#define  SWIGTYPE_p_Analyzer swig_types[4] 
#define  SWIGTYPE_p_double swig_types[5] 
#define  SWIGTYPE_p_PartialListIterator swig_types[6] 
#define  SWIGTYPE_p_PartialIterator swig_types[7] 
#define  SWIGTYPE_p_Breakpoint swig_types[8] 
#define  SWIGTYPE_p_BreakpointEnvelope swig_types[9] 
static swig_type_info *swig_types[11];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    boot_loris_perl

#define SWIG_name   "loris_perl::boot_loris_perl"
#define SWIG_prefix "loris_perl::"

#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
#ifndef MULTIPLICITY
SWIGEXPORT(void) SWIG_init (CV* cv);
#else
SWIGEXPORT(void) SWIG_init (pTHXo_ CV* cv);
#endif
#else
SWIGEXPORT(void) SWIG_init (CV *cv, CPerlObj *);
#endif


		#undef list
	

	#include<Notifier.h>
	#include<Exception.h>
	#include <string>
	
	//	notification function for Loris debugging
	//	and notifications, installed in initialization
	//	block below:
	static void printf_notifier( const char * s )
	{
		printf("*\t%s\n", s);
	}	
	
	//	class NullPointer
	//
	//	Define a Loris::Exception subclass for catching NULL pointers.
	//	This is copied from lorisException_pi.h. It could be in Loris,
	//	but probably was never needed because Loris doesn't make much 
	//	use of pointers.
	//
	class NullPointer : public Loris::Exception
	{
	public: 
		NullPointer( const std::string & str, const std::string & where = "" ) : 
			Exception( std::string("NULL pointer exception -- ").append( str ), where ) {}
	};	//	end of class NullPointer
	
	//	define a macro for testing and throwing:
	#define ThrowIfNull(ptr) if ((ptr)==NULL) Throw( NullPointer, #ptr );	


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


#define SWIG_exception(a,b)   croak(b)


#include<Partial.h>
#include<PartialUtils.h>
#include<Notifier.h>
#include <list>

using Loris::debugger;
using Loris::Partial;
using Loris::PartialUtils;
using Loris::Breakpoint;

//	define the names of the classes that are 
//	wrapped by this interface file:
//	(additionally Partial and Breakpoint)
typedef std::list< Loris::Partial > PartialList;
typedef std::list< Loris::Partial >::iterator PartialListIterator;
typedef Loris::Partial::iterator PartialIterator;


PartialList *new_PartialList(){
			debugger << "creating an empty list of Partials" << Loris::endl;
			return new PartialList();
		}
void delete_PartialList(PartialList *self){
			debugger << "destroying  a list of " << self->size() << " Partials" << Loris::endl;
			delete self;
		}
PartialList *PartialList_copy(PartialList *self){
			return new PartialList( *self );
		}
void PartialList_timeSpan(PartialList *self,double *tmin_out,double *tmax_out){
		 	std::pair<double, double> span = 
		 		PartialUtils::timeSpan( self->begin(), self->end() );
		 	*tmin_out = span.first;
		 	*tmax_out = span.second;
		 }
PartialListIterator *PartialListIterator_copy(PartialListIterator *self){
			return new PartialListIterator( *self );
		}
PartialListIterator *PartialListIterator_next(PartialListIterator *self){
			PartialListIterator * next = new PartialListIterator(*self);
			++(*next);
			return next;
		}
PartialListIterator *PartialListIterator_prev(PartialListIterator *self){
			PartialListIterator * prev = new PartialListIterator(*self);
			--(*prev);
			return prev;
		}
Partial *PartialListIterator_partial(PartialListIterator *self){
			Partial & current = **self;
			return &current;
		}
int PartialListIterator_equals(PartialListIterator *self,PartialListIterator *other){
			return *self == *other;
		}
int PartialListIterator_isInRange(PartialListIterator *self,PartialListIterator const *begin,PartialListIterator const *end){	
		 	PartialListIterator it;
		 	for ( it = *begin; it != *end; ++it )
		 	{
		 		if ( it == *self )
		 			return true;
		 	}
		 	return false;
		 }
Partial *Partial_copy(Partial *self){
			return new Partial( *self );
		}
int Partial_equals(Partial *self,Partial *other){
			return *self == *other;
		}
Breakpoint *PartialIterator_breakpoint(PartialIterator *self){ 
			return &(self->breakpoint());
		}
PartialIterator *PartialIterator_copy(PartialIterator *self){
			return new PartialIterator( *self );
		}
PartialIterator *PartialIterator_next(PartialIterator *self){
			PartialIterator * next = new PartialIterator(*self);
			++(*next);
			return next;
		}
PartialIterator *PartialIterator_prev(PartialIterator *self){
			PartialIterator * prev = new PartialIterator(*self);
			--(*prev);
			return prev;
		}
int PartialIterator_equals(PartialIterator *self,PartialIterator *other){
			return *self == *other;
		}
int PartialIterator_isInRange(PartialIterator *self,PartialIterator const *begin,PartialIterator const *end){	
		 	PartialIterator it;
		 	for ( it = *begin; it != *end; ++it )
		 	{
		 		if ( it == *self )
		 			return true;
		 	}
		 	return false;
		 }
Breakpoint *Breakpoint_copy(Breakpoint *self){
			return new Breakpoint( *self );
		}
int Breakpoint_equals(Breakpoint *self,Breakpoint *other){
			return *self == *other;
		}

#include <stdexcept>
#include <vector>
typedef std::vector< double > SampleVector;

SampleVector *SampleVector_copy(SampleVector *self){
		return new SampleVector( *self );
	}
double SampleVector_getAt(SampleVector *self,unsigned long idx){
		// return self->at(idx);	//	g++ doesn't implement at()?
		if ( idx >= self->size() )
			throw std::out_of_range("vector::at index out of range");
		return (*self)[idx];
	}
void SampleVector_setAt(SampleVector *self,unsigned long idx,double x){
		// self->at(idx) = x;	//	g++ doesn't implement at()?
		if ( idx >= self->size() )
			throw std::out_of_range("vector::at index out of range");
		(*self)[idx] = x;
	}

#include<Analyzer.h>
#include<Partial.h>

using Loris::Analyzer;

Analyzer *new_Analyzer(double resolutionHz,double windowWidthHz){
		if ( windowWidthHz == 0. )
			windowWidthHz = resolutionHz;
		return new Analyzer( resolutionHz, windowWidthHz );
	}
Analyzer *Analyzer_copy(Analyzer *self){
		return new Analyzer( self->freqResolution() );
	}
PartialList *Analyzer_analyze(Analyzer *self,SampleVector const *vec,double srate){
		PartialList * partials = new PartialList();
		self->analyze( vec->begin(), vec->end(), srate );
		partials->splice( partials->end(), self->partials() );
		return partials;
	}

#include<BreakpointEnvelope.h>
using Loris::BreakpointEnvelope;

BreakpointEnvelope *BreakpointEnvelope_copy(BreakpointEnvelope *self){
		return new BreakpointEnvelope( *self );
	}

BreakpointEnvelope * BreakpointEnvelopeWithValue_( double initialValue )
{
	return new BreakpointEnvelope( initialValue );
}


#include<AiffFile.h>
using Loris::AiffFile;

SampleVector *AiffFile_samples(AiffFile *self){
		SampleVector * vec = new SampleVector( self->sampleFrames(), 0. );
		self->getSamples( vec->begin(), vec->end() );
		return vec;
	}

	#include<loris.h>


	#include<Dilator.h>
	#include <string>
	#include <vector>
	
	//	Helper function for dilate: 
	//
	//	convert a string into a vector of doubles,
	//	ignore any extraneous characters:
	static std::vector<double> strtovec( const std::string & s )
	{
		std::vector<double> v;
		std::string::size_type beg, end;
		const std::string numparts("1234567890+-.");
		beg = s.find_first_of( numparts );
		while ( beg != std::string::npos )
		{
			end = s.find_first_not_of( numparts, beg );
			if ( end == std::string::npos )
				end = s.length();
	
			double x = atof( s.c_str() + beg );
			v.push_back(x);
	
			beg = s.find_first_of( numparts, end );
		}
		return v;
	}

	void dilate_str( PartialList * partials, 
				 char * initial_times, char * target_times )
	{
		std::vector<double> ivec = strtovec( initial_times );
		std::vector<double> tvec = strtovec( target_times );
		
		Loris::debugger << ivec.size() << " initial points, " 
						<< tvec.size() << " target points" << Loris::endl;
			
		if ( ivec.size() != tvec.size() )
			Throw( Loris::InvalidArgument, "Invalid arguments to dilate(): there must be as many target points as initial points" );
				
		double * initial = ivec.begin();
		double * target = tvec.begin();
		int npts = ivec.size();
	
		//	USE THE PI INSTEAD!
			
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((double *) initial);
		ThrowIfNull((double *) target);
	
		Loris::notifier << "dilating " << partials->size() << " Partials" << Loris::endl;
		Loris::Dilator dil( initial, target, npts );
		dil.dilate( partials->begin(), partials->end() );
	}
	/*	Dilate Partials in a PartialList according to the given 
		initial and target time points. Partial envelopes are 
		stretched and compressed so that temporal features at
		the initial time points are aligned with the final time
		points. Time points are sorted, so Partial envelopes are 
		are only stretched and compressed, but breakpoints are not
		reordered. Duplicate time points are allowed. There must be
		the same number of initial and target time points.
		
		The time points are passed as strings; convert any native
		collection to a string representation, numerical elements
		will be extracted, other characters will be ignored.
	 */


	#include<SdifFile.h>
	PartialList * importSdif_( const char * path )
	{
		Loris::notifier << "importing Partials from " << path << Loris::endl;
		Loris::SdifFile imp( path );

		PartialList * partials = new PartialList();
		//	splice() can't throw, can it???
		partials->splice( partials->end(), imp.partials() );

		return partials;
	}


	#include<SpcFile.h>
	PartialList * importSpc_( const char * path )
	{
		Loris::notifier << "importing Partials from " << path << Loris::endl;
		Loris::SpcFile imp( path );

		PartialList * partials = new PartialList();
		//	splice() can't throw, can it???
		partials->splice( partials->end(), imp.partials() );

		return partials;
	}


	#include<Morpher.h>
	PartialList * morph_( const PartialList * src0, const PartialList * src1, 
						 const BreakpointEnvelope * ffreq, 
						 const BreakpointEnvelope * famp, 
						 const BreakpointEnvelope * fbw )
	{
		ThrowIfNull((PartialList *) src0);
		ThrowIfNull((PartialList *) src1);
		ThrowIfNull((BreakpointEnvelope *) ffreq);
		ThrowIfNull((BreakpointEnvelope *) famp);
		ThrowIfNull((BreakpointEnvelope *) fbw);

		Loris::notifier << "morphing " << src0->size() << " Partials with "
						<< src1->size() << " Partials" << Loris::endl;
					
		//	make a Morpher object and do it:
		Loris::Morpher m( *ffreq, *famp, *fbw );
		m.morph( src0->begin(), src0->end(), src1->begin(), src1->end() );
				
		//	splice the morphed Partials into a new PartialList:
		PartialList * dst = new PartialList();
		//	splice() can't throw, can it???
		dst->splice( dst->end(), m.partials() );
		return dst;
	}


	#include<Synthesizer.h>
	SampleVector * synthesize_( const PartialList * partials, double srate = 44100.0 )
	{
		ThrowIfNull((PartialList *) partials);

		Loris::notifier << "synthesizing " << partials->size() 
						<< " Partials at " << srate << " Hz" << Loris::endl;

		//	compute the duration:
		debugger << "computing duration..." << Loris::endl;
		double maxtime = 0.;
		PartialList::const_iterator it;
		for ( it = partials->begin(); it != partials->end(); ++it ) 
		{
			maxtime = std::max( maxtime, it->endTime() );
		}
		debugger << maxtime << " seconds" << Loris::endl;
		
		//	allocate a SampleVector to accomodate the fade-out at 
		//	the end of the latest Partial:
		const long nsamps = long( srate * ( maxtime + Partial::FadeTime() ) );	
		SampleVector * samples = new SampleVector( nsamps, 0. );
		
		//	synthesize:
		try
		{
			Loris::Synthesizer synth( srate, samples->begin(), samples->end() );
			for ( it = partials->begin(); it != partials->end(); ++it ) 
			{
				synth.synthesize( *it );
			}
		}
		catch(...)
		{
			delete samples;
			throw;
		}
		
		return samples;
	}


	#include<Sieve.h>


	void sift( PartialList * partials )
	{		
		
		ThrowIfNull((PartialList *) partials);

		Loris::notifier << "sifting " << partials->size() << " Partials" << Loris::endl;
		
		Loris::Sieve sieve( 0.0001 );
		sieve.sift( *partials );
	}
	/*	Eliminate overlapping Partials having the same label 
		(except zero). If any two partials with same label 
		overlap in time, keep only the longer of the two.
		Set the label of the shorter duration partial to zero.
		
	 */


	PartialList * extract_( PartialList * partials, long label )
	{
        ThrowIfNull((PartialList *) partials);

		PartialList * ret = new PartialList();
		try 
		{
			spliceByLabel( partials, label, ret );
		}
		catch(...)
		{
			delete ret;
			throw;
		}
		return ret;
	}


	const char * version( void )
	{
		static const char * vstr = LORIS_VERSION_STR;
		return vstr;
	}

#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_loris_perl_var::
class _wrap_loris_perl_var : public CPerlObj {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(pTHX_ SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}


#ifdef PERL_OBJECT
};
#endif

#ifdef __cplusplus
extern "C" {
#endif
XS(_wrap_new_PartialList) {
    PartialList *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_PartialList();");
    {
        try
        {
            result = (PartialList *)new_PartialList();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList);
    XSRETURN(argvi);
}


XS(_wrap_delete_PartialList) {
    PartialList *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_PartialList(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of delete_PartialList. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        try
        {
            delete_PartialList(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_PartialList_copy) {
    PartialList *arg1 ;
    PartialList *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialList_copy(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of PartialList_copy. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        try
        {
            result = (PartialList *)PartialList_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList);
    XSRETURN(argvi);
}


XS(_wrap_PartialList_timeSpan) {
    PartialList *arg1 ;
    double *arg2 ;
    double *arg3 ;
    double temp2 ;
    double temp3 ;
    int argvi = 0;
    dXSARGS;
    
    {
        arg2 = &temp2;
    }
    {
        arg3 = &temp3;
    }
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialList_timeSpan(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of PartialList_timeSpan. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        try
        {
            PartialList_timeSpan(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    {
        if (argvi >= items) {
            EXTEND(sp,1);
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi),(double) *(arg2));
        argvi++;
    }
    {
        if (argvi >= items) {
            EXTEND(sp,1);
        }
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi),(double) *(arg3));
        argvi++;
    }
    XSRETURN(argvi);
}


XS(_wrap_PartialList_clear) {
    PartialList *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialList_clear(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of PartialList_clear. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        try
        {
            (arg1)->clear();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_PartialList_size) {
    PartialList *arg1 ;
    unsigned long result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialList_size(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of PartialList_size. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        try
        {
            result = (unsigned long )(arg1)->size();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartialList_begin) {
    PartialList *arg1 ;
    SwigValueWrapper<PartialListIterator> result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialList_begin(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of PartialList_begin. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        try
        {
            result = (arg1)->begin();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultobj = new PartialListIterator (result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialListIterator);
    }
    XSRETURN(argvi);
}


XS(_wrap_PartialList_end) {
    PartialList *arg1 ;
    SwigValueWrapper<PartialListIterator> result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialList_end(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of PartialList_end. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        try
        {
            result = (arg1)->end();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultobj = new PartialListIterator (result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialListIterator);
    }
    XSRETURN(argvi);
}


XS(_wrap_PartialList_insert) {
    PartialList *arg1 ;
    PartialListIterator arg2 ;
    Partial *arg3 ;
    SwigValueWrapper<PartialListIterator> result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: PartialList_insert(self,position,partial);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of PartialList_insert. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        PartialListIterator * argp;
        if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_PartialListIterator) < 0) {
            croak("Type error in argument 2 of PartialList_insert. Expected %s", SWIGTYPE_p_PartialListIterator->name);	
        }
        arg2 = *argp;
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 3 of PartialList_insert. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    {
        try
        {
            result = (arg1)->insert(arg2,(Partial const &)*arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultobj = new PartialListIterator (result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialListIterator);
    }
    XSRETURN(argvi);
}


XS(_wrap_PartialList_erase) {
    PartialList *arg1 ;
    PartialListIterator arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartialList_erase(self,position);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of PartialList_erase. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        PartialListIterator * argp;
        if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_PartialListIterator) < 0) {
            croak("Type error in argument 2 of PartialList_erase. Expected %s", SWIGTYPE_p_PartialListIterator->name);	
        }
        arg2 = *argp;
    }
    {
        try
        {
            (arg1)->erase(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_PartialList_splice) {
    PartialList *arg1 ;
    PartialListIterator arg2 ;
    PartialList *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: PartialList_splice(self,position,list);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of PartialList_splice. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        PartialListIterator * argp;
        if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_PartialListIterator) < 0) {
            croak("Type error in argument 2 of PartialList_splice. Expected %s", SWIGTYPE_p_PartialListIterator->name);	
        }
        arg2 = *argp;
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 3 of PartialList_splice. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        try
        {
            (arg1)->splice(arg2,*arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_PartialListIterator_copy) {
    PartialListIterator *arg1 ;
    PartialListIterator *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialListIterator_copy(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialListIterator) < 0) {
            croak("Type error in argument 1 of PartialListIterator_copy. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        }
    }
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialListIterator);
    XSRETURN(argvi);
}


XS(_wrap_PartialListIterator_next) {
    PartialListIterator *arg1 ;
    PartialListIterator *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialListIterator_next(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialListIterator) < 0) {
            croak("Type error in argument 1 of PartialListIterator_next. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        }
    }
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_next(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialListIterator);
    XSRETURN(argvi);
}


XS(_wrap_PartialListIterator_prev) {
    PartialListIterator *arg1 ;
    PartialListIterator *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialListIterator_prev(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialListIterator) < 0) {
            croak("Type error in argument 1 of PartialListIterator_prev. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        }
    }
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_prev(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialListIterator);
    XSRETURN(argvi);
}


XS(_wrap_PartialListIterator_partial) {
    PartialListIterator *arg1 ;
    Partial *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialListIterator_partial(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialListIterator) < 0) {
            croak("Type error in argument 1 of PartialListIterator_partial. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        }
    }
    {
        try
        {
            result = (Partial *)PartialListIterator_partial(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Partial);
    XSRETURN(argvi);
}


XS(_wrap_PartialListIterator_equals) {
    PartialListIterator *arg1 ;
    PartialListIterator *arg2 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartialListIterator_equals(self,other);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialListIterator) < 0) {
            croak("Type error in argument 1 of PartialListIterator_equals. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialListIterator) < 0) {
            croak("Type error in argument 2 of PartialListIterator_equals. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        }
    }
    {
        try
        {
            result = (int )PartialListIterator_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartialListIterator_isInRange) {
    PartialListIterator *arg1 ;
    PartialListIterator *arg2 ;
    PartialListIterator *arg3 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: PartialListIterator_isInRange(self,begin,end);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialListIterator) < 0) {
            croak("Type error in argument 1 of PartialListIterator_isInRange. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialListIterator) < 0) {
            croak("Type error in argument 2 of PartialListIterator_isInRange. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_PartialListIterator) < 0) {
            croak("Type error in argument 3 of PartialListIterator_isInRange. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        }
    }
    {
        try
        {
            result = (int )PartialListIterator_isInRange(arg1,(PartialListIterator const *)arg2,(PartialListIterator const *)arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_PartialListIterator) {
    PartialListIterator *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_PartialListIterator();");
    {
        try
        {
            result = (PartialListIterator *)new PartialListIterator();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialListIterator);
    XSRETURN(argvi);
}


XS(_wrap_delete_PartialListIterator) {
    PartialListIterator *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_PartialListIterator(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialListIterator) < 0) {
            croak("Type error in argument 1 of delete_PartialListIterator. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        }
    }
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_new_Partial) {
    Partial *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_Partial();");
    {
        try
        {
            result = (Partial *)new Partial();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Partial);
    XSRETURN(argvi);
}


XS(_wrap_delete_Partial) {
    Partial *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_Partial(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of delete_Partial. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_Partial_label) {
    Partial *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_label(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_label. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    {
        try
        {
            result = (int )((Partial const *)arg1)->label();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_initialPhase) {
    Partial *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_initialPhase(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_initialPhase. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    {
        try
        {
            result = (double )((Partial const *)arg1)->initialPhase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_startTime) {
    Partial *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_startTime(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_startTime. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    {
        try
        {
            result = (double )((Partial const *)arg1)->startTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_endTime) {
    Partial *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_endTime(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_endTime. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    {
        try
        {
            result = (double )((Partial const *)arg1)->endTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_duration) {
    Partial *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_duration(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_duration. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    {
        try
        {
            result = (double )((Partial const *)arg1)->duration();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_numBreakpoints) {
    Partial *arg1 ;
    long result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_numBreakpoints(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_numBreakpoints. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    {
        try
        {
            result = (long )((Partial const *)arg1)->numBreakpoints();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_setLabel) {
    Partial *arg1 ;
    int arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_setLabel(self,l);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_setLabel. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    arg2 = (int ) SvIV(ST(1));
    {
        try
        {
            (arg1)->setLabel(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_Partial_begin) {
    Partial *arg1 ;
    SwigValueWrapper<PartialIterator> result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_begin(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_begin. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    {
        try
        {
            result = (arg1)->begin();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultobj = new PartialIterator (result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialIterator);
    }
    XSRETURN(argvi);
}


XS(_wrap_Partial_end) {
    Partial *arg1 ;
    SwigValueWrapper<PartialIterator> result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_end(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_end. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    {
        try
        {
            result = (arg1)->end();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultobj = new PartialIterator (result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialIterator);
    }
    XSRETURN(argvi);
}


XS(_wrap_Partial_insert) {
    Partial *arg1 ;
    double arg2 ;
    Breakpoint *arg3 ;
    SwigValueWrapper<PartialIterator> result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: Partial_insert(self,time,bp);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_insert. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_Breakpoint) < 0) {
            croak("Type error in argument 3 of Partial_insert. Expected %s", SWIGTYPE_p_Breakpoint->name);
        }
    }
    {
        try
        {
            result = (arg1)->insert(arg2,(Breakpoint const &)*arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultobj = new PartialIterator (result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialIterator);
    }
    XSRETURN(argvi);
}


XS(_wrap_Partial_findAfter) {
    Partial *arg1 ;
    double arg2 ;
    SwigValueWrapper<PartialIterator> result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_findAfter(self,time);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_findAfter. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            result = (arg1)->findAfter(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultobj = new PartialIterator (result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialIterator);
    }
    XSRETURN(argvi);
}


XS(_wrap_Partial_findNearest) {
    Partial *arg1 ;
    double arg2 ;
    SwigValueWrapper<PartialIterator> result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_findNearest(self,time);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_findNearest. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            result = (arg1)->findNearest(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultobj = new PartialIterator (result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_PartialIterator);
    }
    XSRETURN(argvi);
}


XS(_wrap_Partial_erase) {
    Partial *arg1 ;
    PartialIterator *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_erase(self,pos);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_erase. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialIterator) < 0) {
            croak("Type error in argument 2 of Partial_erase. Expected %s", SWIGTYPE_p_PartialIterator->name);
        }
    }
    {
        try
        {
            (arg1)->erase(*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_Partial_frequencyAt) {
    Partial *arg1 ;
    double arg2 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_frequencyAt(self,time);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_frequencyAt. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            result = (double )((Partial const *)arg1)->frequencyAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_amplitudeAt) {
    Partial *arg1 ;
    double arg2 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_amplitudeAt(self,time);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_amplitudeAt. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            result = (double )((Partial const *)arg1)->amplitudeAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_bandwidthAt) {
    Partial *arg1 ;
    double arg2 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_bandwidthAt(self,time);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_bandwidthAt. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            result = (double )((Partial const *)arg1)->bandwidthAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_phaseAt) {
    Partial *arg1 ;
    double arg2 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_phaseAt(self,time);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_phaseAt. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            result = (double )((Partial const *)arg1)->phaseAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_copy) {
    Partial *arg1 ;
    Partial *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_copy(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_copy. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    {
        try
        {
            result = (Partial *)Partial_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Partial);
    XSRETURN(argvi);
}


XS(_wrap_Partial_equals) {
    Partial *arg1 ;
    Partial *arg2 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_equals(self,other);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 1 of Partial_equals. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Partial) < 0) {
            croak("Type error in argument 2 of Partial_equals. Expected %s", SWIGTYPE_p_Partial->name);
        }
    }
    {
        try
        {
            result = (int )Partial_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartialIterator_time) {
    PartialIterator *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialIterator_time(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator) < 0) {
            croak("Type error in argument 1 of PartialIterator_time. Expected %s", SWIGTYPE_p_PartialIterator->name);
        }
    }
    {
        try
        {
            result = (double )((PartialIterator const *)arg1)->time();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_PartialIterator_breakpoint) {
    PartialIterator *arg1 ;
    Breakpoint *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialIterator_breakpoint(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator) < 0) {
            croak("Type error in argument 1 of PartialIterator_breakpoint. Expected %s", SWIGTYPE_p_PartialIterator->name);
        }
    }
    {
        try
        {
            result = (Breakpoint *)PartialIterator_breakpoint(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Breakpoint);
    XSRETURN(argvi);
}


XS(_wrap_PartialIterator_copy) {
    PartialIterator *arg1 ;
    PartialIterator *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialIterator_copy(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator) < 0) {
            croak("Type error in argument 1 of PartialIterator_copy. Expected %s", SWIGTYPE_p_PartialIterator->name);
        }
    }
    {
        try
        {
            result = (PartialIterator *)PartialIterator_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator);
    XSRETURN(argvi);
}


XS(_wrap_PartialIterator_next) {
    PartialIterator *arg1 ;
    PartialIterator *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialIterator_next(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator) < 0) {
            croak("Type error in argument 1 of PartialIterator_next. Expected %s", SWIGTYPE_p_PartialIterator->name);
        }
    }
    {
        try
        {
            result = (PartialIterator *)PartialIterator_next(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator);
    XSRETURN(argvi);
}


XS(_wrap_PartialIterator_prev) {
    PartialIterator *arg1 ;
    PartialIterator *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialIterator_prev(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator) < 0) {
            croak("Type error in argument 1 of PartialIterator_prev. Expected %s", SWIGTYPE_p_PartialIterator->name);
        }
    }
    {
        try
        {
            result = (PartialIterator *)PartialIterator_prev(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator);
    XSRETURN(argvi);
}


XS(_wrap_PartialIterator_equals) {
    PartialIterator *arg1 ;
    PartialIterator *arg2 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartialIterator_equals(self,other);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator) < 0) {
            croak("Type error in argument 1 of PartialIterator_equals. Expected %s", SWIGTYPE_p_PartialIterator->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialIterator) < 0) {
            croak("Type error in argument 2 of PartialIterator_equals. Expected %s", SWIGTYPE_p_PartialIterator->name);
        }
    }
    {
        try
        {
            result = (int )PartialIterator_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartialIterator_isInRange) {
    PartialIterator *arg1 ;
    PartialIterator *arg2 ;
    PartialIterator *arg3 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: PartialIterator_isInRange(self,begin,end);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator) < 0) {
            croak("Type error in argument 1 of PartialIterator_isInRange. Expected %s", SWIGTYPE_p_PartialIterator->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialIterator) < 0) {
            croak("Type error in argument 2 of PartialIterator_isInRange. Expected %s", SWIGTYPE_p_PartialIterator->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_PartialIterator) < 0) {
            croak("Type error in argument 3 of PartialIterator_isInRange. Expected %s", SWIGTYPE_p_PartialIterator->name);
        }
    }
    {
        try
        {
            result = (int )PartialIterator_isInRange(arg1,(PartialIterator const *)arg2,(PartialIterator const *)arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_PartialIterator) {
    PartialIterator *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_PartialIterator();");
    {
        try
        {
            result = (PartialIterator *)new PartialIterator();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator);
    XSRETURN(argvi);
}


XS(_wrap_delete_PartialIterator) {
    PartialIterator *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_PartialIterator(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialIterator) < 0) {
            croak("Type error in argument 1 of delete_PartialIterator. Expected %s", SWIGTYPE_p_PartialIterator->name);
        }
    }
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_new_Breakpoint) {
    double arg1 ;
    double arg2 ;
    double arg3 ;
    double arg4 = 0. ;
    Breakpoint *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 4)) 
    croak("Usage: new_Breakpoint(f,a,b,p);");
    arg1 = (double ) SvNV(ST(0));
    
    arg2 = (double ) SvNV(ST(1));
    
    arg3 = (double ) SvNV(ST(2));
    
    if (items > 3) {
        arg4 = (double ) SvNV(ST(3));
        
    }
    {
        try
        {
            result = (Breakpoint *)new Breakpoint(arg1,arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Breakpoint);
    XSRETURN(argvi);
}


XS(_wrap_delete_Breakpoint) {
    Breakpoint *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_Breakpoint(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint) < 0) {
            croak("Type error in argument 1 of delete_Breakpoint. Expected %s", SWIGTYPE_p_Breakpoint->name);
        }
    }
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_Breakpoint_frequency) {
    Breakpoint *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Breakpoint_frequency(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint) < 0) {
            croak("Type error in argument 1 of Breakpoint_frequency. Expected %s", SWIGTYPE_p_Breakpoint->name);
        }
    }
    {
        try
        {
            result = (double )(arg1)->frequency();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Breakpoint_amplitude) {
    Breakpoint *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Breakpoint_amplitude(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint) < 0) {
            croak("Type error in argument 1 of Breakpoint_amplitude. Expected %s", SWIGTYPE_p_Breakpoint->name);
        }
    }
    {
        try
        {
            result = (double )(arg1)->amplitude();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Breakpoint_bandwidth) {
    Breakpoint *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Breakpoint_bandwidth(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint) < 0) {
            croak("Type error in argument 1 of Breakpoint_bandwidth. Expected %s", SWIGTYPE_p_Breakpoint->name);
        }
    }
    {
        try
        {
            result = (double )(arg1)->bandwidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Breakpoint_phase) {
    Breakpoint *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Breakpoint_phase(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint) < 0) {
            croak("Type error in argument 1 of Breakpoint_phase. Expected %s", SWIGTYPE_p_Breakpoint->name);
        }
    }
    {
        try
        {
            result = (double )(arg1)->phase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Breakpoint_setFrequency) {
    Breakpoint *arg1 ;
    double arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Breakpoint_setFrequency(self,x);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint) < 0) {
            croak("Type error in argument 1 of Breakpoint_setFrequency. Expected %s", SWIGTYPE_p_Breakpoint->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            (arg1)->setFrequency(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_Breakpoint_setAmplitude) {
    Breakpoint *arg1 ;
    double arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Breakpoint_setAmplitude(self,x);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint) < 0) {
            croak("Type error in argument 1 of Breakpoint_setAmplitude. Expected %s", SWIGTYPE_p_Breakpoint->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            (arg1)->setAmplitude(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_Breakpoint_setBandwidth) {
    Breakpoint *arg1 ;
    double arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Breakpoint_setBandwidth(self,x);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint) < 0) {
            croak("Type error in argument 1 of Breakpoint_setBandwidth. Expected %s", SWIGTYPE_p_Breakpoint->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            (arg1)->setBandwidth(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_Breakpoint_setPhase) {
    Breakpoint *arg1 ;
    double arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Breakpoint_setPhase(self,x);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint) < 0) {
            croak("Type error in argument 1 of Breakpoint_setPhase. Expected %s", SWIGTYPE_p_Breakpoint->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            (arg1)->setPhase(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_Breakpoint_copy) {
    Breakpoint *arg1 ;
    Breakpoint *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Breakpoint_copy(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint) < 0) {
            croak("Type error in argument 1 of Breakpoint_copy. Expected %s", SWIGTYPE_p_Breakpoint->name);
        }
    }
    {
        try
        {
            result = (Breakpoint *)Breakpoint_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Breakpoint);
    XSRETURN(argvi);
}


XS(_wrap_Breakpoint_equals) {
    Breakpoint *arg1 ;
    Breakpoint *arg2 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Breakpoint_equals(self,other);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Breakpoint) < 0) {
            croak("Type error in argument 1 of Breakpoint_equals. Expected %s", SWIGTYPE_p_Breakpoint->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Breakpoint) < 0) {
            croak("Type error in argument 2 of Breakpoint_equals. Expected %s", SWIGTYPE_p_Breakpoint->name);
        }
    }
    {
        try
        {
            result = (int )Breakpoint_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_SampleVector) {
    unsigned long arg1 = 0 ;
    SampleVector *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 1)) 
    croak("Usage: new_SampleVector(size);");
    if (items > 0) {
        arg1 = (unsigned long ) SvIV(ST(0));
    }
    {
        try
        {
            result = (SampleVector *)new SampleVector(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SampleVector);
    XSRETURN(argvi);
}


XS(_wrap_delete_SampleVector) {
    SampleVector *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_SampleVector(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SampleVector) < 0) {
            croak("Type error in argument 1 of delete_SampleVector. Expected %s", SWIGTYPE_p_SampleVector->name);
        }
    }
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_SampleVector_size) {
    SampleVector *arg1 ;
    unsigned long result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: SampleVector_size(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SampleVector) < 0) {
            croak("Type error in argument 1 of SampleVector_size. Expected %s", SWIGTYPE_p_SampleVector->name);
        }
    }
    {
        try
        {
            result = (unsigned long )(arg1)->size();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}


XS(_wrap_SampleVector_resize) {
    SampleVector *arg1 ;
    unsigned long arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: SampleVector_resize(self,size);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SampleVector) < 0) {
            croak("Type error in argument 1 of SampleVector_resize. Expected %s", SWIGTYPE_p_SampleVector->name);
        }
    }
    arg2 = (unsigned long ) SvIV(ST(1));
    {
        try
        {
            (arg1)->resize(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_SampleVector_clear) {
    SampleVector *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: SampleVector_clear(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SampleVector) < 0) {
            croak("Type error in argument 1 of SampleVector_clear. Expected %s", SWIGTYPE_p_SampleVector->name);
        }
    }
    {
        try
        {
            (arg1)->clear();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_SampleVector_copy) {
    SampleVector *arg1 ;
    SampleVector *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: SampleVector_copy(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SampleVector) < 0) {
            croak("Type error in argument 1 of SampleVector_copy. Expected %s", SWIGTYPE_p_SampleVector->name);
        }
    }
    {
        try
        {
            result = (SampleVector *)SampleVector_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SampleVector);
    XSRETURN(argvi);
}


XS(_wrap_SampleVector_getAt) {
    SampleVector *arg1 ;
    unsigned long arg2 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: SampleVector_getAt(self,idx);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SampleVector) < 0) {
            croak("Type error in argument 1 of SampleVector_getAt. Expected %s", SWIGTYPE_p_SampleVector->name);
        }
    }
    arg2 = (unsigned long ) SvIV(ST(1));
    {
        try
        {
            result = (double )SampleVector_getAt(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_SampleVector_setAt) {
    SampleVector *arg1 ;
    unsigned long arg2 ;
    double arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: SampleVector_setAt(self,idx,x);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SampleVector) < 0) {
            croak("Type error in argument 1 of SampleVector_setAt. Expected %s", SWIGTYPE_p_SampleVector->name);
        }
    }
    arg2 = (unsigned long ) SvIV(ST(1));
    arg3 = (double ) SvNV(ST(2));
    
    {
        try
        {
            SampleVector_setAt(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_delete_Analyzer) {
    Analyzer *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_Analyzer(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of delete_Analyzer. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_new_Analyzer) {
    double arg1 ;
    double arg2 = 0. ;
    Analyzer *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 2)) 
    croak("Usage: new_Analyzer(resolutionHz,windowWidthHz);");
    arg1 = (double ) SvNV(ST(0));
    
    if (items > 1) {
        arg2 = (double ) SvNV(ST(1));
        
    }
    {
        try
        {
            result = (Analyzer *)new_Analyzer(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Analyzer);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_copy) {
    Analyzer *arg1 ;
    Analyzer *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_copy(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_copy. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    {
        try
        {
            result = (Analyzer *)Analyzer_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Analyzer);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_analyze) {
    Analyzer *arg1 ;
    SampleVector *arg2 ;
    double arg3 ;
    PartialList *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: Analyzer_analyze(self,vec,srate);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_analyze. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SampleVector) < 0) {
            croak("Type error in argument 2 of Analyzer_analyze. Expected %s", SWIGTYPE_p_SampleVector->name);
        }
    }
    arg3 = (double ) SvNV(ST(2));
    
    {
        try
        {
            result = (PartialList *)Analyzer_analyze(arg1,(SampleVector const *)arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_freqResolution) {
    Analyzer *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_freqResolution(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_freqResolution. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->freqResolution();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_ampFloor) {
    Analyzer *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_ampFloor(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_ampFloor. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->ampFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_windowWidth) {
    Analyzer *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_windowWidth(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_windowWidth. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->windowWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_freqFloor) {
    Analyzer *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_freqFloor(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_freqFloor. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->freqFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_hopTime) {
    Analyzer *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_hopTime(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_hopTime. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->hopTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_freqDrift) {
    Analyzer *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_freqDrift(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_freqDrift. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->freqDrift();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_cropTime) {
    Analyzer *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_cropTime(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_cropTime. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->cropTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_bwRegionWidth) {
    Analyzer *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_bwRegionWidth(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_bwRegionWidth. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    {
        try
        {
            result = (double )((Analyzer const *)arg1)->bwRegionWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_setFreqResolution) {
    Analyzer *arg1 ;
    double arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setFreqResolution(self,x);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_setFreqResolution. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            (arg1)->setFreqResolution(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_setAmpFloor) {
    Analyzer *arg1 ;
    double arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setAmpFloor(self,x);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_setAmpFloor. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            (arg1)->setAmpFloor(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_setWindowWidth) {
    Analyzer *arg1 ;
    double arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setWindowWidth(self,x);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_setWindowWidth. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            (arg1)->setWindowWidth(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_setFreqFloor) {
    Analyzer *arg1 ;
    double arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setFreqFloor(self,x);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_setFreqFloor. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            (arg1)->setFreqFloor(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_setFreqDrift) {
    Analyzer *arg1 ;
    double arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setFreqDrift(self,x);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_setFreqDrift. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            (arg1)->setFreqDrift(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_setHopTime) {
    Analyzer *arg1 ;
    double arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setHopTime(self,x);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_setHopTime. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            (arg1)->setHopTime(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_setCropTime) {
    Analyzer *arg1 ;
    double arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setCropTime(self,x);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_setCropTime. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            (arg1)->setCropTime(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_setBwRegionWidth) {
    Analyzer *arg1 ;
    double arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setBwRegionWidth(self,x);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Analyzer) < 0) {
            croak("Type error in argument 1 of Analyzer_setBwRegionWidth. Expected %s", SWIGTYPE_p_Analyzer->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            (arg1)->setBwRegionWidth(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_new_BreakpointEnvelope) {
    BreakpointEnvelope *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_BreakpointEnvelope();");
    {
        try
        {
            result = (BreakpointEnvelope *)new BreakpointEnvelope();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BreakpointEnvelope);
    XSRETURN(argvi);
}


XS(_wrap_delete_BreakpointEnvelope) {
    BreakpointEnvelope *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_BreakpointEnvelope(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointEnvelope) < 0) {
            croak("Type error in argument 1 of delete_BreakpointEnvelope. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        }
    }
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_BreakpointEnvelope_copy) {
    BreakpointEnvelope *arg1 ;
    BreakpointEnvelope *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BreakpointEnvelope_copy(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointEnvelope) < 0) {
            croak("Type error in argument 1 of BreakpointEnvelope_copy. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        }
    }
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelope_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BreakpointEnvelope);
    XSRETURN(argvi);
}


XS(_wrap_BreakpointEnvelope_valueAt) {
    BreakpointEnvelope *arg1 ;
    double arg2 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BreakpointEnvelope_valueAt(self,x);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointEnvelope) < 0) {
            croak("Type error in argument 1 of BreakpointEnvelope_valueAt. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            result = (double )((BreakpointEnvelope const *)arg1)->valueAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BreakpointEnvelope_insertBreakpoint) {
    BreakpointEnvelope *arg1 ;
    double arg2 ;
    double arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: BreakpointEnvelope_insertBreakpoint(self,time,value);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_BreakpointEnvelope) < 0) {
            croak("Type error in argument 1 of BreakpointEnvelope_insertBreakpoint. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    arg3 = (double ) SvNV(ST(2));
    
    {
        try
        {
            (arg1)->insertBreakpoint(arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_BreakpointEnvelopeWithValue) {
    double arg1 ;
    BreakpointEnvelope *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BreakpointEnvelopeWithValue(initialValue);");
    arg1 = (double ) SvNV(ST(0));
    
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelopeWithValue_(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BreakpointEnvelope);
    XSRETURN(argvi);
}


XS(_wrap_new_AiffFile) {
    char *arg1 ;
    AiffFile *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: new_AiffFile(filename);");
    if (!SvOK((SV*) ST(0))) arg1 = 0;
    else arg1 = (char *) SvPV(ST(0), PL_na);
    {
        try
        {
            result = (AiffFile *)new AiffFile((char const *)arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_AiffFile);
    XSRETURN(argvi);
}


XS(_wrap_delete_AiffFile) {
    AiffFile *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_AiffFile(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile) < 0) {
            croak("Type error in argument 1 of delete_AiffFile. Expected %s", SWIGTYPE_p_AiffFile->name);
        }
    }
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_AiffFile_channels) {
    AiffFile *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: AiffFile_channels(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile) < 0) {
            croak("Type error in argument 1 of AiffFile_channels. Expected %s", SWIGTYPE_p_AiffFile->name);
        }
    }
    {
        try
        {
            result = (int )((AiffFile const *)arg1)->channels();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}


XS(_wrap_AiffFile_sampleFrames) {
    AiffFile *arg1 ;
    unsigned long result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: AiffFile_sampleFrames(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile) < 0) {
            croak("Type error in argument 1 of AiffFile_sampleFrames. Expected %s", SWIGTYPE_p_AiffFile->name);
        }
    }
    {
        try
        {
            result = (unsigned long )((AiffFile const *)arg1)->sampleFrames();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}


XS(_wrap_AiffFile_sampleRate) {
    AiffFile *arg1 ;
    double result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: AiffFile_sampleRate(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile) < 0) {
            croak("Type error in argument 1 of AiffFile_sampleRate. Expected %s", SWIGTYPE_p_AiffFile->name);
        }
    }
    {
        try
        {
            result = (double )((AiffFile const *)arg1)->sampleRate();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_AiffFile_sampleSize) {
    AiffFile *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: AiffFile_sampleSize(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile) < 0) {
            croak("Type error in argument 1 of AiffFile_sampleSize. Expected %s", SWIGTYPE_p_AiffFile->name);
        }
    }
    {
        try
        {
            result = (int )((AiffFile const *)arg1)->sampleSize();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}


XS(_wrap_AiffFile_samples) {
    AiffFile *arg1 ;
    SampleVector *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: AiffFile_samples(self);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AiffFile) < 0) {
            croak("Type error in argument 1 of AiffFile_samples. Expected %s", SWIGTYPE_p_AiffFile->name);
        }
    }
    {
        try
        {
            result = (SampleVector *)AiffFile_samples(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SampleVector);
    XSRETURN(argvi);
}


XS(_wrap_channelize) {
    PartialList *arg1 ;
    BreakpointEnvelope *arg2 ;
    int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: channelize(partials,refFreqEnvelope,refLabel);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of channelize. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_BreakpointEnvelope) < 0) {
            croak("Type error in argument 2 of channelize. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        }
    }
    arg3 = (int ) SvIV(ST(2));
    {
        try
        {
            channelize(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_createFreqReference) {
    PartialList *arg1 ;
    double arg2 ;
    double arg3 ;
    BreakpointEnvelope *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: createFreqReference(partials,minFreq,maxFreq);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of createFreqReference. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    arg3 = (double ) SvNV(ST(2));
    
    {
        try
        {
            result = (BreakpointEnvelope *)createFreqReference(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BreakpointEnvelope);
    XSRETURN(argvi);
}


XS(_wrap_dilate) {
    PartialList *arg1 ;
    char *arg2 ;
    char *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: dilate(partials,initial_times,target_times);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of dilate. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    if (!SvOK((SV*) ST(1))) arg2 = 0;
    else arg2 = (char *) SvPV(ST(1), PL_na);
    if (!SvOK((SV*) ST(2))) arg3 = 0;
    else arg3 = (char *) SvPV(ST(2), PL_na);
    {
        try
        {
            dilate_str(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_distill) {
    PartialList *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: distill(partials);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of distill. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        try
        {
            distill(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_exportAiff) {
    char *arg1 ;
    SampleVector *arg2 ;
    double arg3 = 44100.0 ;
    int arg4 = 1 ;
    int arg5 = 16 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 5)) 
    croak("Usage: exportAiff(path,samples,samplerate,nchannels,bitsPerSamp);");
    if (!SvOK((SV*) ST(0))) arg1 = 0;
    else arg1 = (char *) SvPV(ST(0), PL_na);
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SampleVector) < 0) {
            croak("Type error in argument 2 of exportAiff. Expected %s", SWIGTYPE_p_SampleVector->name);
        }
    }
    if (items > 2) {
        arg3 = (double ) SvNV(ST(2));
        
    }
    if (items > 3) {
        arg4 = (int ) SvIV(ST(3));
    }
    if (items > 4) {
        arg5 = (int ) SvIV(ST(4));
    }
    {
        try
        {
            exportAiff((char const *)arg1,arg2,arg3,arg4,arg5);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_exportSdif) {
    char *arg1 ;
    PartialList *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: exportSdif(path,partials);");
    if (!SvOK((SV*) ST(0))) arg1 = 0;
    else arg1 = (char *) SvPV(ST(0), PL_na);
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 2 of exportSdif. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        try
        {
            exportSdif((char const *)arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_exportSpc) {
    char *arg1 ;
    PartialList *arg2 ;
    double arg3 ;
    int arg4 = true ;
    double arg5 = 0. ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 5)) 
    croak("Usage: exportSpc(path,partials,midiPitch,enhanced,endApproachTime);");
    if (!SvOK((SV*) ST(0))) arg1 = 0;
    else arg1 = (char *) SvPV(ST(0), PL_na);
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 2 of exportSpc. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    arg3 = (double ) SvNV(ST(2));
    
    if (items > 3) {
        arg4 = (int ) SvIV(ST(3));
    }
    if (items > 4) {
        arg5 = (double ) SvNV(ST(4));
        
    }
    {
        try
        {
            exportSpc((char const *)arg1,arg2,arg3,arg4,arg5);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_importSdif) {
    char *arg1 ;
    PartialList *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: importSdif(path);");
    if (!SvOK((SV*) ST(0))) arg1 = 0;
    else arg1 = (char *) SvPV(ST(0), PL_na);
    {
        try
        {
            result = (PartialList *)importSdif_((char const *)arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList);
    XSRETURN(argvi);
}


XS(_wrap_importSpc) {
    char *arg1 ;
    PartialList *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: importSpc(path);");
    if (!SvOK((SV*) ST(0))) arg1 = 0;
    else arg1 = (char *) SvPV(ST(0), PL_na);
    {
        try
        {
            result = (PartialList *)importSpc_((char const *)arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList);
    XSRETURN(argvi);
}


XS(_wrap_morph) {
    PartialList *arg1 ;
    PartialList *arg2 ;
    BreakpointEnvelope *arg3 ;
    BreakpointEnvelope *arg4 ;
    BreakpointEnvelope *arg5 ;
    PartialList *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) 
    croak("Usage: morph(src0,src1,ffreq,famp,fbw);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of morph. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 2 of morph. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_BreakpointEnvelope) < 0) {
            croak("Type error in argument 3 of morph. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_BreakpointEnvelope) < 0) {
            croak("Type error in argument 4 of morph. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_BreakpointEnvelope) < 0) {
            croak("Type error in argument 5 of morph. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        }
    }
    {
        try
        {
            result = (PartialList *)morph_((PartialList const *)arg1,(PartialList const *)arg2,(BreakpointEnvelope const *)arg3,(BreakpointEnvelope const *)arg4,(BreakpointEnvelope const *)arg5);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList);
    XSRETURN(argvi);
}


XS(_wrap_synthesize) {
    PartialList *arg1 ;
    double arg2 ;
    SampleVector *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: synthesize(partials,srate);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of synthesize. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    arg2 = (double ) SvNV(ST(1));
    
    {
        try
        {
            result = (SampleVector *)synthesize_((PartialList const *)arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SampleVector);
    XSRETURN(argvi);
}


XS(_wrap_sift) {
    PartialList *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: sift(partials);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of sift. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        try
        {
            sift(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_extractLabeled) {
    PartialList *arg1 ;
    long arg2 ;
    PartialList *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: extractLabeled(partials,label);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of extractLabeled. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    arg2 = (long ) SvIV(ST(1));
    {
        try
        {
            result = (PartialList *)extract_(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList);
    XSRETURN(argvi);
}


XS(_wrap_scaleAmp) {
    PartialList *arg1 ;
    BreakpointEnvelope *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: scaleAmp(partials,ampEnv);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of scaleAmp. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_BreakpointEnvelope) < 0) {
            croak("Type error in argument 2 of scaleAmp. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        }
    }
    {
        try
        {
            scaleAmp(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_scaleNoiseRatio) {
    PartialList *arg1 ;
    BreakpointEnvelope *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: scaleNoiseRatio(partials,noiseEnv);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of scaleNoiseRatio. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_BreakpointEnvelope) < 0) {
            croak("Type error in argument 2 of scaleNoiseRatio. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        }
    }
    {
        try
        {
            scaleNoiseRatio(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_shiftPitch) {
    PartialList *arg1 ;
    BreakpointEnvelope *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: shiftPitch(partials,pitchEnv);");
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PartialList) < 0) {
            croak("Type error in argument 1 of shiftPitch. Expected %s", SWIGTYPE_p_PartialList->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_BreakpointEnvelope) < 0) {
            croak("Type error in argument 2 of shiftPitch. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        }
    }
    {
        try
        {
            shiftPitch(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    
    XSRETURN(argvi);
}


XS(_wrap_version) {
    char *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: version();");
    {
        try
        {
            result = (char *)version();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++), (char *) result);
    XSRETURN(argvi);
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_Partial[] = {{"_p_Partial", 0, "Partial *"},{"_p_Partial"},{0}};
static swig_type_info _swigt__p_PartialList[] = {{"_p_PartialList", 0, "PartialList *"},{"_p_PartialList"},{0}};
static swig_type_info _swigt__p_SampleVector[] = {{"_p_SampleVector", 0, "SampleVector *"},{"_p_SampleVector"},{0}};
static swig_type_info _swigt__p_AiffFile[] = {{"_p_AiffFile", 0, "AiffFile *"},{"_p_AiffFile"},{0}};
static swig_type_info _swigt__p_Analyzer[] = {{"_p_Analyzer", 0, "Analyzer *"},{"_p_Analyzer"},{0}};
static swig_type_info _swigt__p_double[] = {{"_p_double", 0, "double *"},{"_p_double"},{0}};
static swig_type_info _swigt__p_PartialListIterator[] = {{"_p_PartialListIterator", 0, "PartialListIterator *"},{"_p_PartialListIterator"},{0}};
static swig_type_info _swigt__p_PartialIterator[] = {{"_p_PartialIterator", 0, "PartialIterator *"},{"_p_PartialIterator"},{0}};
static swig_type_info _swigt__p_Breakpoint[] = {{"_p_Breakpoint", 0, "Breakpoint *"},{"_p_Breakpoint"},{0}};
static swig_type_info _swigt__p_BreakpointEnvelope[] = {{"_p_BreakpointEnvelope", 0, "BreakpointEnvelope *"},{"_p_BreakpointEnvelope"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_Partial, 
_swigt__p_PartialList, 
_swigt__p_SampleVector, 
_swigt__p_AiffFile, 
_swigt__p_Analyzer, 
_swigt__p_double, 
_swigt__p_PartialListIterator, 
_swigt__p_PartialIterator, 
_swigt__p_Breakpoint, 
_swigt__p_BreakpointEnvelope, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_constant_info swig_constants[] = {
{0}
};
#ifdef __cplusplus
}
#endif
static swig_variable_info swig_variables[] = {
{0}
};
static swig_command_info swig_commands[] = {
{"loris_perl::new_PartialList", _wrap_new_PartialList},
{"loris_perl::delete_PartialList", _wrap_delete_PartialList},
{"loris_perl::PartialList_copy", _wrap_PartialList_copy},
{"loris_perl::PartialList_timeSpan", _wrap_PartialList_timeSpan},
{"loris_perl::PartialList_clear", _wrap_PartialList_clear},
{"loris_perl::PartialList_size", _wrap_PartialList_size},
{"loris_perl::PartialList_begin", _wrap_PartialList_begin},
{"loris_perl::PartialList_end", _wrap_PartialList_end},
{"loris_perl::PartialList_insert", _wrap_PartialList_insert},
{"loris_perl::PartialList_erase", _wrap_PartialList_erase},
{"loris_perl::PartialList_splice", _wrap_PartialList_splice},
{"loris_perl::PartialListIterator_copy", _wrap_PartialListIterator_copy},
{"loris_perl::PartialListIterator_next", _wrap_PartialListIterator_next},
{"loris_perl::PartialListIterator_prev", _wrap_PartialListIterator_prev},
{"loris_perl::PartialListIterator_partial", _wrap_PartialListIterator_partial},
{"loris_perl::PartialListIterator_equals", _wrap_PartialListIterator_equals},
{"loris_perl::PartialListIterator_isInRange", _wrap_PartialListIterator_isInRange},
{"loris_perl::new_PartialListIterator", _wrap_new_PartialListIterator},
{"loris_perl::delete_PartialListIterator", _wrap_delete_PartialListIterator},
{"loris_perl::new_Partial", _wrap_new_Partial},
{"loris_perl::delete_Partial", _wrap_delete_Partial},
{"loris_perl::Partial_label", _wrap_Partial_label},
{"loris_perl::Partial_initialPhase", _wrap_Partial_initialPhase},
{"loris_perl::Partial_startTime", _wrap_Partial_startTime},
{"loris_perl::Partial_endTime", _wrap_Partial_endTime},
{"loris_perl::Partial_duration", _wrap_Partial_duration},
{"loris_perl::Partial_numBreakpoints", _wrap_Partial_numBreakpoints},
{"loris_perl::Partial_setLabel", _wrap_Partial_setLabel},
{"loris_perl::Partial_begin", _wrap_Partial_begin},
{"loris_perl::Partial_end", _wrap_Partial_end},
{"loris_perl::Partial_insert", _wrap_Partial_insert},
{"loris_perl::Partial_findAfter", _wrap_Partial_findAfter},
{"loris_perl::Partial_findNearest", _wrap_Partial_findNearest},
{"loris_perl::Partial_erase", _wrap_Partial_erase},
{"loris_perl::Partial_frequencyAt", _wrap_Partial_frequencyAt},
{"loris_perl::Partial_amplitudeAt", _wrap_Partial_amplitudeAt},
{"loris_perl::Partial_bandwidthAt", _wrap_Partial_bandwidthAt},
{"loris_perl::Partial_phaseAt", _wrap_Partial_phaseAt},
{"loris_perl::Partial_copy", _wrap_Partial_copy},
{"loris_perl::Partial_equals", _wrap_Partial_equals},
{"loris_perl::PartialIterator_time", _wrap_PartialIterator_time},
{"loris_perl::PartialIterator_breakpoint", _wrap_PartialIterator_breakpoint},
{"loris_perl::PartialIterator_copy", _wrap_PartialIterator_copy},
{"loris_perl::PartialIterator_next", _wrap_PartialIterator_next},
{"loris_perl::PartialIterator_prev", _wrap_PartialIterator_prev},
{"loris_perl::PartialIterator_equals", _wrap_PartialIterator_equals},
{"loris_perl::PartialIterator_isInRange", _wrap_PartialIterator_isInRange},
{"loris_perl::new_PartialIterator", _wrap_new_PartialIterator},
{"loris_perl::delete_PartialIterator", _wrap_delete_PartialIterator},
{"loris_perl::new_Breakpoint", _wrap_new_Breakpoint},
{"loris_perl::delete_Breakpoint", _wrap_delete_Breakpoint},
{"loris_perl::Breakpoint_frequency", _wrap_Breakpoint_frequency},
{"loris_perl::Breakpoint_amplitude", _wrap_Breakpoint_amplitude},
{"loris_perl::Breakpoint_bandwidth", _wrap_Breakpoint_bandwidth},
{"loris_perl::Breakpoint_phase", _wrap_Breakpoint_phase},
{"loris_perl::Breakpoint_setFrequency", _wrap_Breakpoint_setFrequency},
{"loris_perl::Breakpoint_setAmplitude", _wrap_Breakpoint_setAmplitude},
{"loris_perl::Breakpoint_setBandwidth", _wrap_Breakpoint_setBandwidth},
{"loris_perl::Breakpoint_setPhase", _wrap_Breakpoint_setPhase},
{"loris_perl::Breakpoint_copy", _wrap_Breakpoint_copy},
{"loris_perl::Breakpoint_equals", _wrap_Breakpoint_equals},
{"loris_perl::new_SampleVector", _wrap_new_SampleVector},
{"loris_perl::delete_SampleVector", _wrap_delete_SampleVector},
{"loris_perl::SampleVector_size", _wrap_SampleVector_size},
{"loris_perl::SampleVector_resize", _wrap_SampleVector_resize},
{"loris_perl::SampleVector_clear", _wrap_SampleVector_clear},
{"loris_perl::SampleVector_copy", _wrap_SampleVector_copy},
{"loris_perl::SampleVector_getAt", _wrap_SampleVector_getAt},
{"loris_perl::SampleVector_setAt", _wrap_SampleVector_setAt},
{"loris_perl::delete_Analyzer", _wrap_delete_Analyzer},
{"loris_perl::new_Analyzer", _wrap_new_Analyzer},
{"loris_perl::Analyzer_copy", _wrap_Analyzer_copy},
{"loris_perl::Analyzer_analyze", _wrap_Analyzer_analyze},
{"loris_perl::Analyzer_freqResolution", _wrap_Analyzer_freqResolution},
{"loris_perl::Analyzer_ampFloor", _wrap_Analyzer_ampFloor},
{"loris_perl::Analyzer_windowWidth", _wrap_Analyzer_windowWidth},
{"loris_perl::Analyzer_freqFloor", _wrap_Analyzer_freqFloor},
{"loris_perl::Analyzer_hopTime", _wrap_Analyzer_hopTime},
{"loris_perl::Analyzer_freqDrift", _wrap_Analyzer_freqDrift},
{"loris_perl::Analyzer_cropTime", _wrap_Analyzer_cropTime},
{"loris_perl::Analyzer_bwRegionWidth", _wrap_Analyzer_bwRegionWidth},
{"loris_perl::Analyzer_setFreqResolution", _wrap_Analyzer_setFreqResolution},
{"loris_perl::Analyzer_setAmpFloor", _wrap_Analyzer_setAmpFloor},
{"loris_perl::Analyzer_setWindowWidth", _wrap_Analyzer_setWindowWidth},
{"loris_perl::Analyzer_setFreqFloor", _wrap_Analyzer_setFreqFloor},
{"loris_perl::Analyzer_setFreqDrift", _wrap_Analyzer_setFreqDrift},
{"loris_perl::Analyzer_setHopTime", _wrap_Analyzer_setHopTime},
{"loris_perl::Analyzer_setCropTime", _wrap_Analyzer_setCropTime},
{"loris_perl::Analyzer_setBwRegionWidth", _wrap_Analyzer_setBwRegionWidth},
{"loris_perl::new_BreakpointEnvelope", _wrap_new_BreakpointEnvelope},
{"loris_perl::delete_BreakpointEnvelope", _wrap_delete_BreakpointEnvelope},
{"loris_perl::BreakpointEnvelope_copy", _wrap_BreakpointEnvelope_copy},
{"loris_perl::BreakpointEnvelope_valueAt", _wrap_BreakpointEnvelope_valueAt},
{"loris_perl::BreakpointEnvelope_insertBreakpoint", _wrap_BreakpointEnvelope_insertBreakpoint},
{"loris_perl::BreakpointEnvelopeWithValue", _wrap_BreakpointEnvelopeWithValue},
{"loris_perl::new_AiffFile", _wrap_new_AiffFile},
{"loris_perl::delete_AiffFile", _wrap_delete_AiffFile},
{"loris_perl::AiffFile_channels", _wrap_AiffFile_channels},
{"loris_perl::AiffFile_sampleFrames", _wrap_AiffFile_sampleFrames},
{"loris_perl::AiffFile_sampleRate", _wrap_AiffFile_sampleRate},
{"loris_perl::AiffFile_sampleSize", _wrap_AiffFile_sampleSize},
{"loris_perl::AiffFile_samples", _wrap_AiffFile_samples},
{"loris_perl::channelize", _wrap_channelize},
{"loris_perl::createFreqReference", _wrap_createFreqReference},
{"loris_perl::dilate", _wrap_dilate},
{"loris_perl::distill", _wrap_distill},
{"loris_perl::exportAiff", _wrap_exportAiff},
{"loris_perl::exportSdif", _wrap_exportSdif},
{"loris_perl::exportSpc", _wrap_exportSpc},
{"loris_perl::importSdif", _wrap_importSdif},
{"loris_perl::importSpc", _wrap_importSpc},
{"loris_perl::morph", _wrap_morph},
{"loris_perl::synthesize", _wrap_synthesize},
{"loris_perl::sift", _wrap_sift},
{"loris_perl::extractLabeled", _wrap_extractLabeled},
{"loris_perl::scaleAmp", _wrap_scaleAmp},
{"loris_perl::scaleNoiseRatio", _wrap_scaleNoiseRatio},
{"loris_perl::shiftPitch", _wrap_shiftPitch},
{"loris_perl::version", _wrap_version},
{0,0}
};

#ifdef __cplusplus
extern "C"
#endif

XS(SWIG_init) {
    dXSARGS;
    int i;
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
    }
    
    /* Install commands */
    for (i = 0; swig_commands[i].name; i++) {
        newXS((char*) swig_commands[i].name,swig_commands[i].wrapper, (char*)__FILE__);
    }
    
    /* Install variables */
    for (i = 0; swig_variables[i].name; i++) {
        SV *sv;
        sv = perl_get_sv((char*) swig_variables[i].name, TRUE | 0x2);
        sv_setiv(sv, (IV) 0);
        swig_create_magic(sv, (char *) swig_variables[i].name, swig_variables[i].set, swig_variables[i].get);
    }
    
    /* Install constant */
    for (i = 0; swig_constants[i].type; i++) {
        SV *sv;
        sv = perl_get_sv((char*)swig_constants[i].name, TRUE | 0x2);
        switch(swig_constants[i].type) {
            case SWIG_INT:
            sv_setiv(sv, (IV) swig_constants[i].lvalue);
            break;
            case SWIG_FLOAT:
            sv_setnv(sv, (double) swig_constants[i].dvalue);
            break;
            case SWIG_STRING:
            sv_setpv(sv, (char *) swig_constants[i].pvalue);
            break;
            case SWIG_POINTER:
            SWIG_MakePtr(sv, swig_constants[i].pvalue, *(swig_constants[i].ptype));
            break;
            case SWIG_BINARY:
            /*      obj = SWIG_NewPackedObj(swig_constants[i].pvalue, swig_constants[i].lvalue, *(swig_constants[i].ptype)); */
            break;
            default:
            break;
        }
        SvREADONLY_on(sv);
    }
    
    
    Loris::setNotifierHandler( printf_notifier );
    Loris::setDebuggerHandler( printf_notifier );
    
    ST(0) = &PL_sv_yes;
    XSRETURN(1);
}

