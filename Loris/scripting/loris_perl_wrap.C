/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3u-20010615-1424 (Alpha 5)
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#       endif
#endif
#else
#       define SWIGEXPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct swig_type_info {
  char  *name;                 
  void *(*converter)(void *);
  char  *str;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE
SWIGEXPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGEXPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGEXPORT(void *) SWIG_TypeCast(swig_type_info *, void *);
#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  while (s) {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  }
  return 0;
}

/* Cast a pointer (needed for C++ inheritance */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(void *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

#endif

#ifdef __cplusplus
}
#endif



/* -----------------------------------------------------------------------------
 * perl5.swg
 *
 * Perl5 runtime library
 * $Header$
 * ----------------------------------------------------------------------------- */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
/* Needed on some windows machines---since MS plays funny
   games with the header files under C++ */
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* Get rid of free and malloc defined by perl */
#undef free
#undef malloc

#include <string.h>
#ifdef __cplusplus
}
#endif

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerlObj *pPerl = (CPerlObj *) this;
#define MAGIC_CAST   (int (CPerlObj::*)(SV *, MAGIC *))
#define SWIGCLASS_STATIC 
#else
#define MAGIC_PPERL
#define MAGIC_CAST
#define SWIGCLASS_STATIC static
#endif

#if defined(WIN32) && defined(PERL_OBJECT) && !defined(PerlIO_exportFILE)
#define PerlIO_exportFILE(fh,fl) (FILE*)(fh)
#endif

/* Modifications for newer Perl 5.005 releases */

#if !defined(PERL_REVISION) || ((PERL_REVISION >= 5) && ((PERL_VERSION < 5) || ((PERL_VERSION == 5) && (PERL_SUBVERSION < 50))))
#ifndef PL_sv_yes
#define PL_sv_yes sv_yes
#endif
#ifndef PL_sv_undef
#define PL_sv_undef sv_undef
#endif
#ifndef PL_na
#define PL_na na
#endif
#endif

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SWIG_NOINCLUDE

#ifndef PERL_OBJECT
extern int SWIG_ConvertPtr(SV *, void **, swig_type_info *);
extern void SWIG_MakePtr(SV *, void *, swig_type_info *);
#else
extern int _SWIG_ConvertPtr(CPerlObj *, SV *, void **, swig_type_info *);
extern void _SWIG_MakePtr(CPerlObj *, SV *, void *, swig_type_info *);
#define SWIG_ConvertPtr(a,b,c) _SWIG_ConvertPtr(pPerl,a,b,c)
#define SWIG_MakePtr(a,b,c) _SWIG_MakePtr(pPerl,a,b,c)
#endif

#endif

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGRUNTIME(int) 
SWIG_ConvertPtr(SV *sv, void **ptr, swig_type_info *_t)
#else
#define SWIG_ConvertPtr(a,b,c) _SWIG_GetConvert(pPerl,a,b,c)
SWIGRUNTIME(int)
_SWIG_ConvertPtr(CPerlObj *pPerl, SV *sv, void **ptr, swig_type_info *_t)
#endif
{
  char *_c;
  swig_type_info *tc;
  IV   tmp;

  /* If magical, apply more magic */
  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
	mg = mg_find(tsv,'P');
	if (mg) {
	  SV *rsv = mg->mg_obj;
	  if (sv_isobject(rsv)) {
	    tmp = SvIV((SV*)SvRV(rsv));
	  }
	}
      } else {
	return -1;
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    if (!_t) {
      *(ptr) = (void *) tmp;
      return 0;
    }
  } else if (! SvOK(sv)) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return 0;
  } else if (SvTYPE(sv) == SVt_RV) {  /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv)) 
      return 0;
    else
      return -1;
  } else {                            /* Don't know what it is */
      *(ptr) = (void *) 0;
      return -1;
  }
  if (_t) {
    /* Now see if the types match */      
    _c = HvNAME(SvSTASH(SvRV(sv)));
    tc = SWIG_TypeCheck(_c,_t);
    if (!tc) {
      *ptr = (void *) tmp;
      return -1;
    }
    *ptr = SWIG_TypeCast(tc,(void *)tmp);
    return 0;
  }
  *ptr = (void *) tmp;
  return 0;
}
#ifndef PERL_OBJECT
SWIGRUNTIME(void) 
SWIG_MakePtr(SV *sv, void *ptr, swig_type_info *t)
#else
#define SWIG_MakePtr(a,b,c) _SWIG_MakePtr(pPerl,a,b,c)
SWIGRUNTIME(int *)
_SWIG_MakePtr(CPerlObj *pPerl, SV *sv, void *ptr, swig_type_info *t)
#endif
{
  sv_setref_pv(sv, t->name, ptr);
}

/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) {
#else
#define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerlObj *pPerl, SV *sv, char *name, int (CPerlObj::*set)(SV *, MAGIC *), int (CPerlObj::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = get;
  mg->mg_virtual->svt_set = set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}

#ifdef __cplusplus
}
#endif







/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_Partial swig_types[0] 
#define  SWIGTYPE_p_PartialList swig_types[1] 
#define  SWIGTYPE_p_SampleVector swig_types[2] 
#define  SWIGTYPE_p_AiffFile swig_types[3] 
#define  SWIGTYPE_p_Analyzer swig_types[4] 
#define  SWIGTYPE_p_PartialListIterator swig_types[5] 
#define  SWIGTYPE_p_PartialIterator swig_types[6] 
#define  SWIGTYPE_p_Breakpoint swig_types[7] 
#define  SWIGTYPE_p_BreakpointEnvelope swig_types[8] 
static swig_type_info *swig_types[10];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    boot_loris_perl

#define SWIG_name   "loris_perl::boot_loris_perl"
#define SWIG_varinit "loris_perl::var_loris_perl_init();"
#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
SWIGEXPORT(void) SWIG_init (CV* cv);
#else
SWIGEXPORT(void) SWIG_init (CV *cv, CPerlObj *);
#endif

		#undef list


	#include<Notifier.h>
	#include<Exception.h>
	#include <string>
	
	//	notification function for Loris debugging
	//	and notifications, installed in initialization
	//	block below:
	static void printf_notifier( const char * s )
	{
		printf("*\t%s\n", s);
	}	
	
	//	class NullPointer
	//
	//	Define a Loris::Exception subclass for catching NULL pointers.
	//	This is copied from lorisException_pi.h. It could be in Loris,
	//	but probably was never needed because Loris doesn't make much 
	//	use of pointers.
	//
	class NullPointer : public Loris::Exception
	{
	public: 
		NullPointer( const std::string & str, const std::string & where = "" ) : 
			Exception( std::string("NULL pointer exception -- ").append( str ), where ) {}
	};	//	end of class NullPointer
	
	//	define a macro for testing and throwing:
	#define ThrowIfNull(ptr) if ((ptr)==NULL) Throw( NullPointer, #ptr );	

#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99

#define SWIG_exception(a,b)   croak(b)

#include<Partial.h>
#include<Notifier.h>
#include <list>

using Loris::debugger;
using Loris::Partial;
using Loris::Breakpoint;

//	define the names of the classes that are 
//	wrapped by this interface file:
//	(additionally Partial and Breakpoint)
typedef std::list< Loris::Partial > PartialList;
typedef std::list< Loris::Partial >::iterator PartialListIterator;
typedef Loris::Partial::iterator PartialIterator;


#include<Analyzer.h>
#include<Partial.h>

using Loris::Analyzer;

#include<BreakpointEnvelope.h>
using Loris::BreakpointEnvelope;

BreakpointEnvelope * BreakpointEnvelopeWithValue_( double initialValue )
{
	return new BreakpointEnvelope( initialValue );
}

#include <stdexcept>
#include <vector>
typedef std::vector< double > SampleVector;

#include<AiffFile.h>
using Loris::AiffFile;

	#include<Channelizer.h>

	void channelize( PartialList * partials, 
					 BreakpointEnvelope * refFreqEnvelope, int refLabel )
	{
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((BreakpointEnvelope *) refFreqEnvelope);
	
		if ( refLabel <= 0 )
			Throw( Loris::InvalidArgument, "Channelization reference label must be positive." );
		
		Loris::notifier << "channelizing " << partials->size() << " Partials" << Loris::endl;
	
		Loris::Channelizer chan( *refFreqEnvelope, refLabel );
		chan.channelize( partials->begin(), partials->end() );		
	
	}
	/*	Label Partials in a PartialList with the integer nearest to
		the amplitude-weighted average ratio of their frequency envelope
		to a reference frequency envelope. The frequency spectrum is 
		partitioned into non-overlapping channels whose time-varying 
		center frequencies track the reference frequency envelope. 
		The reference label indicates which channel's center frequency
		is exactly equal to the reference envelope frequency, and other
		channels' center frequencies are multiples of the reference 
		envelope frequency divided by the reference label. Each Partial 
		in the PartialList is labeled with the number of the channel
		that best fits its frequency envelope. The quality of the fit
		is evaluated at the breakpoints in the Partial envelope and
		weighted by the amplitude at each breakpoint, so that high-
		amplitude breakpoints contribute more to the channel decision.
		Partials are labeled, but otherwise unmodified. In particular, 
		their frequencies are not modified in any way.
	 */

	#include<Dilator.h>
	#include <string>
	#include <vector>
	
	//	Helper function for dilate: 
	//
	//	convert a string into a vector of doubles,
	//	ignore any extraneous characters:
	static std::vector<double> strtovec( const std::string & s )
	{
		std::vector<double> v;
		std::string::size_type beg, end;
		const std::string numparts("1234567890+-.");
		beg = s.find_first_of( numparts );
		while ( beg != std::string::npos )
		{
			end = s.find_first_not_of( numparts, beg );
			if ( end == std::string::npos )
				end = s.length();
	
			double x = atof( s.c_str() + beg );
			v.push_back(x);
	
			beg = s.find_first_of( numparts, end );
		}
		return v;
	}

	void dilate( PartialList * partials, 
				 char * initial_times, char * target_times )
	{
		std::vector<double> ivec = strtovec( initial_times );
		std::vector<double> tvec = strtovec( target_times );
		
		Loris::debugger << ivec.size() << " initial points, " 
						<< tvec.size() << " target points" << Loris::endl;
			
		if ( ivec.size() != tvec.size() )
			Throw( Loris::InvalidArgument, "Invalid arguments to dilate(): there must be as many target points as initial points" );
				
		double * initial = ivec.begin();
		double * target = tvec.begin();
		int npts = ivec.size();
	
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((double *) initial);
		ThrowIfNull((double *) target);
	
		Loris::notifier << "dilating " << partials->size() << " Partials" << Loris::endl;
		Loris::Dilator dil( initial, target, npts );
		dil.dilate( partials->begin(), partials->end() );
	}
	/*	Dilate Partials in a PartialList according to the given 
		initial and target time points. Partial envelopes are 
		stretched and compressed so that temporal features at
		the initial time points are aligned with the final time
		points. Time points are sorted, so Partial envelopes are 
		are only stretched and compressed, but breakpoints are not
		reordered. Duplicate time points are allowed. There must be
		the same number of initial and target time points.
		
		The time points are passed as strings; convert any native
		collection to a string representation, numerical elements
		will be extracted, other characters will be ignored.
	 */

	#include<Distiller.h>

void distill( PartialList * partials )
	{
		ThrowIfNull((PartialList *) partials);
	
		Loris::notifier << "distilling " << partials->size() << " Partials" << Loris::endl;
		Loris::Distiller still;
		still.distill( *partials );
		
	}
	/*	Distill labeled (channelized)  Partials in a PartialList into a 
		PartialList containing a single (labeled) Partial per label. 
		The distilled PartialList will contain as many Partials as
		there were non-zero labels in the original PartialList. Unlabeled 
		(label 0) Partials are eliminated.
	 */

	#include<AiffFile.h>

	void exportAiff( const char * path,
					 SampleVector * samples,
					 double samplerate, int nchannels, int bitsPerSamp )
	{		
		Loris::AiffFile::Export( path, samplerate, nchannels, bitsPerSamp, 
								 samples->begin(), samples->end() );
	}
	/*	Export audio samples stored in a SampleVector to an AIFF file
		having the specified number of channels and sample rate at the 
		given file path (or name). The floating point samples in the 
		SampleVector are clamped to the range (-1.,1.) and converted 
		to integers having bitsPerSamp bits.
	 */
				 

	//	stupid name for sdif file header, name collision
	#include<SdifFile.h>

	void exportSdif( const char * path, PartialList * partials )
	{
		ThrowIfNull((PartialList *) partials);

		if ( partials->size() == 0 ) 
			Throw( Loris::InvalidObject, "No Partials in PartialList to export to sdif file." );
	
		Loris::notifier << "exporting sdif partial data to " << path << Loris::endl;		
		Loris::SdifFile::Export( path, *partials );
		
	}
	/*	Export Partials in a PartialList to a SDIF file at the specified
		file path (or name). SDIF data is written in the 1TRC format.  
		For more information about SDIF, see the SDIF website at:
			www.ircam.fr/equipes/analyse-synthese/sdif/  
	 */

	#include<SpcFile.h>

	void exportSpc( const char * path, PartialList * partials, double midiPitch, 
					int enhanced = true, double endApproachTime = 0. )
	{
		ThrowIfNull((PartialList *) partials);

		if ( partials->size() == 0 )
			Throw( Loris::InvalidObject, "No Partials in PartialList to export to Spc file." );

		Loris::notifier << "exporting Spc partial data to " << path << Loris::endl;
		Loris::SpcFile::Export( path, *partials, midiPitch, enhanced, endApproachTime );
	}
	/*	Export Partials in a PartialList to a Spc file at the specified file
		path (or name). The fractional MIDI pitch must be specified. The optional
		enhanced parameter defaults to true (for bandwidth-enhanced spc files), 
		but an be specified false for pure-sines spc files. The optional 
		endApproachTime parameter is in seconds; its default value is zero (and 
		has no effect). A nonzero endApproachTime indicates that the plist does 
		not include a release, but rather ends in a static spectrum corresponding 
		to the final breakpoint values of the partials. The endApproachTime
		specifies how long before the end of the sound the amplitude, frequency, 
		and bandwidth values are to be modified to make a gradual transition to 
		the static spectrum.
	 */

	#include<SdifFile.h>
	PartialList * importSdif( const char * path )
	{
		Loris::notifier << "importing Partials from " << path << Loris::endl;
		Loris::SdifFile imp( path );

		PartialList * partials = new PartialList();
		//	splice() can't throw, can it???
		partials->splice( partials->end(), imp.partials() );

		return partials;
	}

	#include<SpcFile.h>
	PartialList * importSpc( const char * path )
	{
		Loris::notifier << "importing Partials from " << path << Loris::endl;
		Loris::SpcFile imp( path );

		PartialList * partials = new PartialList();
		//	splice() can't throw, can it???
		partials->splice( partials->end(), imp.partials() );

		return partials;
	}

	#include<Morpher.h>
	PartialList * morph( const PartialList * src0, const PartialList * src1, 
						 const BreakpointEnvelope * ffreq, 
						 const BreakpointEnvelope * famp, 
						 const BreakpointEnvelope * fbw )
	{
		ThrowIfNull((PartialList *) src0);
		ThrowIfNull((PartialList *) src1);
		ThrowIfNull((BreakpointEnvelope *) ffreq);
		ThrowIfNull((BreakpointEnvelope *) famp);
		ThrowIfNull((BreakpointEnvelope *) fbw);

		Loris::notifier << "morphing " << src0->size() << " Partials with "
						<< src1->size() << " Partials" << Loris::endl;
					
		//	make a Morpher object and do it:
		Loris::Morpher m( *ffreq, *famp, *fbw );
		m.morph( src0->begin(), src0->end(), src1->begin(), src1->end() );
				
		//	splice the morphed Partials into a new PartialList:
		PartialList * dst = new PartialList();
		//	splice() can't throw, can it???
		dst->splice( dst->end(), m.partials() );
		return dst;
	}

	#include<Synthesizer.h>
	SampleVector * synthesize( const PartialList * partials, double srate )
	{
		ThrowIfNull((PartialList *) partials);

		Loris::notifier << "synthesizing " << partials->size() 
						<< " Partials at " << srate << " Hz" << Loris::endl;

		//	compute the duration:
		debugger << "computing duration..." << Loris::endl;
		double maxtime = 0.;
		PartialList::const_iterator it;
		for ( it = partials->begin(); it != partials->end(); ++it ) 
		{
			maxtime = std::max( maxtime, it->endTime() );
		}
		debugger << maxtime << " seconds" << Loris::endl;
		
		//	allocate a SampleVector to accomodate the fade-out at 
		//	the end of the latest Partial:
		const long nsamps = long( srate * ( maxtime + Partial::FadeTime() ) );	
		SampleVector * samples = new SampleVector( nsamps, 0. );
		
		//	synthesize:
		try
		{
			Loris::Synthesizer synth( srate, samples->begin(), samples->end() );
			for ( it = partials->begin(); it != partials->end(); ++it ) 
			{
				synth.synthesize( *it );
			}
		}
		catch(...)
		{
			delete samples;
			throw;
		}
		
		return samples;
	}

	#include<Sieve.h>

	void sift( PartialList * partials )
	{		
		
		ThrowIfNull((PartialList *) partials);

		Loris::notifier << "sifting " << partials->size() << " Partials" << Loris::endl;
		
		Loris::Sieve sieve( 0.0001 );
		sieve.sift( *partials );
	}
	/*	Lippold's wacky experimental sifting thingie: 
		If any two partials with same label overlap in time,
		keep only the longer of the two partials.
		Set the label of the shorter duration partial to zero.
		
		This used to be "experimental," and is now just 
		"transitional."
	 */

	#include <memory> 	//	 for auto_ptr
	
	BreakpointEnvelope * 
	createFreqReference( PartialList * partials, int numSamples,
						 double minFreq, double maxFreq )
	{
		ThrowIfNull((PartialList *) partials);
		
		if ( numSamples <= 0 )
			Throw( Loris::InvalidArgument, "number of samples in frequency reference must be positive." );
		
		if ( maxFreq < minFreq )
			std::swap( minFreq, maxFreq );
			
		//	find the longest Partial in the given frequency range:
		PartialList::iterator longest = partials->end();
		for ( PartialList::iterator it = partials->begin(); 
			  it != partials->end(); 
			  ++it ) 
		{
			//	evaluate the Partial's frequency at its loudest
			//	(highest sinusoidal amplitude) Breakpoint:
			Partial::const_iterator partialIter = it->begin();
			double maxAmp = 
				partialIter.breakpoint().amplitude() * std::sqrt( 1. - partialIter.breakpoint().bandwidth() );
			double time = partialIter.time();
			
			for ( ++partialIter; partialIter != it->end(); ++partialIter ) 
			{
				double a = partialIter.breakpoint().amplitude() * 
							std::sqrt( 1. - partialIter.breakpoint().bandwidth() );
				if ( a > maxAmp ) 
				{
					maxAmp = a;
					time = partialIter.time();
				}
			}			
			double compareFreq = it->frequencyAt( time );
			
			
			if ( compareFreq < minFreq || compareFreq > maxFreq )
				continue;
				
			if ( longest == partials->end() || it->duration() > longest->duration() ) 
			{
				longest = it;
			}
		}	
		
		if ( longest == partials->end() ) 
		{
			Throw( Loris::InvalidArgument, "no partials found in the specified frequency range" );
		}
	
		//	use auto_ptr to manage memory in case 
		//	an exception is generated (hard to imagine):
		std::auto_ptr< BreakpointEnvelope > env_ptr( new BreakpointEnvelope() );

		//	find n samples, ignoring the end points:
		double dt = longest->duration() / (numSamples + 1.);
		for ( int i = 0; i < numSamples; ++i ) 
		{
			double t = longest->startTime() + ((i+1) * dt);
			double f = longest->frequencyAt(t);
			env_ptr->insertBreakpoint( t, f );
		}
		
		return env_ptr.release();
	}

	#include <cmath>

	void scaleAmp( PartialList * partials, BreakpointEnvelope * ampEnv )
	{
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((BreakpointEnvelope *) ampEnv);

		Loris::notifier << "scaling amplitude of " << partials->size() << " Partials" << Loris::endl;

		PartialList::iterator listPos;
		for ( listPos = partials->begin(); listPos != partials->end(); ++listPos ) 
		{
			PartialIterator envPos;
			for ( envPos = listPos->begin(); envPos != listPos->end(); ++envPos ) 
			{		
				envPos.breakpoint().setAmplitude( envPos.breakpoint().amplitude() * ampEnv->valueAt(envPos.time()) );
			}
		}	
	}
	/*	Scale the amplitude of the Partials in a PartialList according 
		to an envelope representing a time-varying amplitude scale value.
	 */

	void scaleNoiseRatio( PartialList * partials, BreakpointEnvelope * noiseEnv )
	{
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((BreakpointEnvelope *) noiseEnv);

		Loris::notifier << "scaling noise ratio of " << partials->size() << " Partials" << Loris::endl;

		PartialList::iterator listPos;
		for ( listPos = partials->begin(); listPos != partials->end(); ++listPos ) 
		{
			PartialIterator envPos;
			for ( envPos = listPos->begin(); envPos != listPos->end(); ++envPos ) 
			{		
				//	compute new bandwidth value:
				double bw = envPos.breakpoint().bandwidth();
				if ( bw < 1. ) 
				{
					double ratio = bw  / (1. - bw);
					ratio *= noiseEnv->valueAt(envPos.time());
					bw = ratio / (1. + ratio);
				}
				else 
				{
					bw = 1.;
				}
				
				envPos.breakpoint().setBandwidth( bw );
			}
		}	
	}
	/*	Scale the relative noise content of the Partials in a PartialList 
		according to an envelope representing a (time-varying) noise energy 
		scale value.
	 */

	void shiftPitch( PartialList * partials, BreakpointEnvelope * pitchEnv )
	{
		ThrowIfNull((PartialList *) partials);
		ThrowIfNull((BreakpointEnvelope *) pitchEnv);

		Loris::notifier << "shifting pitch of " << partials->size() << " Partials" << Loris::endl;
		
		PartialList::iterator listPos;
		for ( listPos = partials->begin(); listPos != partials->end(); ++listPos ) 
		{
			PartialIterator envPos;
			for ( envPos = listPos->begin(); envPos != listPos->end(); ++envPos ) 
			{		
				//	compute frequency scale:
				double scale = 
					std::pow(2., (0.01 * pitchEnv->valueAt(envPos.time())) /12.);				
				envPos.breakpoint().setFrequency( envPos.breakpoint().frequency() * scale );
			}
		}	
	}
	/*	Shift the pitch of all Partials in a PartialList according to 
		the given pitch envelope. The pitch envelope is assumed to have 
		units of cents (1/100 of a halfstep).
	 */
#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_loris_perl_var::
class _wrap_loris_perl_var : public CPerlObj {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}


#ifdef PERL_OBJECT
};
#endif

XS(_wrap_BreakpointEnvelopeWithValue) {
    double arg0 ;
    int argvi = 0;
    BreakpointEnvelope *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BreakpointEnvelopeWithValue(initialValue);");
    arg0 = (double )SvNV(ST(0));
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelopeWithValue_(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BreakpointEnvelope);
    XSRETURN(argvi);
}


XS(_wrap_channelize) {
    PartialList *arg0 ;
    BreakpointEnvelope *arg1 ;
    int arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: channelize(partials,refFreqEnvelope,refLabel);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of channelize. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_BreakpointEnvelope) < 0) {
        croak("Type error in argument 2 of channelize. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        XSRETURN(1);
    }
    arg2 = (int )SvIV(ST(2));
    {
        try
        {
            channelize(arg0,arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_dilate) {
    PartialList *arg0 ;
    char *arg1 ;
    char *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: dilate(partials,initial_times,target_times);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of dilate. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) {
        arg1 = 0; 
    }
    else {
        arg1 = (char *) SvPV(ST(1),PL_na); 
    }
    if (! SvOK((SV*) ST(2))) {
        arg2 = 0; 
    }
    else {
        arg2 = (char *) SvPV(ST(2),PL_na); 
    }
    {
        try
        {
            dilate(arg0,arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_distill) {
    PartialList *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: distill(partials);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of distill. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    {
        try
        {
            distill(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_exportAiff) {
    char *arg0 ;
    SampleVector *arg1 ;
    double arg2 ;
    int arg3 ;
    int arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) 
    croak("Usage: exportAiff(path,samples,samplerate,nchannels,bitsPerSamp);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_SampleVector) < 0) {
        croak("Type error in argument 2 of exportAiff. Expected %s", SWIGTYPE_p_SampleVector->name);
        XSRETURN(1);
    }
    arg2 = (double )SvNV(ST(2));
    arg3 = (int )SvIV(ST(3));
    arg4 = (int )SvIV(ST(4));
    {
        try
        {
            exportAiff((char const *)arg0,arg1,arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_exportSdif) {
    char *arg0 ;
    PartialList *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: exportSdif(path,partials);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 2 of exportSdif. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    {
        try
        {
            exportSdif((char const *)arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_exportSpc) {
    char *arg0 ;
    PartialList *arg1 ;
    double arg2 ;
    int arg3 = true ;
    double arg4 = 0. ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 5)) 
    croak("Usage: exportSpc(path,partials,midiPitch,enhanced,endApproachTime);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 2 of exportSpc. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    arg2 = (double )SvNV(ST(2));
    if (items > 3) {
        arg3 = (int )SvIV(ST(3));
    }
    if (items > 4) {
        arg4 = (double )SvNV(ST(4));
    }
    {
        try
        {
            exportSpc((char const *)arg0,arg1,arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_importSdif) {
    char *arg0 ;
    int argvi = 0;
    PartialList *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: importSdif(path);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    {
        try
        {
            result = (PartialList *)importSdif((char const *)arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList);
    XSRETURN(argvi);
}


XS(_wrap_importSpc) {
    char *arg0 ;
    int argvi = 0;
    PartialList *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: importSpc(path);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    {
        try
        {
            result = (PartialList *)importSpc((char const *)arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList);
    XSRETURN(argvi);
}


XS(_wrap_morph) {
    PartialList *arg0 ;
    PartialList *arg1 ;
    BreakpointEnvelope *arg2 ;
    BreakpointEnvelope *arg3 ;
    BreakpointEnvelope *arg4 ;
    int argvi = 0;
    PartialList *result ;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) 
    croak("Usage: morph(src0,src1,ffreq,famp,fbw);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of morph. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 2 of morph. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_BreakpointEnvelope) < 0) {
        croak("Type error in argument 3 of morph. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(3),(void **) &arg3,SWIGTYPE_p_BreakpointEnvelope) < 0) {
        croak("Type error in argument 4 of morph. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(4),(void **) &arg4,SWIGTYPE_p_BreakpointEnvelope) < 0) {
        croak("Type error in argument 5 of morph. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (PartialList *)morph((PartialList const *)arg0,(PartialList const *)arg1,(BreakpointEnvelope const *)arg2,(BreakpointEnvelope const *)arg3,(BreakpointEnvelope const *)arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList);
    XSRETURN(argvi);
}


XS(_wrap_synthesize) {
    PartialList *arg0 ;
    double arg1 ;
    int argvi = 0;
    SampleVector *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: synthesize(partials,srate);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of synthesize. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            result = (SampleVector *)synthesize((PartialList const *)arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SampleVector);
    XSRETURN(argvi);
}


XS(_wrap_sift) {
    PartialList *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: sift(partials);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of sift. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    {
        try
        {
            sift(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_createFreqReference) {
    PartialList *arg0 ;
    int arg1 ;
    double arg2 ;
    double arg3 ;
    int argvi = 0;
    BreakpointEnvelope *result ;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) 
    croak("Usage: createFreqReference(partials,numSamples,minFreq,maxFreq);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of createFreqReference. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    arg1 = (int )SvIV(ST(1));
    arg2 = (double )SvNV(ST(2));
    arg3 = (double )SvNV(ST(3));
    {
        try
        {
            result = (BreakpointEnvelope *)createFreqReference(arg0,arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BreakpointEnvelope);
    XSRETURN(argvi);
}


XS(_wrap_scaleAmp) {
    PartialList *arg0 ;
    BreakpointEnvelope *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: scaleAmp(partials,ampEnv);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of scaleAmp. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_BreakpointEnvelope) < 0) {
        croak("Type error in argument 2 of scaleAmp. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        XSRETURN(1);
    }
    {
        try
        {
            scaleAmp(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_scaleNoiseRatio) {
    PartialList *arg0 ;
    BreakpointEnvelope *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: scaleNoiseRatio(partials,noiseEnv);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of scaleNoiseRatio. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_BreakpointEnvelope) < 0) {
        croak("Type error in argument 2 of scaleNoiseRatio. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        XSRETURN(1);
    }
    {
        try
        {
            scaleNoiseRatio(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_shiftPitch) {
    PartialList *arg0 ;
    BreakpointEnvelope *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: shiftPitch(partials,pitchEnv);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of shiftPitch. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_BreakpointEnvelope) < 0) {
        croak("Type error in argument 2 of shiftPitch. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        XSRETURN(1);
    }
    {
        try
        {
            shiftPitch(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


PartialList * PartialList_copy(PartialList *self) {
    {
        return new PartialList( *self );
    }
}


XS(_wrap_PartialList_copy) {
    PartialList *arg0 ;
    int argvi = 0;
    PartialList *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialList_copy(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of PartialList_copy. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (PartialList *)PartialList_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList);
    XSRETURN(argvi);
}


PartialList * new_PartialList() {
    {
        debugger << "creating an empty list of Partials" << Loris::endl;
        return new PartialList();
    }
}


XS(_wrap_new_PartialList) {
    int argvi = 0;
    PartialList *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_PartialList();");
    {
        try
        {
            result = (PartialList *)new_PartialList();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList);
    XSRETURN(argvi);
}


void  delete_PartialList(PartialList *self) {
    {
        debugger << "destroying  a list of " << self->size() << " Partials" << Loris::endl;
        delete self;
    }
}


XS(_wrap_delete_PartialList) {
    PartialList *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_PartialList(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of delete_PartialList. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    {
        try
        {
            delete_PartialList(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_PartialList_clear) {
    PartialList *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialList_clear(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of PartialList_clear. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    {
        try
        {
            arg0->clear();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_PartialList_size) {
    PartialList *arg0 ;
    int argvi = 0;
    unsigned long result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialList_size(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of PartialList_size. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (unsigned long )arg0->size();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartialList_begin) {
    PartialList *arg0 ;
    int argvi = 0;
    PartialListIterator *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialList_begin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of PartialList_begin. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = new PartialListIterator (arg0->begin());
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialListIterator);
    XSRETURN(argvi);
}


XS(_wrap_PartialList_end) {
    PartialList *arg0 ;
    int argvi = 0;
    PartialListIterator *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialList_end(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of PartialList_end. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = new PartialListIterator (arg0->end());
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialListIterator);
    XSRETURN(argvi);
}


XS(_wrap_PartialList_insert) {
    PartialList *arg0 ;
    PartialListIterator *arg1 ;
    Partial *arg2 ;
    int argvi = 0;
    PartialListIterator *result ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: PartialList_insert(self,position,partial);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of PartialList_insert. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartialListIterator) < 0) {
        croak("Type error in argument 2 of PartialList_insert. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 3 of PartialList_insert. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = new PartialListIterator (arg0->insert(*arg1,(Partial const &)*arg2));
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialListIterator);
    XSRETURN(argvi);
}


XS(_wrap_PartialList_erase) {
    PartialList *arg0 ;
    PartialListIterator *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartialList_erase(self,position);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of PartialList_erase. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartialListIterator) < 0) {
        croak("Type error in argument 2 of PartialList_erase. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        XSRETURN(1);
    }
    {
        try
        {
            arg0->erase(*arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_PartialList_splice) {
    PartialList *arg0 ;
    PartialListIterator *arg1 ;
    PartialList *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: PartialList_splice(self,position,list);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 1 of PartialList_splice. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartialListIterator) < 0) {
        croak("Type error in argument 2 of PartialList_splice. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_PartialList) < 0) {
        croak("Type error in argument 3 of PartialList_splice. Expected %s", SWIGTYPE_p_PartialList->name);
        XSRETURN(1);
    }
    {
        try
        {
            arg0->splice(*arg1,*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


PartialListIterator * PartialListIterator_copy(PartialListIterator *self) {
    {
        return new PartialListIterator( *self );
    }
}


XS(_wrap_PartialListIterator_copy) {
    PartialListIterator *arg0 ;
    int argvi = 0;
    PartialListIterator *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialListIterator_copy(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialListIterator) < 0) {
        croak("Type error in argument 1 of PartialListIterator_copy. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialListIterator);
    XSRETURN(argvi);
}


PartialListIterator * PartialListIterator_next(PartialListIterator *self) {
    {
        ++(*self);
        return self;
    }
}


XS(_wrap_PartialListIterator_next) {
    PartialListIterator *arg0 ;
    int argvi = 0;
    PartialListIterator *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialListIterator_next(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialListIterator) < 0) {
        croak("Type error in argument 1 of PartialListIterator_next. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_next(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialListIterator);
    XSRETURN(argvi);
}


PartialListIterator * PartialListIterator_prev(PartialListIterator *self) {
    {
        --(*self);
        return self;
    }
}


XS(_wrap_PartialListIterator_prev) {
    PartialListIterator *arg0 ;
    int argvi = 0;
    PartialListIterator *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialListIterator_prev(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialListIterator) < 0) {
        croak("Type error in argument 1 of PartialListIterator_prev. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_prev(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialListIterator);
    XSRETURN(argvi);
}


Partial * PartialListIterator_partial(PartialListIterator *self) {
    {
        Partial & current = **self;
        return &current;
    }
}


XS(_wrap_PartialListIterator_partial) {
    PartialListIterator *arg0 ;
    int argvi = 0;
    Partial *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialListIterator_partial(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialListIterator) < 0) {
        croak("Type error in argument 1 of PartialListIterator_partial. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (Partial *)PartialListIterator_partial(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Partial);
    XSRETURN(argvi);
}


int  PartialListIterator_equals(PartialListIterator *self,PartialListIterator *other) {
    {
        return *self == *other;
    }
}


XS(_wrap_PartialListIterator_equals) {
    PartialListIterator *arg0 ;
    PartialListIterator *arg1 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartialListIterator_equals(self,other);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialListIterator) < 0) {
        croak("Type error in argument 1 of PartialListIterator_equals. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartialListIterator) < 0) {
        croak("Type error in argument 2 of PartialListIterator_equals. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (int )PartialListIterator_equals(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


int  PartialListIterator_isInRange(PartialListIterator *self,PartialListIterator const *begin,PartialListIterator const *end) {
    {
        PartialListIterator it;
        for ( it = *begin; it != *end; ++it )
        {
            if ( it == *self )
            return true;
        }
        return false;
    }
}


XS(_wrap_PartialListIterator_isInRange) {
    PartialListIterator *arg0 ;
    PartialListIterator *arg1 ;
    PartialListIterator *arg2 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: PartialListIterator_isInRange(self,begin,end);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialListIterator) < 0) {
        croak("Type error in argument 1 of PartialListIterator_isInRange. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartialListIterator) < 0) {
        croak("Type error in argument 2 of PartialListIterator_isInRange. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_PartialListIterator) < 0) {
        croak("Type error in argument 3 of PartialListIterator_isInRange. Expected %s", SWIGTYPE_p_PartialListIterator->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (int )PartialListIterator_isInRange(arg0,(PartialListIterator const *)arg1,(PartialListIterator const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_Partial) {
    int argvi = 0;
    Partial *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_Partial();");
    {
        try
        {
            result = (Partial *)new Partial();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Partial);
    XSRETURN(argvi);
}


XS(_wrap_delete_Partial) {
    Partial *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_Partial(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of delete_Partial. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_Partial_label) {
    Partial *arg0 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_label(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_label. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (int )arg0->label();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_initialPhase) {
    Partial *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_initialPhase(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_initialPhase. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->initialPhase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_startTime) {
    Partial *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_startTime(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_startTime. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->startTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_endTime) {
    Partial *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_endTime(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_endTime. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->endTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_duration) {
    Partial *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_duration(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_duration. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->duration();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_numBreakpoints) {
    Partial *arg0 ;
    int argvi = 0;
    long result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_numBreakpoints(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_numBreakpoints. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (long )arg0->numBreakpoints();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_setLabel) {
    Partial *arg0 ;
    int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_setLabel(self,l);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_setLabel. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    arg1 = (int )SvIV(ST(1));
    {
        try
        {
            arg0->setLabel(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_Partial_begin) {
    Partial *arg0 ;
    int argvi = 0;
    PartialIterator *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_begin(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_begin. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = new PartialIterator (arg0->begin());
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator);
    XSRETURN(argvi);
}


XS(_wrap_Partial_end) {
    Partial *arg0 ;
    int argvi = 0;
    PartialIterator *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_end(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_end. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = new PartialIterator (arg0->end());
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator);
    XSRETURN(argvi);
}


XS(_wrap_Partial_insert) {
    Partial *arg0 ;
    double arg1 ;
    Breakpoint *arg2 ;
    int argvi = 0;
    PartialIterator *result ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: Partial_insert(self,time,bp);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_insert. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_Breakpoint) < 0) {
        croak("Type error in argument 3 of Partial_insert. Expected %s", SWIGTYPE_p_Breakpoint->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = new PartialIterator (arg0->insert(arg1,(Breakpoint const &)*arg2));
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator);
    XSRETURN(argvi);
}


XS(_wrap_Partial_findAfter) {
    Partial *arg0 ;
    double arg1 ;
    int argvi = 0;
    PartialIterator *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_findAfter(self,time);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_findAfter. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            result = new PartialIterator (arg0->findAfter(arg1));
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator);
    XSRETURN(argvi);
}


XS(_wrap_Partial_findNearest) {
    Partial *arg0 ;
    double arg1 ;
    int argvi = 0;
    PartialIterator *result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_findNearest(self,time);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_findNearest. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            result = new PartialIterator (arg0->findNearest(arg1));
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator);
    XSRETURN(argvi);
}


XS(_wrap_Partial_erase) {
    Partial *arg0 ;
    PartialIterator *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_erase(self,pos);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_erase. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartialIterator) < 0) {
        croak("Type error in argument 2 of Partial_erase. Expected %s", SWIGTYPE_p_PartialIterator->name);
        XSRETURN(1);
    }
    {
        try
        {
            arg0->erase(*arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_Partial_frequencyAt) {
    Partial *arg0 ;
    double arg1 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_frequencyAt(self,time);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_frequencyAt. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            result = (double )arg0->frequencyAt(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_amplitudeAt) {
    Partial *arg0 ;
    double arg1 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_amplitudeAt(self,time);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_amplitudeAt. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            result = (double )arg0->amplitudeAt(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_bandwidthAt) {
    Partial *arg0 ;
    double arg1 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_bandwidthAt(self,time);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_bandwidthAt. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            result = (double )arg0->bandwidthAt(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Partial_phaseAt) {
    Partial *arg0 ;
    double arg1 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_phaseAt(self,time);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_phaseAt. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            result = (double )arg0->phaseAt(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


Partial * Partial_copy(Partial *self) {
    {
        return new Partial( *self );
    }
}


XS(_wrap_Partial_copy) {
    Partial *arg0 ;
    int argvi = 0;
    Partial *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Partial_copy(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_copy. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (Partial *)Partial_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Partial);
    XSRETURN(argvi);
}


int  Partial_equals(Partial *self,Partial *other) {
    {
        return *self == *other;
    }
}


XS(_wrap_Partial_equals) {
    Partial *arg0 ;
    Partial *arg1 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Partial_equals(self,other);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 1 of Partial_equals. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Partial) < 0) {
        croak("Type error in argument 2 of Partial_equals. Expected %s", SWIGTYPE_p_Partial->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (int )Partial_equals(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_PartialIterator_time) {
    PartialIterator *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialIterator_time(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialIterator) < 0) {
        croak("Type error in argument 1 of PartialIterator_time. Expected %s", SWIGTYPE_p_PartialIterator->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->time();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


Breakpoint * PartialIterator_breakpoint(PartialIterator *self) {
    {
        return &(self->breakpoint());
    }
}


XS(_wrap_PartialIterator_breakpoint) {
    PartialIterator *arg0 ;
    int argvi = 0;
    Breakpoint *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialIterator_breakpoint(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialIterator) < 0) {
        croak("Type error in argument 1 of PartialIterator_breakpoint. Expected %s", SWIGTYPE_p_PartialIterator->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (Breakpoint *)PartialIterator_breakpoint(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Breakpoint);
    XSRETURN(argvi);
}


PartialIterator * PartialIterator_copy(PartialIterator *self) {
    {
        return new PartialIterator( *self );
    }
}


XS(_wrap_PartialIterator_copy) {
    PartialIterator *arg0 ;
    int argvi = 0;
    PartialIterator *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialIterator_copy(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialIterator) < 0) {
        croak("Type error in argument 1 of PartialIterator_copy. Expected %s", SWIGTYPE_p_PartialIterator->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (PartialIterator *)PartialIterator_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator);
    XSRETURN(argvi);
}


PartialIterator * PartialIterator_next(PartialIterator *self) {
    {
        ++(*self);
        return self;
    }
}


XS(_wrap_PartialIterator_next) {
    PartialIterator *arg0 ;
    int argvi = 0;
    PartialIterator *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialIterator_next(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialIterator) < 0) {
        croak("Type error in argument 1 of PartialIterator_next. Expected %s", SWIGTYPE_p_PartialIterator->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (PartialIterator *)PartialIterator_next(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator);
    XSRETURN(argvi);
}


PartialIterator * PartialIterator_prev(PartialIterator *self) {
    {
        --(*self);
        return self;
    }
}


XS(_wrap_PartialIterator_prev) {
    PartialIterator *arg0 ;
    int argvi = 0;
    PartialIterator *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: PartialIterator_prev(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialIterator) < 0) {
        croak("Type error in argument 1 of PartialIterator_prev. Expected %s", SWIGTYPE_p_PartialIterator->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (PartialIterator *)PartialIterator_prev(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialIterator);
    XSRETURN(argvi);
}


int  PartialIterator_equals(PartialIterator *self,PartialIterator *other) {
    {
        return *self == *other;
    }
}


XS(_wrap_PartialIterator_equals) {
    PartialIterator *arg0 ;
    PartialIterator *arg1 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: PartialIterator_equals(self,other);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialIterator) < 0) {
        croak("Type error in argument 1 of PartialIterator_equals. Expected %s", SWIGTYPE_p_PartialIterator->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartialIterator) < 0) {
        croak("Type error in argument 2 of PartialIterator_equals. Expected %s", SWIGTYPE_p_PartialIterator->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (int )PartialIterator_equals(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


int  PartialIterator_isInRange(PartialIterator *self,PartialIterator const *begin,PartialIterator const *end) {
    {
        PartialIterator it;
        for ( it = *begin; it != *end; ++it )
        {
            if ( it == *self )
            return true;
        }
        return false;
    }
}


XS(_wrap_PartialIterator_isInRange) {
    PartialIterator *arg0 ;
    PartialIterator *arg1 ;
    PartialIterator *arg2 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: PartialIterator_isInRange(self,begin,end);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_PartialIterator) < 0) {
        croak("Type error in argument 1 of PartialIterator_isInRange. Expected %s", SWIGTYPE_p_PartialIterator->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_PartialIterator) < 0) {
        croak("Type error in argument 2 of PartialIterator_isInRange. Expected %s", SWIGTYPE_p_PartialIterator->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(2),(void **) &arg2,SWIGTYPE_p_PartialIterator) < 0) {
        croak("Type error in argument 3 of PartialIterator_isInRange. Expected %s", SWIGTYPE_p_PartialIterator->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (int )PartialIterator_isInRange(arg0,(PartialIterator const *)arg1,(PartialIterator const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_Breakpoint) {
    double arg0 ;
    double arg1 ;
    double arg2 ;
    double arg3 = 0. ;
    int argvi = 0;
    Breakpoint *result ;
    dXSARGS;
    
    if ((items < 3) || (items > 4)) 
    croak("Usage: new_Breakpoint(f,a,b,p);");
    arg0 = (double )SvNV(ST(0));
    arg1 = (double )SvNV(ST(1));
    arg2 = (double )SvNV(ST(2));
    if (items > 3) {
        arg3 = (double )SvNV(ST(3));
    }
    {
        try
        {
            result = (Breakpoint *)new Breakpoint(arg0,arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Breakpoint);
    XSRETURN(argvi);
}


XS(_wrap_delete_Breakpoint) {
    Breakpoint *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_Breakpoint(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Breakpoint) < 0) {
        croak("Type error in argument 1 of delete_Breakpoint. Expected %s", SWIGTYPE_p_Breakpoint->name);
        XSRETURN(1);
    }
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_Breakpoint_frequency) {
    Breakpoint *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Breakpoint_frequency(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Breakpoint) < 0) {
        croak("Type error in argument 1 of Breakpoint_frequency. Expected %s", SWIGTYPE_p_Breakpoint->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->frequency();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Breakpoint_amplitude) {
    Breakpoint *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Breakpoint_amplitude(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Breakpoint) < 0) {
        croak("Type error in argument 1 of Breakpoint_amplitude. Expected %s", SWIGTYPE_p_Breakpoint->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->amplitude();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Breakpoint_bandwidth) {
    Breakpoint *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Breakpoint_bandwidth(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Breakpoint) < 0) {
        croak("Type error in argument 1 of Breakpoint_bandwidth. Expected %s", SWIGTYPE_p_Breakpoint->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->bandwidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Breakpoint_phase) {
    Breakpoint *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Breakpoint_phase(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Breakpoint) < 0) {
        croak("Type error in argument 1 of Breakpoint_phase. Expected %s", SWIGTYPE_p_Breakpoint->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->phase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Breakpoint_setFrequency) {
    Breakpoint *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Breakpoint_setFrequency(self,x);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Breakpoint) < 0) {
        croak("Type error in argument 1 of Breakpoint_setFrequency. Expected %s", SWIGTYPE_p_Breakpoint->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            arg0->setFrequency(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_Breakpoint_setAmplitude) {
    Breakpoint *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Breakpoint_setAmplitude(self,x);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Breakpoint) < 0) {
        croak("Type error in argument 1 of Breakpoint_setAmplitude. Expected %s", SWIGTYPE_p_Breakpoint->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            arg0->setAmplitude(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_Breakpoint_setBandwidth) {
    Breakpoint *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Breakpoint_setBandwidth(self,x);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Breakpoint) < 0) {
        croak("Type error in argument 1 of Breakpoint_setBandwidth. Expected %s", SWIGTYPE_p_Breakpoint->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            arg0->setBandwidth(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_Breakpoint_setPhase) {
    Breakpoint *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Breakpoint_setPhase(self,x);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Breakpoint) < 0) {
        croak("Type error in argument 1 of Breakpoint_setPhase. Expected %s", SWIGTYPE_p_Breakpoint->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            arg0->setPhase(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


Breakpoint * Breakpoint_copy(Breakpoint *self) {
    {
        return new Breakpoint( *self );
    }
}


XS(_wrap_Breakpoint_copy) {
    Breakpoint *arg0 ;
    int argvi = 0;
    Breakpoint *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Breakpoint_copy(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Breakpoint) < 0) {
        croak("Type error in argument 1 of Breakpoint_copy. Expected %s", SWIGTYPE_p_Breakpoint->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (Breakpoint *)Breakpoint_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Breakpoint);
    XSRETURN(argvi);
}


int  Breakpoint_equals(Breakpoint *self,Breakpoint *other) {
    {
        return *self == *other;
    }
}


XS(_wrap_Breakpoint_equals) {
    Breakpoint *arg0 ;
    Breakpoint *arg1 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Breakpoint_equals(self,other);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Breakpoint) < 0) {
        croak("Type error in argument 1 of Breakpoint_equals. Expected %s", SWIGTYPE_p_Breakpoint->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_Breakpoint) < 0) {
        croak("Type error in argument 2 of Breakpoint_equals. Expected %s", SWIGTYPE_p_Breakpoint->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (int )Breakpoint_equals(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_new_Analyzer) {
    double arg0 ;
    int argvi = 0;
    Analyzer *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: new_Analyzer(resolutionHz);");
    arg0 = (double )SvNV(ST(0));
    {
        try
        {
            result = (Analyzer *)new Analyzer(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Analyzer);
    XSRETURN(argvi);
}


XS(_wrap_delete_Analyzer) {
    Analyzer *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_Analyzer(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of delete_Analyzer. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


Analyzer * Analyzer_copy(Analyzer *self) {
    {
        return new Analyzer( self->freqResolution() );
    }
}


XS(_wrap_Analyzer_copy) {
    Analyzer *arg0 ;
    int argvi = 0;
    Analyzer *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_copy(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_copy. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (Analyzer *)Analyzer_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Analyzer);
    XSRETURN(argvi);
}


PartialList * Analyzer_analyze(Analyzer *self,SampleVector const *vec,double srate) {
    {
        PartialList * partials = new PartialList();
        self->analyze( vec->begin(), vec->end(), srate );
        partials->splice( partials->end(), self->partials() );
        return partials;
    }
}


XS(_wrap_Analyzer_analyze) {
    Analyzer *arg0 ;
    SampleVector *arg1 ;
    double arg2 ;
    int argvi = 0;
    PartialList *result ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: Analyzer_analyze(self,vec,srate);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_analyze. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    if (SWIG_ConvertPtr(ST(1),(void **) &arg1,SWIGTYPE_p_SampleVector) < 0) {
        croak("Type error in argument 2 of Analyzer_analyze. Expected %s", SWIGTYPE_p_SampleVector->name);
        XSRETURN(1);
    }
    arg2 = (double )SvNV(ST(2));
    {
        try
        {
            result = (PartialList *)Analyzer_analyze(arg0,(SampleVector const *)arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PartialList);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_configure) {
    Analyzer *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_configure(self,resolutionHz);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_configure. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            arg0->configure(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_Analyzer_freqResolution) {
    Analyzer *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_freqResolution(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_freqResolution. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->freqResolution();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_ampFloor) {
    Analyzer *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_ampFloor(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_ampFloor. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->ampFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_windowWidth) {
    Analyzer *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_windowWidth(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_windowWidth. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->windowWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_freqFloor) {
    Analyzer *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_freqFloor(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_freqFloor. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->freqFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_hopTime) {
    Analyzer *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_hopTime(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_hopTime. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->hopTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_freqDrift) {
    Analyzer *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_freqDrift(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_freqDrift. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->freqDrift();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_cropTime) {
    Analyzer *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_cropTime(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_cropTime. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->cropTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_bwRegionWidth) {
    Analyzer *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: Analyzer_bwRegionWidth(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_bwRegionWidth. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->bwRegionWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_Analyzer_setFreqResolution) {
    Analyzer *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setFreqResolution(self,x);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_setFreqResolution. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            arg0->setFreqResolution(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_Analyzer_setAmpFloor) {
    Analyzer *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setAmpFloor(self,x);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_setAmpFloor. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            arg0->setAmpFloor(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_Analyzer_setWindowWidth) {
    Analyzer *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setWindowWidth(self,x);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_setWindowWidth. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            arg0->setWindowWidth(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_Analyzer_setFreqFloor) {
    Analyzer *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setFreqFloor(self,x);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_setFreqFloor. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            arg0->setFreqFloor(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_Analyzer_setFreqDrift) {
    Analyzer *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setFreqDrift(self,x);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_setFreqDrift. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            arg0->setFreqDrift(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_Analyzer_setHopTime) {
    Analyzer *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setHopTime(self,x);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_setHopTime. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            arg0->setHopTime(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_Analyzer_setCropTime) {
    Analyzer *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setCropTime(self,x);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_setCropTime. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            arg0->setCropTime(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_Analyzer_setBwRegionWidth) {
    Analyzer *arg0 ;
    double arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: Analyzer_setBwRegionWidth(self,x);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_Analyzer) < 0) {
        croak("Type error in argument 1 of Analyzer_setBwRegionWidth. Expected %s", SWIGTYPE_p_Analyzer->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            arg0->setBwRegionWidth(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_new_BreakpointEnvelope) {
    int argvi = 0;
    BreakpointEnvelope *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) 
    croak("Usage: new_BreakpointEnvelope();");
    {
        try
        {
            result = (BreakpointEnvelope *)new BreakpointEnvelope();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BreakpointEnvelope);
    XSRETURN(argvi);
}


XS(_wrap_delete_BreakpointEnvelope) {
    BreakpointEnvelope *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_BreakpointEnvelope(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BreakpointEnvelope) < 0) {
        croak("Type error in argument 1 of delete_BreakpointEnvelope. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        XSRETURN(1);
    }
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


BreakpointEnvelope * BreakpointEnvelope_copy(BreakpointEnvelope *self) {
    {
        return new BreakpointEnvelope( *self );
    }
}


XS(_wrap_BreakpointEnvelope_copy) {
    BreakpointEnvelope *arg0 ;
    int argvi = 0;
    BreakpointEnvelope *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: BreakpointEnvelope_copy(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BreakpointEnvelope) < 0) {
        croak("Type error in argument 1 of BreakpointEnvelope_copy. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelope_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BreakpointEnvelope);
    XSRETURN(argvi);
}


XS(_wrap_BreakpointEnvelope_valueAt) {
    BreakpointEnvelope *arg0 ;
    double arg1 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: BreakpointEnvelope_valueAt(self,x);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BreakpointEnvelope) < 0) {
        croak("Type error in argument 1 of BreakpointEnvelope_valueAt. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    {
        try
        {
            result = (double )arg0->valueAt(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_BreakpointEnvelope_insertBreakpoint) {
    BreakpointEnvelope *arg0 ;
    double arg1 ;
    double arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: BreakpointEnvelope_insertBreakpoint(self,time,value);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_BreakpointEnvelope) < 0) {
        croak("Type error in argument 1 of BreakpointEnvelope_insertBreakpoint. Expected %s", SWIGTYPE_p_BreakpointEnvelope->name);
        XSRETURN(1);
    }
    arg1 = (double )SvNV(ST(1));
    arg2 = (double )SvNV(ST(2));
    {
        try
        {
            arg0->insertBreakpoint(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_new_SampleVector) {
    unsigned long arg0 = 0 ;
    int argvi = 0;
    SampleVector *result ;
    dXSARGS;
    
    if ((items < 0) || (items > 1)) 
    croak("Usage: new_SampleVector(size);");
    if (items > 0) {
        arg0 = (unsigned long )SvIV(ST(0));
    }
    {
        try
        {
            result = (SampleVector *)new SampleVector(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SampleVector);
    XSRETURN(argvi);
}


XS(_wrap_delete_SampleVector) {
    SampleVector *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_SampleVector(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_SampleVector) < 0) {
        croak("Type error in argument 1 of delete_SampleVector. Expected %s", SWIGTYPE_p_SampleVector->name);
        XSRETURN(1);
    }
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_SampleVector_size) {
    SampleVector *arg0 ;
    int argvi = 0;
    unsigned long result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: SampleVector_size(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_SampleVector) < 0) {
        croak("Type error in argument 1 of SampleVector_size. Expected %s", SWIGTYPE_p_SampleVector->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (unsigned long )arg0->size();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_SampleVector_resize) {
    SampleVector *arg0 ;
    unsigned long arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: SampleVector_resize(self,size);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_SampleVector) < 0) {
        croak("Type error in argument 1 of SampleVector_resize. Expected %s", SWIGTYPE_p_SampleVector->name);
        XSRETURN(1);
    }
    arg1 = (unsigned long )SvIV(ST(1));
    {
        try
        {
            arg0->resize(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_SampleVector_clear) {
    SampleVector *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: SampleVector_clear(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_SampleVector) < 0) {
        croak("Type error in argument 1 of SampleVector_clear. Expected %s", SWIGTYPE_p_SampleVector->name);
        XSRETURN(1);
    }
    {
        try
        {
            arg0->clear();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


SampleVector * SampleVector_copy(SampleVector *self) {
    {
        return new SampleVector( *self );
    }
}


XS(_wrap_SampleVector_copy) {
    SampleVector *arg0 ;
    int argvi = 0;
    SampleVector *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: SampleVector_copy(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_SampleVector) < 0) {
        croak("Type error in argument 1 of SampleVector_copy. Expected %s", SWIGTYPE_p_SampleVector->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (SampleVector *)SampleVector_copy(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SampleVector);
    XSRETURN(argvi);
}


double  SampleVector_getAt(SampleVector *self,unsigned long idx) {
    {
// return self->at(idx);	//	g++ doesn't implement at()?
		if ( idx >= self->size() )
			throw std::out_of_range("vector::at index out of range");
		return (*self)[idx];
	}
}


XS(_wrap_SampleVector_getAt) {
    SampleVector *arg0 ;
    unsigned long arg1 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) 
    croak("Usage: SampleVector_getAt(self,idx);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_SampleVector) < 0) {
        croak("Type error in argument 1 of SampleVector_getAt. Expected %s", SWIGTYPE_p_SampleVector->name);
        XSRETURN(1);
    }
    arg1 = (unsigned long )SvIV(ST(1));
    {
        try
        {
            result = (double )SampleVector_getAt(arg0,arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


void  SampleVector_setAt(SampleVector *self,unsigned long idx,double x) {
    {
// self->at(idx) = x;	//	g++ doesn't implement at()?
		if ( idx >= self->size() )
			throw std::out_of_range("vector::at index out of range");
		(*self)[idx] = x;
	}
}


XS(_wrap_SampleVector_setAt) {
    SampleVector *arg0 ;
    unsigned long arg1 ;
    double arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) 
    croak("Usage: SampleVector_setAt(self,idx,x);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_SampleVector) < 0) {
        croak("Type error in argument 1 of SampleVector_setAt. Expected %s", SWIGTYPE_p_SampleVector->name);
        XSRETURN(1);
    }
    arg1 = (unsigned long )SvIV(ST(1));
    arg2 = (double )SvNV(ST(2));
    {
        try
        {
            SampleVector_setAt(arg0,arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_new_AiffFile) {
    char *arg0 ;
    int argvi = 0;
    AiffFile *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: new_AiffFile(filename);");
    if (! SvOK((SV*) ST(0))) {
        arg0 = 0; 
    }
    else {
        arg0 = (char *) SvPV(ST(0),PL_na); 
    }
    {
        try
        {
            result = (AiffFile *)new AiffFile((char const *)arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_AiffFile);
    XSRETURN(argvi);
}


XS(_wrap_delete_AiffFile) {
    AiffFile *arg0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: delete_AiffFile(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_AiffFile) < 0) {
        croak("Type error in argument 1 of delete_AiffFile. Expected %s", SWIGTYPE_p_AiffFile->name);
        XSRETURN(1);
    }
    {
        try
        {
            delete arg0;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }XSRETURN(argvi);
}


XS(_wrap_AiffFile_channels) {
    AiffFile *arg0 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: AiffFile_channels(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_AiffFile) < 0) {
        croak("Type error in argument 1 of AiffFile_channels. Expected %s", SWIGTYPE_p_AiffFile->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (int )arg0->channels();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_AiffFile_sampleFrames) {
    AiffFile *arg0 ;
    int argvi = 0;
    unsigned long result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: AiffFile_sampleFrames(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_AiffFile) < 0) {
        croak("Type error in argument 1 of AiffFile_sampleFrames. Expected %s", SWIGTYPE_p_AiffFile->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (unsigned long )arg0->sampleFrames();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


XS(_wrap_AiffFile_sampleRate) {
    AiffFile *arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: AiffFile_sampleRate(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_AiffFile) < 0) {
        croak("Type error in argument 1 of AiffFile_sampleRate. Expected %s", SWIGTYPE_p_AiffFile->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (double )arg0->sampleRate();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}


XS(_wrap_AiffFile_sampleSize) {
    AiffFile *arg0 ;
    int argvi = 0;
    int result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: AiffFile_sampleSize(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_AiffFile) < 0) {
        croak("Type error in argument 1 of AiffFile_sampleSize. Expected %s", SWIGTYPE_p_AiffFile->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (int )arg0->sampleSize();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) result);
    XSRETURN(argvi);
}


SampleVector * AiffFile_samples(AiffFile *self) {
    {
        SampleVector * vec = new SampleVector( self->sampleFrames(), 0. );
        self->getSamples( vec->begin(), vec->end() );
        return vec;
    }
}


XS(_wrap_AiffFile_samples) {
    AiffFile *arg0 ;
    int argvi = 0;
    SampleVector *result ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) 
    croak("Usage: AiffFile_samples(self);");
    if (SWIG_ConvertPtr(ST(0),(void **) &arg0,SWIGTYPE_p_AiffFile) < 0) {
        croak("Type error in argument 1 of AiffFile_samples. Expected %s", SWIGTYPE_p_AiffFile->name);
        XSRETURN(1);
    }
    {
        try
        {
            result = (SampleVector *)AiffFile_samples(arg0);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            //	(these are very unlikely to come from the interface
            //	code, and cannot escape the procedural interface to
            //	Loris, which catches all exceptions.)
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_RuntimeError, (char *) s.c_str() );
        }
    }ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SampleVector);
    XSRETURN(argvi);
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_Partial[] = {{"_p_Partial", 0, "Partial *"},{"_p_Partial"},{0}};
static swig_type_info _swigt__p_PartialList[] = {{"_p_PartialList", 0, "PartialList *"},{"_p_PartialList"},{0}};
static swig_type_info _swigt__p_SampleVector[] = {{"_p_SampleVector", 0, "SampleVector *"},{"_p_SampleVector"},{0}};
static swig_type_info _swigt__p_AiffFile[] = {{"_p_AiffFile", 0, "AiffFile *"},{"_p_AiffFile"},{0}};
static swig_type_info _swigt__p_Analyzer[] = {{"_p_Analyzer", 0, "Analyzer *"},{"_p_Analyzer"},{0}};
static swig_type_info _swigt__p_PartialListIterator[] = {{"_p_PartialListIterator", 0, "PartialListIterator *"},{"_p_PartialListIterator"},{0}};
static swig_type_info _swigt__p_PartialIterator[] = {{"_p_PartialIterator", 0, "PartialIterator *"},{"_p_PartialIterator"},{0}};
static swig_type_info _swigt__p_Breakpoint[] = {{"_p_Breakpoint", 0, "Breakpoint *"},{"_p_Breakpoint"},{0}};
static swig_type_info _swigt__p_BreakpointEnvelope[] = {{"_p_BreakpointEnvelope", 0, "BreakpointEnvelope *"},{"_p_BreakpointEnvelope"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_Partial, 
_swigt__p_PartialList, 
_swigt__p_SampleVector, 
_swigt__p_AiffFile, 
_swigt__p_Analyzer, 
_swigt__p_PartialListIterator, 
_swigt__p_PartialIterator, 
_swigt__p_Breakpoint, 
_swigt__p_BreakpointEnvelope, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

XS(_wrap_perl5_loris_perl_var_init) {
    dXSARGS;
    SV *sv;
    XSRETURN(1);
}
#ifdef __cplusplus
extern "C"
#endif
XS(SWIG_init) {
    dXSARGS;
    int i;
    char *file = __FILE__;
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
    }
    newXS("loris_perl::var_loris_perl_init", _wrap_perl5_loris_perl_var_init, file);
    
    Loris::setNotifierHandler( printf_notifier );
    Loris::setDebuggerHandler( printf_notifier );
    newXS("loris_perl::BreakpointEnvelopeWithValue", _wrap_BreakpointEnvelopeWithValue, file);
    newXS("loris_perl::channelize", _wrap_channelize, file);
    newXS("loris_perl::dilate", _wrap_dilate, file);
    newXS("loris_perl::distill", _wrap_distill, file);
    newXS("loris_perl::exportAiff", _wrap_exportAiff, file);
    newXS("loris_perl::exportSdif", _wrap_exportSdif, file);
    newXS("loris_perl::exportSpc", _wrap_exportSpc, file);
    newXS("loris_perl::importSdif", _wrap_importSdif, file);
    newXS("loris_perl::importSpc", _wrap_importSpc, file);
    newXS("loris_perl::morph", _wrap_morph, file);
    newXS("loris_perl::synthesize", _wrap_synthesize, file);
    newXS("loris_perl::sift", _wrap_sift, file);
    newXS("loris_perl::createFreqReference", _wrap_createFreqReference, file);
    newXS("loris_perl::scaleAmp", _wrap_scaleAmp, file);
    newXS("loris_perl::scaleNoiseRatio", _wrap_scaleNoiseRatio, file);
    newXS("loris_perl::shiftPitch", _wrap_shiftPitch, file);
    newXS("loris_perl::PartialList_copy", _wrap_PartialList_copy, file);
    newXS("loris_perl::new_PartialList", _wrap_new_PartialList, file);
    newXS("loris_perl::delete_PartialList", _wrap_delete_PartialList, file);
    newXS("loris_perl::PartialList_clear", _wrap_PartialList_clear, file);
    newXS("loris_perl::PartialList_size", _wrap_PartialList_size, file);
    newXS("loris_perl::PartialList_begin", _wrap_PartialList_begin, file);
    newXS("loris_perl::PartialList_end", _wrap_PartialList_end, file);
    newXS("loris_perl::PartialList_insert", _wrap_PartialList_insert, file);
    newXS("loris_perl::PartialList_erase", _wrap_PartialList_erase, file);
    newXS("loris_perl::PartialList_splice", _wrap_PartialList_splice, file);
    newXS("loris_perl::PartialListIterator_copy", _wrap_PartialListIterator_copy, file);
    newXS("loris_perl::PartialListIterator_next", _wrap_PartialListIterator_next, file);
    newXS("loris_perl::PartialListIterator_prev", _wrap_PartialListIterator_prev, file);
    newXS("loris_perl::PartialListIterator_partial", _wrap_PartialListIterator_partial, file);
    newXS("loris_perl::PartialListIterator_equals", _wrap_PartialListIterator_equals, file);
    newXS("loris_perl::PartialListIterator_isInRange", _wrap_PartialListIterator_isInRange, file);
    newXS("loris_perl::new_Partial", _wrap_new_Partial, file);
    newXS("loris_perl::delete_Partial", _wrap_delete_Partial, file);
    newXS("loris_perl::Partial_label", _wrap_Partial_label, file);
    newXS("loris_perl::Partial_initialPhase", _wrap_Partial_initialPhase, file);
    newXS("loris_perl::Partial_startTime", _wrap_Partial_startTime, file);
    newXS("loris_perl::Partial_endTime", _wrap_Partial_endTime, file);
    newXS("loris_perl::Partial_duration", _wrap_Partial_duration, file);
    newXS("loris_perl::Partial_numBreakpoints", _wrap_Partial_numBreakpoints, file);
    newXS("loris_perl::Partial_setLabel", _wrap_Partial_setLabel, file);
    newXS("loris_perl::Partial_begin", _wrap_Partial_begin, file);
    newXS("loris_perl::Partial_end", _wrap_Partial_end, file);
    newXS("loris_perl::Partial_insert", _wrap_Partial_insert, file);
    newXS("loris_perl::Partial_findAfter", _wrap_Partial_findAfter, file);
    newXS("loris_perl::Partial_findNearest", _wrap_Partial_findNearest, file);
    newXS("loris_perl::Partial_erase", _wrap_Partial_erase, file);
    newXS("loris_perl::Partial_frequencyAt", _wrap_Partial_frequencyAt, file);
    newXS("loris_perl::Partial_amplitudeAt", _wrap_Partial_amplitudeAt, file);
    newXS("loris_perl::Partial_bandwidthAt", _wrap_Partial_bandwidthAt, file);
    newXS("loris_perl::Partial_phaseAt", _wrap_Partial_phaseAt, file);
    newXS("loris_perl::Partial_copy", _wrap_Partial_copy, file);
    newXS("loris_perl::Partial_equals", _wrap_Partial_equals, file);
    newXS("loris_perl::PartialIterator_time", _wrap_PartialIterator_time, file);
    newXS("loris_perl::PartialIterator_breakpoint", _wrap_PartialIterator_breakpoint, file);
    newXS("loris_perl::PartialIterator_copy", _wrap_PartialIterator_copy, file);
    newXS("loris_perl::PartialIterator_next", _wrap_PartialIterator_next, file);
    newXS("loris_perl::PartialIterator_prev", _wrap_PartialIterator_prev, file);
    newXS("loris_perl::PartialIterator_equals", _wrap_PartialIterator_equals, file);
    newXS("loris_perl::PartialIterator_isInRange", _wrap_PartialIterator_isInRange, file);
    newXS("loris_perl::new_Breakpoint", _wrap_new_Breakpoint, file);
    newXS("loris_perl::delete_Breakpoint", _wrap_delete_Breakpoint, file);
    newXS("loris_perl::Breakpoint_frequency", _wrap_Breakpoint_frequency, file);
    newXS("loris_perl::Breakpoint_amplitude", _wrap_Breakpoint_amplitude, file);
    newXS("loris_perl::Breakpoint_bandwidth", _wrap_Breakpoint_bandwidth, file);
    newXS("loris_perl::Breakpoint_phase", _wrap_Breakpoint_phase, file);
    newXS("loris_perl::Breakpoint_setFrequency", _wrap_Breakpoint_setFrequency, file);
    newXS("loris_perl::Breakpoint_setAmplitude", _wrap_Breakpoint_setAmplitude, file);
    newXS("loris_perl::Breakpoint_setBandwidth", _wrap_Breakpoint_setBandwidth, file);
    newXS("loris_perl::Breakpoint_setPhase", _wrap_Breakpoint_setPhase, file);
    newXS("loris_perl::Breakpoint_copy", _wrap_Breakpoint_copy, file);
    newXS("loris_perl::Breakpoint_equals", _wrap_Breakpoint_equals, file);
    newXS("loris_perl::new_Analyzer", _wrap_new_Analyzer, file);
    newXS("loris_perl::delete_Analyzer", _wrap_delete_Analyzer, file);
    newXS("loris_perl::Analyzer_copy", _wrap_Analyzer_copy, file);
    newXS("loris_perl::Analyzer_analyze", _wrap_Analyzer_analyze, file);
    newXS("loris_perl::Analyzer_configure", _wrap_Analyzer_configure, file);
    newXS("loris_perl::Analyzer_freqResolution", _wrap_Analyzer_freqResolution, file);
    newXS("loris_perl::Analyzer_ampFloor", _wrap_Analyzer_ampFloor, file);
    newXS("loris_perl::Analyzer_windowWidth", _wrap_Analyzer_windowWidth, file);
    newXS("loris_perl::Analyzer_freqFloor", _wrap_Analyzer_freqFloor, file);
    newXS("loris_perl::Analyzer_hopTime", _wrap_Analyzer_hopTime, file);
    newXS("loris_perl::Analyzer_freqDrift", _wrap_Analyzer_freqDrift, file);
    newXS("loris_perl::Analyzer_cropTime", _wrap_Analyzer_cropTime, file);
    newXS("loris_perl::Analyzer_bwRegionWidth", _wrap_Analyzer_bwRegionWidth, file);
    newXS("loris_perl::Analyzer_setFreqResolution", _wrap_Analyzer_setFreqResolution, file);
    newXS("loris_perl::Analyzer_setAmpFloor", _wrap_Analyzer_setAmpFloor, file);
    newXS("loris_perl::Analyzer_setWindowWidth", _wrap_Analyzer_setWindowWidth, file);
    newXS("loris_perl::Analyzer_setFreqFloor", _wrap_Analyzer_setFreqFloor, file);
    newXS("loris_perl::Analyzer_setFreqDrift", _wrap_Analyzer_setFreqDrift, file);
    newXS("loris_perl::Analyzer_setHopTime", _wrap_Analyzer_setHopTime, file);
    newXS("loris_perl::Analyzer_setCropTime", _wrap_Analyzer_setCropTime, file);
    newXS("loris_perl::Analyzer_setBwRegionWidth", _wrap_Analyzer_setBwRegionWidth, file);
    newXS("loris_perl::new_BreakpointEnvelope", _wrap_new_BreakpointEnvelope, file);
    newXS("loris_perl::delete_BreakpointEnvelope", _wrap_delete_BreakpointEnvelope, file);
    newXS("loris_perl::BreakpointEnvelope_copy", _wrap_BreakpointEnvelope_copy, file);
    newXS("loris_perl::BreakpointEnvelope_valueAt", _wrap_BreakpointEnvelope_valueAt, file);
    newXS("loris_perl::BreakpointEnvelope_insertBreakpoint", _wrap_BreakpointEnvelope_insertBreakpoint, file);
    newXS("loris_perl::new_SampleVector", _wrap_new_SampleVector, file);
    newXS("loris_perl::delete_SampleVector", _wrap_delete_SampleVector, file);
    newXS("loris_perl::SampleVector_size", _wrap_SampleVector_size, file);
    newXS("loris_perl::SampleVector_resize", _wrap_SampleVector_resize, file);
    newXS("loris_perl::SampleVector_clear", _wrap_SampleVector_clear, file);
    newXS("loris_perl::SampleVector_copy", _wrap_SampleVector_copy, file);
    newXS("loris_perl::SampleVector_getAt", _wrap_SampleVector_getAt, file);
    newXS("loris_perl::SampleVector_setAt", _wrap_SampleVector_setAt, file);
    newXS("loris_perl::new_AiffFile", _wrap_new_AiffFile, file);
    newXS("loris_perl::delete_AiffFile", _wrap_delete_AiffFile, file);
    newXS("loris_perl::AiffFile_channels", _wrap_AiffFile_channels, file);
    newXS("loris_perl::AiffFile_sampleFrames", _wrap_AiffFile_sampleFrames, file);
    newXS("loris_perl::AiffFile_sampleRate", _wrap_AiffFile_sampleRate, file);
    newXS("loris_perl::AiffFile_sampleSize", _wrap_AiffFile_sampleSize, file);
    newXS("loris_perl::AiffFile_samples", _wrap_AiffFile_samples, file);
    ST(0) = &PL_sv_yes;
    XSRETURN(1);
}

