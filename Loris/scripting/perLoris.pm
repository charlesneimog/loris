# This file was automatically generated by SWIG
package perLoris;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package perLorisc;
bootstrap perLoris;
package perLoris;
@EXPORT = qw( );

# ---------- BASE METHODS -------------

package perLoris;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package perLoris;

*channelize = *perLorisc::channelize;
*createFreqReference = *perLorisc::createFreqReference;
*dilate = *perLorisc::dilate;
*distill = *perLorisc::distill;
*exportAiff = *perLorisc::exportAiff;
*exportSdif = *perLorisc::exportSdif;
*exportSpc = *perLorisc::exportSpc;
*importSdif = *perLorisc::importSdif;
*importSpc = *perLorisc::importSpc;
*morph = *perLorisc::morph;
*synthesize = *perLorisc::synthesize;
*crop = *perLorisc::crop;
*copyLabeled = *perLorisc::copyLabeled;
*extractLabeled = *perLorisc::extractLabeled;
*removeLabeled = *perLorisc::removeLabeled;
*resample = *perLorisc::resample;
*scaleAmp = *perLorisc::scaleAmp;
*scaleBandwidth = *perLorisc::scaleBandwidth;
*scaleFrequency = *perLorisc::scaleFrequency;
*scaleNoiseRatio = *perLorisc::scaleNoiseRatio;
*shiftPitch = *perLorisc::shiftPitch;
*shiftTime = *perLorisc::shiftTime;
*sift = *perLorisc::sift;
*sortByLabel = *perLorisc::sortByLabel;
*version = *perLorisc::version;
*BreakpointEnvelopeWithValue = *perLorisc::BreakpointEnvelopeWithValue;

############# Class : perLoris::Marker ##############

package perLoris::Marker;
@ISA = qw( perLoris );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = perLorisc::new_Marker(@_);
    bless $self, $pkg if defined($self);
}

*name = *perLorisc::Marker_name;
*time = *perLorisc::Marker_time;
*setName = *perLorisc::Marker_setName;
*setTime = *perLorisc::Marker_setTime;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        perLorisc::delete_Marker($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : perLoris::AiffFile ##############

package perLoris::AiffFile;
@ISA = qw( perLoris );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        perLorisc::delete_AiffFile($self);
        delete $OWNER{$self};
    }
}

*sampleRate = *perLorisc::AiffFile_sampleRate;
*midiNoteNumber = *perLorisc::AiffFile_midiNoteNumber;
*sampleFrames = *perLorisc::AiffFile_sampleFrames;
*addPartial = *perLorisc::AiffFile_addPartial;
*setMidiNoteNumber = *perLorisc::AiffFile_setMidiNoteNumber;
*write = *perLorisc::AiffFile_write;
sub new {
    my $pkg = shift;
    my $self = perLorisc::new_AiffFile(@_);
    bless $self, $pkg if defined($self);
}

*samples = *perLorisc::AiffFile_samples;
*channels = *perLorisc::AiffFile_channels;
*addPartials = *perLorisc::AiffFile_addPartials;
*numMarkers = *perLorisc::AiffFile_numMarkers;
*getMarker = *perLorisc::AiffFile_getMarker;
*removeMarker = *perLorisc::AiffFile_removeMarker;
*addMarker = *perLorisc::AiffFile_addMarker;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : perLoris::Analyzer ##############

package perLoris::Analyzer;
@ISA = qw( perLoris );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = perLorisc::new_Analyzer(@_);
    bless $self, $pkg if defined($self);
}

*copy = *perLorisc::Analyzer_copy;
*analyze = *perLorisc::Analyzer_analyze;
*freqResolution = *perLorisc::Analyzer_freqResolution;
*ampFloor = *perLorisc::Analyzer_ampFloor;
*windowWidth = *perLorisc::Analyzer_windowWidth;
*sidelobeLevel = *perLorisc::Analyzer_sidelobeLevel;
*freqFloor = *perLorisc::Analyzer_freqFloor;
*hopTime = *perLorisc::Analyzer_hopTime;
*freqDrift = *perLorisc::Analyzer_freqDrift;
*cropTime = *perLorisc::Analyzer_cropTime;
*bwRegionWidth = *perLorisc::Analyzer_bwRegionWidth;
*setFreqResolution = *perLorisc::Analyzer_setFreqResolution;
*setAmpFloor = *perLorisc::Analyzer_setAmpFloor;
*setWindowWidth = *perLorisc::Analyzer_setWindowWidth;
*setSidelobeLevel = *perLorisc::Analyzer_setSidelobeLevel;
*setFreqFloor = *perLorisc::Analyzer_setFreqFloor;
*setFreqDrift = *perLorisc::Analyzer_setFreqDrift;
*setHopTime = *perLorisc::Analyzer_setHopTime;
*setCropTime = *perLorisc::Analyzer_setCropTime;
*setBwRegionWidth = *perLorisc::Analyzer_setBwRegionWidth;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        perLorisc::delete_Analyzer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : perLoris::BreakpointEnvelope ##############

package perLoris::BreakpointEnvelope;
@ISA = qw( perLoris );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = perLorisc::new_BreakpointEnvelope(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        perLorisc::delete_BreakpointEnvelope($self);
        delete $OWNER{$self};
    }
}

*copy = *perLorisc::BreakpointEnvelope_copy;
*insertBreakpoint = *perLorisc::BreakpointEnvelope_insertBreakpoint;
*valueAt = *perLorisc::BreakpointEnvelope_valueAt;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : perLoris::SampleVector ##############

package perLoris::SampleVector;
@ISA = qw( perLoris );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = perLorisc::new_SampleVector(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        perLorisc::delete_SampleVector($self);
        delete $OWNER{$self};
    }
}

*clear = *perLorisc::SampleVector_clear;
*resize = *perLorisc::SampleVector_resize;
*size = *perLorisc::SampleVector_size;
*copy = *perLorisc::SampleVector_copy;
*getAt = *perLorisc::SampleVector_getAt;
*setAt = *perLorisc::SampleVector_setAt;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : perLoris::SdifFile ##############

package perLoris::SdifFile;
@ISA = qw( perLoris );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        perLorisc::delete_SdifFile($self);
        delete $OWNER{$self};
    }
}

*write = *perLorisc::SdifFile_write;
*write1TRC = *perLorisc::SdifFile_write1TRC;
sub new {
    my $pkg = shift;
    my $self = perLorisc::new_SdifFile(@_);
    bless $self, $pkg if defined($self);
}

*partials = *perLorisc::SdifFile_partials;
*addPartials = *perLorisc::SdifFile_addPartials;
*numMarkers = *perLorisc::SdifFile_numMarkers;
*getMarker = *perLorisc::SdifFile_getMarker;
*removeMarker = *perLorisc::SdifFile_removeMarker;
*addMarker = *perLorisc::SdifFile_addMarker;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : perLoris::SpcFile ##############

package perLoris::SpcFile;
@ISA = qw( perLoris );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        perLorisc::delete_SpcFile($self);
        delete $OWNER{$self};
    }
}

*sampleRate = *perLorisc::SpcFile_sampleRate;
*midiNoteNumber = *perLorisc::SpcFile_midiNoteNumber;
*addPartial = *perLorisc::SpcFile_addPartial;
*setMidiNoteNumber = *perLorisc::SpcFile_setMidiNoteNumber;
*setSampleRate = *perLorisc::SpcFile_setSampleRate;
*write = *perLorisc::SpcFile_write;
sub new {
    my $pkg = shift;
    my $self = perLorisc::new_SpcFile(@_);
    bless $self, $pkg if defined($self);
}

*partials = *perLorisc::SpcFile_partials;
*addPartials = *perLorisc::SpcFile_addPartials;
*numMarkers = *perLorisc::SpcFile_numMarkers;
*getMarker = *perLorisc::SpcFile_getMarker;
*removeMarker = *perLorisc::SpcFile_removeMarker;
*addMarker = *perLorisc::SpcFile_addMarker;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : perLoris::NewPlistIterator ##############

package perLoris::NewPlistIterator;
@ISA = qw( perLoris );
%OWNER = ();
*atEnd = *perLorisc::NewPlistIterator_atEnd;
*next = *perLorisc::NewPlistIterator_next;
*partial = *perLorisc::NewPlistIterator_partial;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : perLoris::NewPartialIterator ##############

package perLoris::NewPartialIterator;
@ISA = qw( perLoris );
%OWNER = ();
*atEnd = *perLorisc::NewPartialIterator_atEnd;
*hasNext = *perLorisc::NewPartialIterator_hasNext;
*next = *perLorisc::NewPartialIterator_next;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : perLoris::PartialList ##############

package perLoris::PartialList;
@ISA = qw( perLoris );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = perLorisc::new_PartialList(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        perLorisc::delete_PartialList($self);
        delete $OWNER{$self};
    }
}

*clear = *perLorisc::PartialList_clear;
*size = *perLorisc::PartialList_size;
*timeSpan = *perLorisc::PartialList_timeSpan;
*iterator = *perLorisc::PartialList_iterator;
*append = *perLorisc::PartialList_append;
*begin = *perLorisc::PartialList_begin;
*end = *perLorisc::PartialList_end;
*erase = *perLorisc::PartialList_erase;
*splice = *perLorisc::PartialList_splice;
*insert = *perLorisc::PartialList_insert;
*copy = *perLorisc::PartialList_copy;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : perLoris::Partial ##############

package perLoris::Partial;
@ISA = qw( perLoris );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = perLorisc::new_Partial(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        perLorisc::delete_Partial($self);
        delete $OWNER{$self};
    }
}

*label = *perLorisc::Partial_label;
*initialPhase = *perLorisc::Partial_initialPhase;
*startTime = *perLorisc::Partial_startTime;
*endTime = *perLorisc::Partial_endTime;
*duration = *perLorisc::Partial_duration;
*numBreakpoints = *perLorisc::Partial_numBreakpoints;
*setLabel = *perLorisc::Partial_setLabel;
*frequencyAt = *perLorisc::Partial_frequencyAt;
*amplitudeAt = *perLorisc::Partial_amplitudeAt;
*bandwidthAt = *perLorisc::Partial_bandwidthAt;
*phaseAt = *perLorisc::Partial_phaseAt;
*iterator = *perLorisc::Partial_iterator;
*begin = *perLorisc::Partial_begin;
*end = *perLorisc::Partial_end;
*erase = *perLorisc::Partial_erase;
*insert = *perLorisc::Partial_insert;
*findAfter = *perLorisc::Partial_findAfter;
*findNearest = *perLorisc::Partial_findNearest;
*copy = *perLorisc::Partial_copy;
*equals = *perLorisc::Partial_equals;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : perLoris::Breakpoint ##############

package perLoris::Breakpoint;
@ISA = qw( perLoris );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = perLorisc::new_Breakpoint(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        perLorisc::delete_Breakpoint($self);
        delete $OWNER{$self};
    }
}

*frequency = *perLorisc::Breakpoint_frequency;
*amplitude = *perLorisc::Breakpoint_amplitude;
*bandwidth = *perLorisc::Breakpoint_bandwidth;
*phase = *perLorisc::Breakpoint_phase;
*setFrequency = *perLorisc::Breakpoint_setFrequency;
*setAmplitude = *perLorisc::Breakpoint_setAmplitude;
*setBandwidth = *perLorisc::Breakpoint_setBandwidth;
*setPhase = *perLorisc::Breakpoint_setPhase;
*copy = *perLorisc::Breakpoint_copy;
*equals = *perLorisc::Breakpoint_equals;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : perLoris::BreakpointPosition ##############

package perLoris::BreakpointPosition;
@ISA = qw( perLoris );
%OWNER = ();
*time = *perLorisc::BreakpointPosition_time;
*breakpoint = *perLorisc::BreakpointPosition_breakpoint;
*frequency = *perLorisc::BreakpointPosition_frequency;
*amplitude = *perLorisc::BreakpointPosition_amplitude;
*bandwidth = *perLorisc::BreakpointPosition_bandwidth;
*phase = *perLorisc::BreakpointPosition_phase;
*setFrequency = *perLorisc::BreakpointPosition_setFrequency;
*setAmplitude = *perLorisc::BreakpointPosition_setAmplitude;
*setBandwidth = *perLorisc::BreakpointPosition_setBandwidth;
*setPhase = *perLorisc::BreakpointPosition_setPhase;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : perLoris::PartialIterator ##############

package perLoris::PartialIterator;
@ISA = qw( perLoris );
%OWNER = ();
%ITERATORS = ();
*time = *perLorisc::PartialIterator_time;
*breakpoint = *perLorisc::PartialIterator_breakpoint;
*copy = *perLorisc::PartialIterator_copy;
*next = *perLorisc::PartialIterator_next;
*prev = *perLorisc::PartialIterator_prev;
*equals = *perLorisc::PartialIterator_equals;
*isInRange = *perLorisc::PartialIterator_isInRange;
sub new {
    my $pkg = shift;
    my $self = perLorisc::new_PartialIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        perLorisc::delete_PartialIterator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : perLoris::PartialListIterator ##############

package perLoris::PartialListIterator;
@ISA = qw( perLoris );
%OWNER = ();
%ITERATORS = ();
*copy = *perLorisc::PartialListIterator_copy;
*next = *perLorisc::PartialListIterator_next;
*prev = *perLorisc::PartialListIterator_prev;
*partial = *perLorisc::PartialListIterator_partial;
*equals = *perLorisc::PartialListIterator_equals;
*isInRange = *perLorisc::PartialListIterator_isInRange;
sub new {
    my $pkg = shift;
    my $self = perLorisc::new_PartialListIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        perLorisc::delete_PartialListIterator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package perLoris;

1;
