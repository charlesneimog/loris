#ifndef INCLUDE_LORIS_H
#define INCLUDE_LORIS_H
/*
 * This is the Loris C++ Class Library, implementing analysis, 
 * manipulation, and synthesis of digitized sounds using the Reassigned 
 * Bandwidth-Enhanced Additive Sound Model.
 *
 * Loris is Copyright (c) 1999-2004 by Kelly Fitz and Lippold Haken
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY, without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 *	loris.h
 *
 *	Header specifying C-linkable procedural interface for Loris. 
 *
 *	Main components of this interface:
 *	- object interfaces - Analyzer, BreakpointEnvelope, PartialList, 
 *		and SampleVector need to be (opaque) objects in the interface, 
 * 		either because they hold state (e.g. Analyzer) or because they are 
 *		fundamental data types (e.g. Partial), so they need a procedural 
 *		interface to their member functions. All these things need to be 
 *		opaque pointers for the benefit of C.
 *	- non-object-based procedures - other classes in Loris are not so stateful,
 *		and have sufficiently narrow functionality that they need only 
 *		procedures, and no object representation.
 *	- utility functions - some procedures that are generally useful but are
 *		not part of the Loris core are also defined.
 *	- notification and exception handlers - all exceptions must be caught and
 *		handled internally, clients can specify an exception handler and 
 *		a notification function (the default one in Loris uses printf()).
 *
 *	loris.h is generated automatically from loris.h.in. Do not modify loris.h
 *
 * Kelly Fitz, 4 Feb 2002
 * loris@cerlsoundgroup.org
 *
 * http://www.cerlsoundgroup.org/Loris/
 *
 */
 
/* ---------------------------------------------------------------- */
/*		Loris version declarations
/*
/*	Define symbols that facilitate version/release identification.
 */
 
#define LORIS_MAJOR_VERSION @LORIS_MAJOR_VERSION@
#define LORIS_MINOR_VERSION @LORIS_MINOR_VERSION@
#define LORIS_SUBMINOR_VERSION @LORIS_SUBMINOR_VERSION@
#define LORIS_VERSION_STR "@LORIS_VERSION_STR@"

/* ---------------------------------------------------------------- */
/*		object type declarations
/*
/*	The following opaque pointer types are exposed procedurally 
	through this interface. Loris types and classes are all in the 
	C++ namespace Loris. Collections from the standard namespace 
	(namespace std) are also used.
 */
#if defined(__cplusplus)
	//	include std library headers, declaring template classes
	//	is too painful and fragile:
	#include <list>
	#include <vector>
	typedef std::vector< double > SampleVector;
	
	//	declare Loris classes in Loris namespace:
	namespace Loris
	{
		class Analyzer;
		class BreakpointEnvelope;
		class Partial;
		//	this has to be copied from PartialList.h
		typedef std::list< Loris::Partial > PartialList;
	}
#else 
	/* no classes, just opaque C pointers */
	typedef struct Analyzer Analyzer;
	typedef struct BreakpointEnvelope BreakpointEnvelope;
	typedef struct PartialList PartialList;
	typedef struct SampleVector SampleVector;
#endif

#if defined(__cplusplus)
	namespace Loris {
	extern "C" {
#endif

/* ---------------------------------------------------------------- */
/*		Analyzer object interface
/*
/*	An Analyzer represents a configuration of parameters for
	performing Reassigned Bandwidth-Enhanced Additive Analysis
	of sampled waveforms. This analysis process yields a collection 
	of Partials, each having a trio of synchronous, non-uniformly-
	sampled breakpoint envelopes representing the time-varying 
	frequency, amplitude, and noisiness of a single bandwidth-
	enhanced sinusoid. 

	For more information about Reassigned Bandwidth-Enhanced 
	Analysis and the Reassigned Bandwidth-Enhanced Additive Sound 
	Model, refer to the Loris website: www.cerlsoundgroup.org/Loris/.
	
	In C++, Analyzer is Loris::Analyzer, defined in Analyzer.h.
 */
Analyzer * createAnalyzer( double resolution, double windowWidth );
/*	Construct and return a new Analyzer configured with the given	
	frequency resolution (minimum instantaneous frequency	
	difference between Partials) and analysis window main 
	lobe width (between zeros). All other Analyzer parameters 	
	are computed from the specified  resolution and window width.
 */
void destroyAnalyzer( Analyzer * ptr_this );
/*	Destroy this Analyzer. 								
 */
void analyzer_analyze( Analyzer * ptr_this, 
					   const SampleVector * vec, double srate,
					   PartialList * partials );
/*	Analyze a vector of (mono) samples at the given sample rate 	  	
	(in Hz) and append the extracted Partials to the given 
	PartialList. 												
 */
double analyzer_getFreqResolution( const Analyzer * ptr_this );
/*	Return the frequency resolution (minimum instantaneous frequency  		
	difference between Partials) for this Analyzer. 	
 */
void analyzer_setFreqResolution( Analyzer * ptr_this, double x );
/*	Set the frequency resolution (minimum instantaneous frequency  		
	difference between Partials) for this Analyzer. (Does not cause 	
	other parameters to be recomputed.) 									
 */
double analyzer_getAmpFloor( const Analyzer * ptr_this );
/*	Return the amplitude floor (lowest detected spectral amplitude),  			
	in (negative) dB, for this Analyzer. 				
 */
void analyzer_setAmpFloor( Analyzer * ptr_this, double x );
/*	Set the amplitude floor (lowest detected spectral amplitude), in  			
	(negative) dB, for this Analyzer. 				
 */
double analyzer_getWindowWidth( const Analyzer * ptr_this );
/*	Return the frequency-domain main lobe width (measured between 
	zero-crossings) of the analysis window used by this Analyzer. 				
 */
void analyzer_setWindowWidth( Analyzer * ptr_this, double x );
/*	Set the frequency-domain main lobe width (measured between 
	zero-crossings) of the analysis window used by this Analyzer. 				
 */
double analyzer_getSidelobeLevel( const Analyzer * ptr_this );
/*	Return the sidelobe attenutation level for the Kaiser analysis window in
	positive dB. More negative numbers (e.g. -90) give very good sidelobe 
	rejection but cause the window to be longer in time. Less negative 
	numbers raise the level of the sidelobes, increasing the likelihood
	of frequency-domain interference, but allow the window to be shorter
	in time.
 */
void analyzer_setSidelobeLevel( Analyzer * ptr_this, double x );
/*	Set the sidelobe attenutation level for the Kaiser analysis window in
	positive dB. More negative numbers (e.g. -90) give very good sidelobe 
	rejection but cause the window to be longer in time. Less negative 
	numbers raise the level of the sidelobes, increasing the likelihood
	of frequency-domain interference, but allow the window to be shorter
	in time.
 */
double analyzer_getFreqFloor( const Analyzer * ptr_this );
/*	Return the frequency floor (minimum instantaneous Partial  				
	frequency), in Hz, for this Analyzer. 				
 */
void analyzer_setFreqFloor( Analyzer * ptr_this, double x );
/*	Set the amplitude floor (minimum instantaneous Partial  				
	frequency), in Hz, for this Analyzer.
 */
double analyzer_getFreqDrift( const Analyzer * ptr_this );
/*	Return the maximum allowable frequency difference between 					
	consecutive Breakpoints in a Partial envelope for this Analyzer. 				
 */
void analyzer_setFreqDrift( Analyzer * ptr_this, double x );
/*	Set the maximum allowable frequency difference between 					
	consecutive Breakpoints in a Partial envelope for this Analyzer. 				
 */
double analyzer_getHopTime( const Analyzer * ptr_this );
/*	Return the hop time (which corresponds approximately to the 
	average density of Partial envelope Breakpoint data) for this 
	Analyzer.
 */
void analyzer_setHopTime( Analyzer * ptr_this, double x );
/*	Set the hop time (which corresponds approximately to the average
	density of Partial envelope Breakpoint data) for this Analyzer.
 */
double analyzer_getCropTime( const Analyzer * ptr_this );
/*	Return the crop time (maximum temporal displacement of a time-
	frequency data point from the time-domain center of the analysis
	window, beyond which data points are considered "unreliable")
	for this Analyzer.
 */
void analyzer_setCropTime( Analyzer * ptr_this, double x );
/*	Set the crop time (maximum temporal displacement of a time-
	frequency data point from the time-domain center of the analysis
	window, beyond which data points are considered "unreliable")
	for this Analyzer.
 */
double analyzer_getBwRegionWidth( const Analyzer * ptr_this );
/*	Return the width (in Hz) of the Bandwidth Association regions
	used by this Analyzer.
 */
void analyzer_setBwRegionWidth( Analyzer * ptr_this, double x );
/*	Set the width (in Hz) of the Bandwidth Association regions
	used by this Analyzer.
 */

/* ---------------------------------------------------------------- */
/*		BreakpointEnvelope object interface								
/*
/*	A BreakpointEnvelope represents a linear segment breakpoint 
	function with infinite extension at each end (that is, the 
	values past either end of the breakpoint function have the 
	values at the nearest end).

	In C++, a BreakpointEnvelope is a Loris::BreakpointEnvelope.
 */
 
BreakpointEnvelope * createBreakpointEnvelope( void );
/*	Construct and return a new BreakpointEnvelope having no 
	breakpoints and an implicit value of 0. everywhere, 
	until the first breakpoint is inserted.			
 */

BreakpointEnvelope * copyBreakpointEnvelope( const BreakpointEnvelope * ptr_this );
/*	Construct and return a new BreakpointEnvelope that is an
	exact copy of the specified BreakpointEnvelopes, having 
	an identical set of breakpoints.	
 */

void destroyBreakpointEnvelope( BreakpointEnvelope * ptr_this );
/*	Destroy this BreakpointEnvelope. 								
 */
 
void breakpointEnvelope_insertBreakpoint( BreakpointEnvelope * ptr_this,
					double time, double val );
/*	Insert a breakpoint representing the specified (time, value) 
	pair into this BreakpointEnvelope. If there is already a 
	breakpoint at the specified time, it will be replaced with 
	the new breakpoint.
 */

double breakpointEnvelope_valueAt( const BreakpointEnvelope * ptr_this, 
								   double time );
/*	Return the interpolated value of this BreakpointEnvelope at the 
	specified time.							
 */

/* ---------------------------------------------------------------- */
/*		PartialList object interface
/*
/*	A PartialList represents a collection of Bandwidth-Enhanced 
	Partials, each having a trio of synchronous, non-uniformly-
	sampled breakpoint envelopes representing the time-varying 
	frequency, amplitude, and noisiness of a single bandwidth-
	enhanced sinusoid.

	For more information about Bandwidth-Enhanced Partials and the  
	Reassigned Bandwidth-Enhanced Additive Sound Model, refer to
	the Loris website: www.cerlsoundgroup.org/Loris/.

	In C++, a PartialList is a Loris::PartialList.
 */ 
PartialList * createPartialList( void );
/*	Return a new empty PartialList.
 */
void destroyPartialList( PartialList * ptr_this );
/*	Destroy this PartialList.
 */
void partialList_clear( PartialList * ptr_this );
/*	Remove (and destroy) all the Partials from this PartialList,
	leaving it empty.
 */
void partialList_copy( PartialList * ptr_this, 
					   const PartialList * src );
/*	Make this PartialList a copy of the source PartialList by making
	copies of all of the Partials in the source and adding them to 
	this PartialList.
 */
unsigned long partialList_size( const PartialList * ptr_this );
/*	Return the number of Partials in this PartialList.
 */
void partialList_splice( PartialList * ptr_this, 
						 PartialList * src );
/*	Splice all the Partials in the source PartialList onto the end of
	this PartialList, leaving the source empty.
 */

/* ---------------------------------------------------------------- */
/*		SampleVector object interface								
/*
/*	A SampleVector represents a vector of floating point samples of
	an audio waveform. In Loris, the samples are assumed to have 
	values on the range (-1., 1.) (though this is not enforced or 
	checked). 

	In C++, a SampleVector is a std::vector< double >.
 */
 
SampleVector * createSampleVector( unsigned long size );
/*	Return a new SampleVector having the specified number of samples,
	all of whose value is 0.
 */
void destroySampleVector( SampleVector * ptr_this );
/*	Destroy this SampleVector.
 */
void sampleVector_assign( SampleVector * ptr_this, 
						  const SampleVector * src );
/*	Assign the contents of the source SampleVector to this (the 
	destination) SampleVector, so that the two have identical contents. 
	
	This is a more intuitive name for the operation sampleVector_copy.
 */
void sampleVector_copy( SampleVector * ptr_this, 
						const SampleVector * src );
/*	Make this SampleVector a copy of the source SampleVector, having 
	the same number of samples, and samples at every position in this
	SampleVector having the same value as the corresponding sample in
	the source.
 */
void sampleVector_fill( SampleVector * vec, double * buffer, 
						unsigned long bufsize );
/*	Fill this SampleVector with sampless stored in a buffer of 
	doubles. All the samples in the buffer are stored, the 
	SampleVector will be resized if it is smaller than bufsize.
	If the SampleVector is larger than bufsize, the extra space
	will be filled with zeros.
 */

double sampleVector_getAt( const SampleVector * ptr_this, unsigned long idx );
/*	Return the value of the sample at the given position (index) in
	this SampleVector.
 */
void sampleVector_setAt( SampleVector * ptr_this, unsigned long idx, double x );
/*	Set the value of the sample at the given position (index) in
	this SampleVector.
 */
unsigned long sampleVector_getLength( const SampleVector * ptr_this );
/*	Return the number of samples represented by this SampleVector.
 */
void sampleVector_setLength( SampleVector * ptr_this, unsigned long size );
/*	Change the number of samples represented by this SampleVector. If
	the given size is greater than the current size, all new samples 
	will have value 0. If the given size is less than the current 
	size, then samples in excess of the given size are removed.
 */

/* ---------------------------------------------------------------- */
/*		non-object-based procedures
/*
/*	Operations in Loris that need not be accessed though object
	interfaces are represented as simple functions.
 */

void channelize( PartialList * partials, 
				 BreakpointEnvelope * refFreqEnvelope, int refLabel );
/*	Label Partials in a PartialList with the integer nearest to
	the amplitude-weighted average ratio of their frequency envelope
	to a reference frequency envelope. The frequency spectrum is 
	partitioned into non-overlapping channels whose time-varying 
	center frequencies track the reference frequency envelope. 
	The reference label indicates which channel's center frequency
	is exactly equal to the reference envelope frequency, and other
	channels' center frequencies are multiples of the reference 
	envelope frequency divided by the reference label. Each Partial 
	in the PartialList is labeled with the number of the channel
	that best fits its frequency envelope. The quality of the fit
	is evaluated at the breakpoints in the Partial envelope and
	weighted by the amplitude at each breakpoint, so that high-
	amplitude breakpoints contribute more to the channel decision.
	Partials are labeled, but otherwise unmodified. In particular, 
	their frequencies are not modified in any way.
 */

BreakpointEnvelope * createFreqReference( PartialList * partials, 
										  double minFreq, double maxFreq, 
										  long numSamps );
/*	Return a newly-constructed BreakpointEnvelope by sampling the 
	frequency envelope of the longest Partial in a PartialList. 
	Only Partials whose frequency at the Partial's loudest (highest 
	amplitude) breakpoint is within the given frequency range are 
	considered. The envelope will have the specified number of samples.
	If the specified number of samples is 0, then the
	longest Partial's frequency envelope is sampled every 30 ms
	(No fewer than 10 samples are used, so the sampling maybe more
	dense for very short Partials.) 
	
	For very simple sounds, this frequency reference may be a 
	good first approximation to a reference envelope for
	channelization (see channelize()).
	
	Clients are responsible for disposing of the newly-constructed 
	BreakpointEnvelope.
 */
 
void dilate( PartialList * partials, 
			 const double * initial, const double * target, int npts );
/*	Dilate Partials in a PartialList according to the given 
	initial and target time points. Partial envelopes are 
	stretched and compressed so that temporal features at
	the initial time points are aligned with the final time
	points. Time points are sorted, so Partial envelopes are 
	are only stretched and compressed, but breakpoints are not
	reordered. Duplicate time points are allowed. There must be
	the same number of initial and target time points.
 */

void distill( PartialList * partials );
/*	Distill labeled (channelized)  Partials in a PartialList into a 
	PartialList containing a single (labeled) Partial per label. 
	The distilled PartialList will contain as many Partials as
	there were non-zero labels in the original PartialList. Unlabeled 
	(label 0) Partials are eliminated.
 */

void exportAiff( const char * path, const SampleVector * vec, 
				 double samplerate, int nchannels, int bitsPerSamp );
/*	Export audio samples stored in a SampleVector to an AIFF file
	having the specified number of channels and sample rate at the 
	given file path (or name). The floating point samples in the 
	SampleVector are clamped to the range (-1.,1.) and converted 
	to integers having bitsPerSamp bits.
 */
				 
void exportSdif( const char * path, PartialList * partials );
/*	Export Partials in a PartialList to a SDIF file at the specified
	file path (or name). SDIF data is described by RBEM and RBEL 
	matrices. 
	For more information about SDIF, see the SDIF web site at:
		www.ircam.fr/equipes/analyse-synthese/sdif/  
 */
				
void exportSpc( const char * path, PartialList * partials, double midiPitch, 
				int enhanced, double endApproachTime );
/*	Export Partials in a PartialList to a Spc file at the specified file
	path (or name). The fractional MIDI pitch must be specified. The 
	enhanced parameter defaults to true (for bandwidth-enhanced spc files), 
	but an be specified false for pure-sines spc files. The endApproachTime 
	parameter is in seconds. A nonzero endApproachTime indicates that the plist does 
	not include a release, but rather ends in a static spectrum corresponding 
	to the final breakpoint values of the partials. The endApproachTime
	specifies how long before the end of the sound the amplitude, frequency, 
	and bandwidth values are to be modified to make a gradual transition to 
	the static spectrum.
 */
				
void importAiff( const char * path, SampleVector * vec, 
				 double * samplerate, int * nchannels );
/*	Import audio samples stored in an AIFF file at the given file
	path (or name). The samples are converted to floating point 
	values on the range (-1.,1.) and stored in the given 
	SampleVector, which is resized to (exactly) accomodate all the 
	samples from in the file. If samplerate is not a NULL pointer, 
	then, on return, it points to the value of the sample rate (in
	Hz) of the AIFF samples. Similarly, if nchannels is not a NULL
	pointer, then, on return, it points to the value of the number
	of channels of audio data represented by the AIFF samples.
 */

void importSdif( const char * path, PartialList * partials );
/*	Import Partials from an SDIF file at the given file path (or 
	name), and append them to a PartialList.
 */	

void importSpc( const char * path, PartialList * partials );
/*	Import Partials from an Spc file at the given file path (or 
	name), and return them in a PartialList.
 */	

void morph( const PartialList * src0, const PartialList * src1, 
			const BreakpointEnvelope * ffreq, 
			const BreakpointEnvelope * famp, 
			const BreakpointEnvelope * fbw, 
			PartialList * dst );
/*	Morph labeled Partials in two PartialLists according to the
	given frequency, amplitude, and bandwidth (noisiness) morphing
	envelopes, and append the morphed Partials to the destination 
	PartialList. Loris morphs Partials by interpolating frequency,
	amplitude, and bandwidth envelopes of corresponding Partials in 
	the source PartialLists. For more information about the Loris
	morphing algorithm, see the Loris website: 
	www.cerlsoundgroup.org/Loris/
 */

void resample( PartialList * partials, double interval );
/*  Resample all Partials in a PartialList using the specified
	sampling interval, so that the Breakpoints in the Partial 
	envelopes will all lie on a common temporal grid.
	The Breakpoint times in resampled Partials will comprise a  
	contiguous sequence of integer multiples of the sampling interval,
	beginning with the multiple nearest to the Partial's start time and
	ending with the multiple nearest to the Partial's end time. Resampling
	is performed in-place. 

 */

void sift( PartialList * partials );
/*  Eliminate overlapping Partials having the same label
    (except zero). If any two partials with same label
    overlap in time, keep only the longer of the two.
    Set the label of the shorter duration partial to zero.

 */ 

void synthesize( const PartialList * partials,
				 SampleVector * samples,  
				 double srate );
/*	Synthesize Partials in a PartialList at the given sample
	rate, and store the (floating point) samples in a SampleVector.
	The SampleVector is resized, if necessary, to hold as many
	samples as are needed for the complete synthesis of all the
	Partials in the PartialList. The SampleVector is not 
	cleared before synthesis, so newly synthesized samples are
	added to any previously computed samples in the SampleVector.
 */

/* ---------------------------------------------------------------- */
/*		utility functions
/*
/*	These procedures are generally useful but are not   
	represented by classes in the Loris core.
 */

void copyByLabel( const PartialList * src, long label, PartialList * dst );
/*	Old name for copyLabeled.
 */
 
void copyLabeled( const PartialList * src, long label, PartialList * dst );
/*	Append copies of Partials in the source PartialList having the
	specified label to the destination PartialList. The source list
	is unmodified.
 */

void crop( PartialList * partials, double t1, double t2 );
/*	Trim Partials by removing Breakpoints outside a specified time span.
	Insert a Breakpoint at the boundary when cropping occurs.
 */

void extractLabeled( PartialList * src, long label, PartialList * dst );
/*  Remove Partials in the source PartialList having the specified
    label from the source list and append them to the destination 
    PartialList. 
 */

void removeLabeled( PartialList * src, long label );
/*  Remove from a PartialList all Partials having the specified label.
 */

void scaleAmp( PartialList * partials, BreakpointEnvelope * ampEnv );
/*	Scale the amplitude of the Partials in a PartialList according 
	to an envelope representing a time-varying amplitude scale value.
 */
				 
void scaleBandwidth( PartialList * partials, BreakpointEnvelope * bwEnv );
/*	Scale the bandwidth of the Partials in a PartialList according 
	to an envelope representing a time-varying bandwidth scale value.
 */
				 
void scaleFrequency( PartialList * partials, BreakpointEnvelope * freqEnv );
/*	Scale the frequency of the Partials in a PartialList according 
	to an envelope representing a time-varying frequency scale value.
 */
				 
void scaleNoiseRatio( PartialList * partials, BreakpointEnvelope * noiseEnv );
/*	Scale the relative noise content of the Partials in a PartialList 
	according to an envelope representing a (time-varying) noise energy 
	scale value.
 */

void shiftPitch( PartialList * partials, BreakpointEnvelope * pitchEnv );
/*	Shift the pitch of all Partials in a PartialList according to 
	the given pitch envelope. The pitch envelope is assumed to have 
	units of cents (1/100 of a halfstep).
 */

void shiftTime( PartialList * partials, double offset );
/*	Shift the time of all the Breakpoints in a Partial by a 
	constant amount.
 */

void sortByLabel( PartialList * partials );
/*	Sort the Partials in a PartialList in order of increasing label.
 	The sort is stable; Partials having the same label are not 
 	reordered.
 */

void spliceByLabel( PartialList * src, long label, PartialList * dst );
/*  Old name for extractLabeled. 
 */



/* ---------------------------------------------------------------- */
/*		Notification and exception handlers							
/*
/*
	An exception handler and a notifier may be specified. Both 
	are functions taking a const char * argument and returning
	void.
 */

void setExceptionHandler( void(*f)(const char *) );
/*	Specify a function to call when reporting exceptions. The 
	function takes a const char * argument, and returns void.
 */

void setNotifier( void(*f)(const char *) );
/*	Specify a notification function. The function takes a 
	const char * argument, and returns void.
 */

#if defined(__cplusplus)
}	/* extern "C" 	*/
}	/* end of namespace Loris */
#endif

#endif	/* ndef INCLUDE_LORIS_H */
