#ifndef INCLUDE_SYNTHESIZER_H
#define INCLUDE_SYNTHESIZER_H
/*
 * This is the Loris C++ Class Library, implementing analysis, 
 * manipulation, and synthesis of digitized sounds using the Reassigned 
 * Bandwidth-Enhanced Additive Sound Model.
 *
 * Loris is Copyright (c) 1999-2000 by Kelly Fitz and Lippold Haken
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY, without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * Synthesizer.h
 *
 * Definition of class Loris::SynthesizerSynthesizer, a synthesizer of 
 * bandwidth-enhanced Partials.
 *
 * Kelly Fitz, 16 Aug 1999
 * loris@cerlsoundgroup.org
 *
 * http://www.cerlsoundgroup.org/Loris/
 *
 */

#include <memory>
#include <vector>

//	begin namespace
namespace Loris {

class Synthesizer_imp;
class Partial;

// ---------------------------------------------------------------------------
//	class Synthesizer
//	
//	Class Synthesizer represents an algorithm for rendering
//	bandwidth-enhanced Partials as floating point (double) samples at a
//	specified sampling rate, and accumulating them into a buffer. The
//	Synthesizer does not own the sample buffer, the client is responsible
//	for its construction and destruction, and many Synthesizers may share
//	a buffer.
//
class Synthesizer
{
//	-- instance variables --
	std::auto_ptr< Synthesizer_imp > _imp;

//	-- public interface --
public:
//	-- construction --
	Synthesizer( double srate, double * bufStart, double * bufEnd, double fadeTime = .001 );
	/*	Construct a Synthesizer using the specified sampling rate, sample
		buffer (specified by its endpoints, in the STL style), and Partial
		fade time (in seconds). Since Partials generated by the Loris Analyzer
		generally begin and end at non-zero amplitude, zero-amplitude
		Breakpoints are inserted at either end of the Partial, at a temporal
		distance equal to the fade time, to reduce turn-on and turn-off
		artifacts. If the fade time is unspecified, the default value of one
		millisecond (0.001 seconds) is used.
	 */
	 
	Synthesizer( double srate, std::vector<double> & buffer, double fadeTime = .001 );
	/*	Construct a Synthesizer using the specified sampling rate, sample
		buffer (a standard library vector), and Partial
		fade time (in seconds). Since Partials generated by the Loris Analyzer
		generally begin and end at non-zero amplitude, zero-amplitude
		Breakpoints are inserted at either end of the Partial, at a temporal
		distance equal to the fade time, to reduce turn-on and turn-off
		artifacts. If the fade time is unspecified, the default value of one
		millisecond (0.001 seconds) is used.
	 */
	 
	Synthesizer( const Synthesizer & other );
	/*	Construct a Synthesizer that is an exact copy of another Synthesizer,
		that is, uses the same sample buffer, sampling rate, and fade time.
	 */
	 
	~Synthesizer(void);
	/*	 Destroy this Synthesizer. (Does not destroy the sample buffer.)
	 */
	
	Synthesizer & operator= ( const Synthesizer & other );
	/*	Assignment operator: change this synthesizer to be an exact copy
		of the specified Synthesizer, rhs, that is, using the same sample
		buffer, sampling rate, and fade time.
	 */
	 
//	-- synthesis --
	void synthesize( const Partial & p, double timeShift = 0. ) const;	
	/*	Synthesize a bandwidth-enhanced sinusoidal Partial with the
		(optionally) specified timeShift (in seconds). Zero-amplitude
		Breakpoints are inserted at either end of the Partial to reduce
		turn-on and turn-off artifacts, as described above. The client is
		responsible or insuring that this Synthesizer's buffer is long enough
		to hold all samples from the time-shifted and padded Partials.
		Synthesizer will not generate samples outside the buffer, but neither
		will any attempt be made to eliminate clicks at the buffer boundaries.
		If the time shift is unspecified, no time shift is used.
	 */
	 
	void operator() ( const Partial & p, double timeShift = 0. ) const
		{ synthesize( p, timeShift ) ; }
	/*	Function call operator: same as synthesize( p, timeShift ).
	 */

#if ! defined(NO_TEMPLATE_MEMBERS)
	template<typename Iter>
	void synthesize( Iter begin_partials, Iter end_partials, double timeShift = 0. ) const;
#else
	void synthesize( PartialList::iterator begin_partials, PartialList::iterator end_partials, 
					 double timeShift = 0. ) const;	
#endif
	/*	Synthesize all Partials on the specified half-open (STL-style) range
		with the (optionally) specified timeShift (in seconds). Zero-amplitude
		Breakpoints are inserted at either end of the Partial to reduce
		turn-on and turn-off artifacts, as described above. The client is
		responsible or insuring that this Synthesizer's buffer is long enough
		to hold all samples from the time-shifted and padded Partials.
		Synthesizer will not generate samples outside the buffer, but neither
		will any attempt be made to eliminate clicks at the buffer boundaries.
		If the time shift is unspecified, no time shift is used.
	 */
	 
#if ! defined(NO_TEMPLATE_MEMBERS)
	template<typename Iter>
	void operator() ( Iter begin_partials, Iter end_partials, double timeShift = 0. ) const;
#else
	void operator() ( PartialList::iterator begin_partials, PartialList::iterator end_partials, 
					  double timeShift = 0. ) const;
#endif
	/*	Function call operator: same as 
		synthesize( begin_partials, end_partials, timeShift ).
	 */
	
//	-- access --
	double fadeTime( void ) const;
	/* 	Return this Synthesizer's Partial fade time, in seconds.
	 */
	 
	long numSamples( void ) const;
	/*	Return the size of the sample buffer used (but not owned) by
		this Synthesizer.
	 */
	 
	double sampleRate( void ) const;
	/*	Return the sampling rate (in Hz) for this Synthesizer.
	 */

	const double * samples( void ) const;
	double * samples( void );
	/*	Return a pointer to the beginning of the sample buffer used (but not
		owned) by this Synthesizer. For immutable (const) Synthesizers, this
		member returns a pointer to the beginning of an immutable sample
		buffer (const double *).
	 */
	
//	-- mutation --
	void setFadeTime( double partialFadeTime );
	/*	Set this Synthesizer's fade time to the specified value 
		(in seconds, must be non-negative).
	 */
	 
};	//	end of class Synthesizer

// ---------------------------------------------------------------------------
//	synthesize 
// ---------------------------------------------------------------------------
//	Synthesize all Partials on the specified half-open (STL-style) range
//	with the (optionally) specified timeShift (in seconds). Zero-amplitude
//	Breakpoints are inserted at either end of the Partial to reduce
//	turn-on and turn-off artifacts, as described above. The client is
//	responsible or insuring that this Synthesizer's buffer is long enough
//	to hold all samples from the time-shifted and padded Partials.
//	Synthesizer will not generate samples outside the buffer, but neither
//	will any attempt be made to eliminate clicks at the buffer boundaries.
//	If the time shift is unspecified, no time shift is used.
//
#if ! defined(NO_TEMPLATE_MEMBERS)
template<typename Iter>
void 
Synthesizer::synthesize( Iter begin_partials, Iter end_partials, 
						 double timeShift ) const
#else
inline void 
Synthesizer::synthesize( PartialList::iterator begin_partials, 
						 PartialList::iterator end_partials, 
						 double timeShift ) const
#endif
{ 
	while ( begin_partials != end_partials ) 
		synthesize( *(begin_partials++), timeShift ); 
}

// ---------------------------------------------------------------------------
//	operator() 
// ---------------------------------------------------------------------------
//	Function call operator: same as 
//		synthesize( begin_partials, end_partials, timeShift ).
//
#if ! defined(NO_TEMPLATE_MEMBERS)
template<typename Iter>
void
Synthesizer::operator() ( Iter begin_partials, Iter end_partials, 
						  double timeShift ) const
#else
inline void
Synthesizer::operator() ( PartialList::iterator begin_partials, 
						  PartialList::iterator end_partials, 
						  double timeShift ) const
#endif
{ 
	synthesize( begin_partials, end_partials, timeShift ); 
}

}	//	end of namespace Loris

#endif /* ndef INCLUDE_SYNTHESIZER_H */
